--- linux-2.6.35.7/arch/arm/mach-s5pv210/clock.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/clock.c	2011-08-08 12:52:05.000000000 +0800
@@ -19,6 +19,8 @@
 #include <linux/clk.h>
 #include <linux/sysdev.h>
 #include <linux/io.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
 
 #include <mach/map.h>
 
@@ -30,14 +32,18 @@
 #include <plat/s5p-clock.h>
 #include <plat/clock-clksrc.h>
 #include <plat/s5pv210.h>
+#include <plat/devs.h>
+#include <mach/regs-audss.h>
+
+static int s5pv210_usbosc_enable(struct clk *clk, int enable);
 
 static struct clksrc_clk clk_mout_apll = {
 	.clk	= {
 		.name		= "mout_apll",
 		.id		= -1,
 	},
-	.sources	= &clk_src_apll,
-	.reg_src	= { .reg = S5P_CLK_SRC0, .shift = 0, .size = 1 },
+	.sources = &clk_src_apll,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 0, .size = 1 },
 };
 
 static struct clksrc_clk clk_mout_epll = {
@@ -45,17 +51,17 @@
 		.name		= "mout_epll",
 		.id		= -1,
 	},
-	.sources	= &clk_src_epll,
-	.reg_src	= { .reg = S5P_CLK_SRC0, .shift = 8, .size = 1 },
+	.sources = &clk_src_epll,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 8, .size = 1 },
 };
 
 static struct clksrc_clk clk_mout_mpll = {
-	.clk = {
+	.clk	= {
 		.name		= "mout_mpll",
 		.id		= -1,
 	},
-	.sources	= &clk_src_mpll,
-	.reg_src	= { .reg = S5P_CLK_SRC0, .shift = 4, .size = 1 },
+	.sources = &clk_src_mpll,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 4, .size = 1 },
 };
 
 static struct clk *clkset_armclk_list[] = {
@@ -73,9 +79,9 @@
 		.name		= "armclk",
 		.id		= -1,
 	},
-	.sources	= &clkset_armclk,
-	.reg_src	= { .reg = S5P_CLK_SRC0, .shift = 16, .size = 1 },
-	.reg_div	= { .reg = S5P_CLK_DIV0, .shift = 0, .size = 3 },
+	.sources = &clkset_armclk,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 16, .size = 1 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 0, .size = 3 },
 };
 
 static struct clksrc_clk clk_hclk_msys = {
@@ -84,7 +90,7 @@
 		.id		= -1,
 		.parent		= &clk_armclk.clk,
 	},
-	.reg_div	= { .reg = S5P_CLK_DIV0, .shift = 8, .size = 3 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 8, .size = 3 },
 };
 
 static struct clksrc_clk clk_pclk_msys = {
@@ -93,7 +99,7 @@
 		.id		= -1,
 		.parent		= &clk_hclk_msys.clk,
 	},
-	.reg_div        = { .reg = S5P_CLK_DIV0, .shift = 12, .size = 3 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 12, .size = 3 },
 };
 
 static struct clksrc_clk clk_sclk_a2m = {
@@ -102,7 +108,7 @@
 		.id		= -1,
 		.parent		= &clk_mout_apll.clk,
 	},
-	.reg_div	= { .reg = S5P_CLK_DIV0, .shift = 4, .size = 3 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 4, .size = 3 },
 };
 
 static struct clk *clkset_hclk_sys_list[] = {
@@ -117,40 +123,40 @@
 
 static struct clksrc_clk clk_hclk_dsys = {
 	.clk	= {
-		.name	= "hclk_dsys",
-		.id	= -1,
+		.name		= "hclk_dsys",
+		.id		= -1,
 	},
-	.sources	= &clkset_hclk_sys,
-	.reg_src        = { .reg = S5P_CLK_SRC0, .shift = 20, .size = 1 },
-	.reg_div        = { .reg = S5P_CLK_DIV0, .shift = 16, .size = 4 },
+	.sources = &clkset_hclk_sys,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 20, .size = 1 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 16, .size = 4 },
 };
 
 static struct clksrc_clk clk_pclk_dsys = {
 	.clk	= {
-		.name	= "pclk_dsys",
-		.id	= -1,
-		.parent	= &clk_hclk_dsys.clk,
+		.name		= "pclk_dsys",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
 	},
 	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 20, .size = 3 },
 };
 
 static struct clksrc_clk clk_hclk_psys = {
 	.clk	= {
-		.name	= "hclk_psys",
-		.id	= -1,
+		.name		= "hclk_psys",
+		.id		= -1,
 	},
-	.sources	= &clkset_hclk_sys,
-	.reg_src        = { .reg = S5P_CLK_SRC0, .shift = 24, .size = 1 },
-	.reg_div        = { .reg = S5P_CLK_DIV0, .shift = 24, .size = 4 },
+	.sources = &clkset_hclk_sys,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 24, .size = 1 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 24, .size = 4 },
 };
 
 static struct clksrc_clk clk_pclk_psys = {
 	.clk	= {
-		.name	= "pclk_psys",
-		.id	= -1,
-		.parent	= &clk_hclk_psys.clk,
+		.name		= "pclk_psys",
+		.id		= -1,
+		.parent		= &clk_hclk_psys.clk,
 	},
-	.reg_div        = { .reg = S5P_CLK_DIV0, .shift = 28, .size = 3 },
+	.reg_div = { .reg = S5P_CLK_DIV0, .shift = 28, .size = 3 },
 };
 
 static int s5pv210_clk_ip0_ctrl(struct clk *clk, int enable)
@@ -178,6 +184,11 @@
 	return s5p_gatectrl(S5P_CLKGATE_IP4, clk, enable);
 }
 
+static int s5pv210_clk_ip5_ctrl(struct clk *clk, int enable)
+{
+	return s5p_gatectrl(S5P_CLKGATE_IP5, clk, enable);
+}
+
 static int s5pv210_clk_mask0_ctrl(struct clk *clk, int enable)
 {
 	return s5p_gatectrl(S5P_CLK_SRC_MASK0, clk, enable);
@@ -188,6 +199,11 @@
 	return s5p_gatectrl(S5P_CLK_SRC_MASK1, clk, enable);
 }
 
+static int s5pv210_clk_audss_ctrl(struct clk *clk, int enable)
+{
+	return s5p_gatectrl(S5P_CLKGATE_AUDSS, clk, enable);
+}
+
 static struct clk clk_sclk_hdmi27m = {
 	.name		= "sclk_hdmi27m",
 	.id		= -1,
@@ -209,6 +225,21 @@
 	.id		= -1,
 };
 
+static struct clk clk_i2scdclk0 = {
+	.name		= "i2scdclk",
+	.id		= 0,
+};
+
+static struct clk clk_i2scdclk1 = {
+	.name		= "i2scdclk",
+	.id		= 1,
+};
+
+static struct clk clk_i2scdclk2 = {
+	.name		= "i2scdclk",
+	.id		= 2,
+};
+
 static struct clk clk_pcmcdclk0 = {
 	.name		= "pcmcdclk",
 	.id		= -1,
@@ -241,8 +272,8 @@
 		.enable		= s5pv210_clk_mask0_ctrl,
 		.ctrlbit	= (1 << 7),
 	},
-	.sources	= &clkset_vpllsrc,
-	.reg_src	= { .reg = S5P_CLK_SRC1, .shift = 28, .size = 1 },
+	.sources = &clkset_vpllsrc,
+	.reg_src = { .reg = S5P_CLK_SRC1, .shift = 28, .size = 1 },
 };
 
 static struct clk *clkset_sclk_vpll_list[] = {
@@ -260,8 +291,8 @@
 		.name		= "sclk_vpll",
 		.id		= -1,
 	},
-	.sources	= &clkset_sclk_vpll,
-	.reg_src	= { .reg = S5P_CLK_SRC0, .shift = 12, .size = 1 },
+	.sources = &clkset_sclk_vpll,
+	.reg_src = { .reg = S5P_CLK_SRC0, .shift = 12, .size = 1 },
 };
 
 static unsigned long s5pv210_clk_imem_get_rate(struct clk *clk)
@@ -293,11 +324,67 @@
 		.enable		= s5pv210_clk_ip1_ctrl,
 		.ctrlbit	= (1<<17),
 	}, {
-		.name		= "lcd",
+		.name		= "jpeg",
 		.id		= -1,
 		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip5_ctrl,
+		.ctrlbit	= S5P_CLKGATE_IP5_JPEG,
+	}, {
+		.name		= "mfc",
+		.id		= -1,
+		.parent		= &clk_hclk_msys.clk,
+		.enable		= s5pv210_clk_ip0_ctrl,
+		.ctrlbit	= (1<<16),
+	}, {
+		.name		= "sclk_fimc_lclk",
+		.id		= 0,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip0_ctrl,
+		.ctrlbit	= (1<<24),
+	}, {
+		.name		= "sclk_fimc_lclk",
+		.id		= 1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip0_ctrl,
+		.ctrlbit	= (1<<25),
+	}, {
+		.name		= "sclk_fimc_lclk",
+		.id		= 2,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip0_ctrl,
+		.ctrlbit	= (1<<26),
+	}, {
+		.name		= "otg",
+		.id		= -1,
+		.parent		= &clk_hclk_psys.clk,
 		.enable		= s5pv210_clk_ip1_ctrl,
-		.ctrlbit	= (1<<0),
+		.ctrlbit	= (1<<16),
+	}, {
+		.name		= "usb-host",
+		.id		= -1,
+		.parent		= &clk_hclk_psys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1<<17),
+	}, {
+		.name		= "dsim",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1<<2),
+	}, {
+		.name		= "onenand",
+		.id		= -1,
+		.parent		= &clk_hclk_psys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1 << 24),
+		.dev		= &s5pc110_device_onenand.dev,
+	}, {
+		.name		= "nand",
+		.id		= -1,
+		.parent		= &clk_hclk_psys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= ((1 << 28) | (1 << 24)),
+		.dev		= &s3c_device_nand.dev,
 	}, {
 		.name		= "cfcon",
 		.id		= 0,
@@ -335,12 +422,6 @@
 		.enable		= s5pv210_clk_ip3_ctrl,
 		.ctrlbit	= (1<<16),
 	}, {
-		.name		= "watchdog",
-		.id		= -1,
-		.parent		= &clk_pclk_psys.clk,
-		.enable		= s5pv210_clk_ip3_ctrl,
-		.ctrlbit	= (1<<22),
-	}, {
 		.name		= "rtc",
 		.id		= -1,
 		.parent		= &clk_pclk_psys.clk,
@@ -357,7 +438,7 @@
 		.id		= 1,
 		.parent		= &clk_pclk_psys.clk,
 		.enable		= s5pv210_clk_ip3_ctrl,
-		.ctrlbit	= (1<<8),
+		.ctrlbit	= (1<<10),
 	}, {
 		.name		= "i2c",
 		.id		= 2,
@@ -418,11 +499,139 @@
 		.parent		= &clk_p,
 		.enable		= s5pv210_clk_ip3_ctrl,
 		.ctrlbit	= (1 << 6),
+	}, {
+		.name		= "ac97",
+		.id		= -1,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= (1 << 1),
+	}, {
+		.name		= "spdif",
+		.id		= -1,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= (1 << 0),
+	}, {
+		.name		= "pcm",
+		.id		= 2,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= S5P_CLKGATE_IP3_PCM2,
+	}, {
+		.name		= "pcm",
+		.id		= 1,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= S5P_CLKGATE_IP3_PCM1 | S5P_CLKGATE_IP3_I2S1 ,
+	}, {
+		.name		= "pcm",
+		.id		= 0,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= S5P_CLKGATE_IP3_PCM0,
+	}, {
+		.name		= "i2c-hdmiphy",
+		.id		= -1,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= (1 << 11),
+	}, {
+		.name		= "hdmi",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1 << 11),
+	}, {
+		.name		= "tvenc",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1 << 10),
+	}, {
+		.name		= "mixer",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1 << 9),
+	}, {
+		.name		= "vp",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1 << 8),
+	}, {
+		.name		= "rotator",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip0_ctrl,
+		.ctrlbit	= (1 << 29),
+	}, {
+		.name		= "g2d",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip0_ctrl,
+		.ctrlbit	= (1 << 12),
+	}, {
+		.name		= "usb_osc",
+		.id		= -1,
+		.enable		= s5pv210_usbosc_enable,
+		.ctrlbit	= (1 << 1),
+	}, {
+		.name		= "secss",
+		.id		= -1,
+		.parent		= &clk_hclk_psys.clk,
+		.enable		= s5pv210_clk_ip2_ctrl,
+		.ctrlbit	= (1 << 0),
+	}, {
+		.name		= "seckey",
+		.id		= -1,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip4_ctrl,
+		.ctrlbit	= (1 << 3),
 	},
 };
 
+static struct clk init_dmaclocks[] = {
+	{
+		.name           = "dma",
+		.id             = 0,
+		.parent         = &clk_hclk_dsys.clk,
+		.enable         = s5pv210_clk_ip0_ctrl,
+		.ctrlbit        = (1<<2),
+		.dev            = &s5pv210_device_mdma.dev,
+	}, {
+		.name           = "dma",
+		.id             = 1,
+		.parent         = &clk_hclk_psys.clk,
+		.enable         = s5pv210_clk_ip0_ctrl,
+		.ctrlbit        = (1<<3),
+		.dev            = &s5pv210_device_pdma0.dev,
+	}, {
+		.name           = "dma",
+		.id             = 2,
+		.parent         = &init_dmaclocks[1],
+		.enable         = s5pv210_clk_ip0_ctrl,
+		.ctrlbit        = (1<<4),
+		.dev            = &s5pv210_device_pdma1.dev,
+	},
+};
+
+static  int s5pc11x_clk_out_set_rate(struct clk *clk, unsigned long rate);
+static int s5pc11x_clk_out_set_parent(struct clk *clk, struct clk *parent);
+
+static struct clk_ops s5pc11x_clkout_ops = {
+	.set_parent = s5pc11x_clk_out_set_parent,
+	.set_rate = s5pc11x_clk_out_set_rate,
+};
+
 static struct clk init_clocks[] = {
 	{
+		.name		= "watchdog",
+		.id		= -1,
+		.parent		= &clk_pclk_psys.clk,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= (1<<22),
+	}, {
 		.name		= "hclk_imem",
 		.id		= -1,
 		.parent		= &clk_hclk_msys.clk,
@@ -430,6 +639,12 @@
 		.enable		= s5pv210_clk_ip0_ctrl,
 		.ops		= &clk_hclk_imem_ops,
 	}, {
+		.name		= "lcd",
+		.id		= -1,
+		.parent		= &clk_hclk_dsys.clk,
+		.enable		= s5pv210_clk_ip1_ctrl,
+		.ctrlbit	= (1<<0),
+	}, {
 		.name		= "uart",
 		.id		= 0,
 		.parent		= &clk_pclk_psys.clk,
@@ -453,6 +668,16 @@
 		.parent		= &clk_pclk_psys.clk,
 		.enable		= s5pv210_clk_ip3_ctrl,
 		.ctrlbit	= (1 << 20),
+	}, {
+		.name		= "i2s_v50",
+		.id		= 0,
+		.parent		= &clk_p,
+		.enable		= s5pv210_clk_ip3_ctrl,
+		.ctrlbit	= S5P_CLKGATE_IP3_I2S0 | S5P_CLKGATE_IP3_PCM0,
+	}, {
+		.name		= "clk_out",
+		.id		= -1,
+		.ops		= &s5pc11x_clkout_ops,
 	},
 };
 
@@ -499,23 +724,23 @@
 };
 
 static struct clksrc_clk clk_sclk_dac = {
-	.clk		= {
+	.clk	= {
 		.name		= "sclk_dac",
 		.id		= -1,
 		.enable		= s5pv210_clk_mask0_ctrl,
 		.ctrlbit	= (1 << 2),
 	},
-	.sources	= &clkset_sclk_dac,
-	.reg_src	= { .reg = S5P_CLK_SRC1, .shift = 8, .size = 1 },
+	.sources = &clkset_sclk_dac,
+	.reg_src = { .reg = S5P_CLK_SRC1, .shift = 8, .size = 1 },
 };
 
 static struct clksrc_clk clk_sclk_pixel = {
-	.clk		= {
+	.clk	= {
 		.name		= "sclk_pixel",
 		.id		= -1,
 		.parent		= &clk_sclk_vpll.clk,
 	},
-	.reg_div	= { .reg = S5P_CLK_DIV1, .shift = 0, .size = 4},
+	.reg_div = { .reg = S5P_CLK_DIV1, .shift = 0, .size = 4},
 };
 
 static struct clk *clkset_sclk_hdmi_list[] = {
@@ -529,14 +754,14 @@
 };
 
 static struct clksrc_clk clk_sclk_hdmi = {
-	.clk		= {
+	.clk	= {
 		.name		= "sclk_hdmi",
 		.id		= -1,
 		.enable		= s5pv210_clk_mask0_ctrl,
 		.ctrlbit	= (1 << 0),
 	},
-	.sources	= &clkset_sclk_hdmi,
-	.reg_src	= { .reg = S5P_CLK_SRC1, .shift = 0, .size = 1 },
+	.sources = &clkset_sclk_hdmi,
+	.reg_src = { .reg = S5P_CLK_SRC1, .shift = 0, .size = 1 },
 };
 
 static struct clk *clkset_sclk_mixer_list[] = {
@@ -549,6 +774,54 @@
 	.nr_sources	= ARRAY_SIZE(clkset_sclk_mixer_list),
 };
 
+static int s5pc11x_clk_out_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 val = 0, div = 0, rate_div = 1;
+	int err = -EINVAL;
+
+	if (rate && clk->parent) {
+		if (clk->parent == &clk_fout_apll)
+			rate_div = 4;
+		if (clk->parent == &clk_fout_mpll)
+			rate_div = 2;
+
+		div = clk_get_rate(clk->parent) / rate / rate_div;
+		val = __raw_readl(S5P_CLK_OUT);
+		val &= (~(0xF << 20));
+		val |= (div - 1) << 20;
+		__raw_writel(val, S5P_CLK_OUT);
+		err = 0;
+	}
+	return err;
+}
+
+static int s5pc11x_clk_out_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 val = 0;
+	int err = 0;
+	clk->parent = parent;
+	val = __raw_readl(S5P_CLK_OUT);
+
+	if (parent == &clk_fout_apll) {
+		val = val & (~(0x1F << 12));
+		val |= (0x0 << 12);
+	} else if (parent == &clk_fout_mpll) {
+		val = val & (~(0x1F << 12));
+		val |= (0x1 << 12);
+	} else if (parent == &clk_fout_epll) {
+		val = val & (~(0x1F << 12));
+		val |= (0x2 << 12);
+	} else if (parent == &clk_sclk_vpll.clk) {
+		val = val & (~(0x1F << 12));
+		val |= (0x3 << 12);
+	} else {
+		err = -EINVAL;
+	}
+
+	__raw_writel(val, S5P_CLK_OUT);
+	return err;
+}
+
 static struct clk *clkset_sclk_audio0_list[] = {
 	[0] = &clk_ext_xtal_mux,
 	[1] = &clk_pcmcdclk0,
@@ -567,7 +840,7 @@
 };
 
 static struct clksrc_clk clk_sclk_audio0 = {
-	.clk		= {
+	.clk	= {
 		.name		= "sclk_audio",
 		.id		= 0,
 		.enable		= s5pv210_clk_mask0_ctrl,
@@ -578,6 +851,59 @@
 	.reg_div = { .reg = S5P_CLK_DIV6, .shift = 0, .size = 4 },
 };
 
+static struct clk *clkset_mout_audss_list[] = {
+	&clk_ext_xtal_mux,
+	&clk_fout_epll,
+};
+
+static struct clksrc_sources clkset_mout_audss = {
+	.sources	= clkset_mout_audss_list,
+	.nr_sources	= ARRAY_SIZE(clkset_mout_audss_list),
+};
+
+static struct clksrc_clk clk_mout_audss = {
+	.clk	= {
+		.name		= "mout_audss",
+		.id		= -1,
+	},
+	.sources = &clkset_mout_audss,
+	.reg_src = { .reg = S5P_CLKSRC_AUDSS, .shift = 0, .size = 1 },
+};
+
+static struct clk *clkset_mout_i2s_a_list[] = {
+	&clk_mout_audss.clk,
+	&clk_pcmcdclk0,
+	&clk_sclk_audio0.clk,
+};
+
+static struct clksrc_sources clkset_mout_i2s_a = {
+	.sources	= clkset_mout_i2s_a_list,
+	.nr_sources	= ARRAY_SIZE(clkset_mout_i2s_a_list),
+};
+
+static struct clksrc_clk clk_mout_i2s_a = {
+	.clk	= {
+		.name		= "audio-bus",
+		.id		= 0,
+		.enable		= s5pv210_clk_audss_ctrl,
+		.ctrlbit	= (1 << 6),
+	},
+	.sources = &clkset_mout_i2s_a,
+	.reg_src = { .reg = S5P_CLKSRC_AUDSS, .shift = 2, .size = 2 },
+	.reg_div = { .reg = S5P_CLKDIV_AUDSS, .shift = 4, .size = 4 },
+};
+
+static struct clksrc_clk clk_dout_audio_bus_clk_i2s = {
+	.clk	= {
+		.name		= "dout_audio_bus_clk_i2s",
+		.id		= -1,
+		.parent		= &clk_mout_audss.clk,
+		.enable		= s5pv210_clk_audss_ctrl,
+		.ctrlbit	= (1 << 5),
+	},
+	.reg_div	= { .reg = S5P_CLKDIV_AUDSS, .shift = 0, .size = 4 },
+};
+
 static struct clk *clkset_sclk_audio1_list[] = {
 	[0] = &clk_ext_xtal_mux,
 	[1] = &clk_pcmcdclk1,
@@ -596,7 +922,7 @@
 };
 
 static struct clksrc_clk clk_sclk_audio1 = {
-	.clk		= {
+	.clk	= {
 		.name		= "sclk_audio",
 		.id		= 1,
 		.enable		= s5pv210_clk_mask0_ctrl,
@@ -625,7 +951,7 @@
 };
 
 static struct clksrc_clk clk_sclk_audio2 = {
-	.clk		= {
+	.clk	= {
 		.name		= "sclk_audio",
 		.id		= 2,
 		.enable		= s5pv210_clk_mask0_ctrl,
@@ -683,40 +1009,44 @@
 		.reg_div = { .reg = S5P_CLK_DIV6, .shift = 12, .size = 3 },
 	}, {
 		.clk	= {
-			.name		= "uclk1",
+			.name		= "sclk",
 			.id		= 0,
 			.enable		= s5pv210_clk_mask0_ctrl,
 			.ctrlbit	= (1 << 12),
+			.dev		= &s3c24xx_uart_device0.dev,
 		},
 		.sources = &clkset_uart,
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 16, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 16, .size = 4 },
 	}, {
-		.clk		= {
-			.name		= "uclk1",
+		.clk	= {
+			.name		= "sclk",
 			.id		= 1,
 			.enable		= s5pv210_clk_mask0_ctrl,
 			.ctrlbit	= (1 << 13),
+			.dev		= &s3c24xx_uart_device1.dev,
 		},
 		.sources = &clkset_uart,
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 20, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 20, .size = 4 },
 	}, {
-		.clk		= {
-			.name		= "uclk1",
+		.clk	= {
+			.name		= "sclk",
 			.id		= 2,
 			.enable		= s5pv210_clk_mask0_ctrl,
 			.ctrlbit	= (1 << 14),
+			.dev		= &s3c24xx_uart_device2.dev,
 		},
 		.sources = &clkset_uart,
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 24, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 24, .size = 4 },
 	}, {
-		.clk		= {
-			.name		= "uclk1",
+		.clk	= {
+			.name		= "sclk",
 			.id		= 3,
 			.enable		= s5pv210_clk_mask0_ctrl,
 			.ctrlbit	= (1 << 15),
+			.dev		= &s3c24xx_uart_device3.dev,
 		},
 		.sources = &clkset_uart,
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 28, .size = 4 },
@@ -731,7 +1061,7 @@
 		.sources = &clkset_sclk_mixer,
 		.reg_src = { .reg = S5P_CLK_SRC1, .shift = 4, .size = 1 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_spdif",
 			.id		= -1,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -770,9 +1100,9 @@
 		.reg_src = { .reg = S5P_CLK_SRC3, .shift = 20, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV3, .shift = 20, .size = 4 },
 	}, {
-		.clk		= {
-			.name		= "sclk_cam",
-			.id		= 0,
+		.clk	= {
+			.name		= "sclk_cam0",
+			.id		= -1,
 			.enable		= s5pv210_clk_mask0_ctrl,
 			.ctrlbit	= (1 << 3),
 		},
@@ -780,9 +1110,9 @@
 		.reg_src = { .reg = S5P_CLK_SRC1, .shift = 12, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV1, .shift = 12, .size = 4 },
 	}, {
-		.clk		= {
-			.name		= "sclk_cam",
-			.id		= 1,
+		.clk	= {
+			.name		= "sclk_cam1",
+			.id		= -1,
 			.enable		= s5pv210_clk_mask0_ctrl,
 			.ctrlbit	= (1 << 4),
 		},
@@ -790,17 +1120,17 @@
 		.reg_src = { .reg = S5P_CLK_SRC1, .shift = 16, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV1, .shift = 16, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_fimd",
 			.id		= -1,
-			.enable		= s5pv210_clk_mask0_ctrl,
-			.ctrlbit	= (1 << 5),
+			.enable		= s5pv210_clk_ip1_ctrl,
+			.ctrlbit	= (1 << 0),
 		},
 		.sources = &clkset_group2,
 		.reg_src = { .reg = S5P_CLK_SRC1, .shift = 20, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV1, .shift = 20, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_mmc",
 			.id		= 0,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -810,7 +1140,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 0, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 0, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_mmc",
 			.id		= 1,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -820,7 +1150,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 4, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 4, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_mmc",
 			.id		= 2,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -830,7 +1160,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 8, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 8, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_mmc",
 			.id		= 3,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -840,7 +1170,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC4, .shift = 12, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV4, .shift = 12, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_mfc",
 			.id		= -1,
 			.enable		= s5pv210_clk_ip0_ctrl,
@@ -850,7 +1180,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC2, .shift = 4, .size = 2 },
 		.reg_div = { .reg = S5P_CLK_DIV2, .shift = 4, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_g2d",
 			.id		= -1,
 			.enable		= s5pv210_clk_ip0_ctrl,
@@ -860,17 +1190,18 @@
 		.reg_src = { .reg = S5P_CLK_SRC2, .shift = 8, .size = 2 },
 		.reg_div = { .reg = S5P_CLK_DIV2, .shift = 8, .size = 4 },
 	}, {
-		.clk		= {
-			.name		= "sclk_g3d",
+		.clk	= {
+			.name		= "sclk",
 			.id		= -1,
 			.enable		= s5pv210_clk_ip0_ctrl,
 			.ctrlbit	= (1 << 8),
+			.dev		= &s3c_device_g3d.dev,
 		},
 		.sources = &clkset_group1,
 		.reg_src = { .reg = S5P_CLK_SRC2, .shift = 0, .size = 2 },
 		.reg_div = { .reg = S5P_CLK_DIV2, .shift = 0, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_csis",
 			.id		= -1,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -880,7 +1211,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC1, .shift = 24, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV1, .shift = 28, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_spi",
 			.id		= 0,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -890,7 +1221,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC5, .shift = 0, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV5, .shift = 0, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_spi",
 			.id		= 1,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -900,7 +1231,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC5, .shift = 4, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV5, .shift = 4, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_pwi",
 			.id		= -1,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -910,7 +1241,7 @@
 		.reg_src = { .reg = S5P_CLK_SRC6, .shift = 20, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV6, .shift = 24, .size = 4 },
 	}, {
-		.clk		= {
+		.clk	= {
 			.name		= "sclk_pwm",
 			.id		= -1,
 			.enable		= s5pv210_clk_mask0_ctrl,
@@ -919,7 +1250,39 @@
 		.sources = &clkset_group2,
 		.reg_src = { .reg = S5P_CLK_SRC5, .shift = 12, .size = 4 },
 		.reg_div = { .reg = S5P_CLK_DIV5, .shift = 12, .size = 4 },
+	}, {
+		.clk	= {
+			.name		= "sclk_mdnie",
+			.id		= -1,
+			.enable		= s5pv210_clk_mask1_ctrl,
+			.ctrlbit	= (1 << 0),
+		},
+		.sources = &clkset_group2,
+		.reg_src = { .reg = S5P_CLK_SRC3, .shift = 0, .size = 4 },
+		.reg_div = { .reg = S5P_CLK_DIV3, .shift = 0, .size = 4 },
+	}, {
+		.clk	= {
+			.name		= "sclk_mdnie_pwm",
+			.id		= -1,
+			.enable		= s5pv210_clk_mask1_ctrl,
+			.ctrlbit	= (1 << 1),
+		},
+		.sources = &clkset_group2,
+		.reg_src = { .reg = S5P_CLK_SRC3, .shift = 4, .size = 4 },
+		.reg_div = { .reg = S5P_CLK_DIV3, .shift = 4, .size = 4 },
+	},
+};
+
+/* MOUT CSIS */
+static struct clksrc_clk clk_mout_csis = {
+	.clk	= {
+		.name		= "mout_csis",
+		.id		= -1,
+		.enable		= s5pv210_clk_mask0_ctrl,
+		.ctrlbit	= (1 << 6),
 	},
+	.sources = &clkset_group1,
+	.reg_src = { .reg = S5P_CLK_SRC1, .shift = 24, .size = 4 },
 };
 
 /* Clock initialisation code */
@@ -940,6 +1303,187 @@
 	&clk_sclk_dac,
 	&clk_sclk_pixel,
 	&clk_sclk_hdmi,
+	&clk_mout_csis,
+	&clk_sclk_audio0,
+	&clk_sclk_audio1,
+	&clk_sclk_audio2,
+	&clk_mout_audss,
+	&clk_mout_i2s_a,
+	&clk_dout_audio_bus_clk_i2s,
+};
+
+static int s5pv210_usbosc_enable(struct clk *clk, int enable)
+{
+	unsigned int ctrlbit = clk->ctrlbit;
+	unsigned int usbosc_con = __raw_readl(S5P_SLEEP_CFG) & ~ctrlbit;
+
+	if (enable)
+		usbosc_con |= ctrlbit;
+
+	writel(usbosc_con, S5P_SLEEP_CFG);
+
+	return 0;
+}
+
+static int s5pv210_epll_enable(struct clk *clk, int enable)
+{
+	unsigned int ctrlbit = clk->ctrlbit;
+	unsigned int epll_con = __raw_readl(S5P_EPLL_CON) & ~ctrlbit;
+
+	if (enable)
+		__raw_writel(epll_con | ctrlbit, S5P_EPLL_CON);
+	else
+		__raw_writel(epll_con, S5P_EPLL_CON);
+
+	return 0;
+}
+
+static unsigned long s5pv210_epll_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static u32 epll_div[][6] = {
+	{  48000000, 0, 48, 3, 3, 0 },
+	{  96000000, 0, 48, 3, 2, 0 },
+	{ 144000000, 1, 72, 3, 2, 0 },
+	{ 192000000, 0, 48, 3, 1, 0 },
+	{ 288000000, 1, 72, 3, 1, 0 },
+	{  32750000, 1, 65, 3, 4, 35127 },
+	{  32768000, 1, 65, 3, 4, 35127 },
+	{  45158400, 0, 45, 3, 3, 10355 },
+	{  45000000, 0, 45, 3, 3, 10355 },
+	{  45158000, 0, 45, 3, 3, 10355 },
+	{  49125000, 0, 49, 3, 3, 9961 },
+	{  49152000, 0, 49, 3, 3, 9961 },
+	{  67737600, 1, 67, 3, 3, 48366 },
+	{  67738000, 1, 67, 3, 3, 48366 },
+	{  73800000, 1, 73, 3, 3, 47710 },
+	{  73728000, 1, 73, 3, 3, 47710 },
+	{  36000000, 1, 32, 3, 4, 0 },
+	{  60000000, 1, 60, 3, 3, 0 },
+	{  72000000, 1, 72, 3, 3, 0 },
+	{  80000000, 1, 80, 3, 3, 0 },
+	{  84000000, 0, 42, 3, 2, 0 },
+	{  50000000, 0, 50, 3, 3, 0 },
+};
+
+static int s5pv210_epll_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int epll_con, epll_con_k;
+	unsigned int i;
+
+	/* Return if nothing changed */
+	if (clk->rate == rate)
+		return 0;
+
+	epll_con = __raw_readl(S5P_EPLL_CON);
+	epll_con_k = __raw_readl(S5P_EPLL_CON_K);
+
+	epll_con_k &= ~(PLL90XX_KDIV_MASK);
+	epll_con &= ~(PLL90XX_MDIV_MASK << PLL90XX_MDIV_SHIFT |   \
+			PLL90XX_PDIV_MASK << PLL90XX_PDIV_SHIFT | \
+			PLL90XX_VDIV_MASK << PLL90XX_VDIV_SHIFT | \
+			PLL90XX_SDIV_MASK << PLL90XX_SDIV_SHIFT);
+
+	for (i = 0; i < ARRAY_SIZE(epll_div); i++) {
+		if (epll_div[i][0] == rate) {
+			epll_con_k |= epll_div[i][5] << 0;
+			epll_con |= epll_div[i][1] << 27;
+			epll_con |= epll_div[i][2] << 16;
+			epll_con |= epll_div[i][3] << 8;
+			epll_con |= epll_div[i][4] << 0;
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(epll_div)) {
+		printk(KERN_ERR "%s: Invalid Clock EPLL Frequency\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	__raw_writel(epll_con, S5P_EPLL_CON);
+	__raw_writel(epll_con_k, S5P_EPLL_CON_K);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+static struct clk_ops s5pv210_epll_ops = {
+	.get_rate = s5pv210_epll_get_rate,
+	.set_rate = s5pv210_epll_set_rate,
+};
+
+static unsigned long s5pv210_apll_get_rate(struct clk *clk)
+{
+	struct clk *xtal_clk;
+	unsigned long xtal;
+
+	xtal_clk = clk_get(NULL, "xtal");
+	BUG_ON(IS_ERR(xtal_clk));
+
+	xtal = clk_get_rate(xtal_clk);
+	clk_put(xtal_clk);
+
+	if (clk->parent == &clk_fin_apll)
+		return xtal;
+	else
+		return s5p_get_pll45xx(xtal, __raw_readl(S5P_APLL_CON),
+				pll_4508);
+}
+
+static struct clk_ops s5pv210_apll_ops = {
+	.get_rate = s5pv210_apll_get_rate,
+};
+
+static int s5pv210_vpll_enable(struct clk *clk, int enable)
+{
+	unsigned int ctrlbit = clk->ctrlbit;
+	unsigned int vpll_con = __raw_readl(S5P_VPLL_CON) & ~ctrlbit;
+
+	if (enable)
+		__raw_writel(vpll_con | ctrlbit, S5P_VPLL_CON);
+	else
+		__raw_writel(vpll_con, S5P_VPLL_CON);
+
+	return 0;
+}
+
+static unsigned long s5pv210_vpll_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+static int s5pv210_vpll_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int vpll_con;
+
+	switch (rate) {
+	case 54000000:
+		vpll_con = PDIV(6) | MDIV(108) | SDIV(3);
+		break;
+	case 27000000:
+		vpll_con = PDIV(6) | MDIV(108) | SDIV(4);
+		break;
+	default:
+		goto err_on_invalid_rate;
+	}
+
+	__raw_writel(vpll_con, S5P_VPLL_CON);
+
+	clk->rate = rate;
+
+	return 0;
+
+err_on_invalid_rate:
+	return -EINVAL;
+}
+
+static struct clk_ops s5pv210_vpll_ops = {
+	.get_rate = s5pv210_vpll_get_rate,
+	.set_rate = s5pv210_vpll_set_rate,
 };
 
 void __init_or_cpufreq s5pv210_setup_clocks(void)
@@ -961,6 +1505,12 @@
 	unsigned int ptr;
 	u32 clkdiv0, clkdiv1;
 
+	clk_fout_epll.enable = s5pv210_epll_enable;
+	clk_fout_epll.ops = &s5pv210_epll_ops;
+
+	clk_fout_vpll.enable = s5pv210_vpll_enable;
+	clk_fout_vpll.ops = &s5pv210_vpll_ops;
+
 	printk(KERN_DEBUG "%s: registering clocks\n", __func__);
 
 	clkdiv0 = __raw_readl(S5P_CLK_DIV0);
@@ -983,7 +1533,7 @@
 	vpllsrc = clk_get_rate(&clk_vpllsrc.clk);
 	vpll = s5p_get_pll45xx(vpllsrc, __raw_readl(S5P_VPLL_CON), pll_4502);
 
-	clk_fout_apll.rate = apll;
+	clk_fout_apll.ops = &s5pv210_apll_ops;
 	clk_fout_mpll.rate = mpll;
 	clk_fout_epll.rate = epll;
 	clk_fout_vpll.rate = vpll;
@@ -1017,6 +1567,9 @@
 	&clk_sclk_hdmiphy,
 	&clk_sclk_usbphy0,
 	&clk_sclk_usbphy1,
+	&clk_i2scdclk0,
+	&clk_i2scdclk1,
+	&clk_i2scdclk2,
 	&clk_pcmcdclk0,
 	&clk_pcmcdclk1,
 	&clk_pcmcdclk2,
@@ -1024,7 +1577,6 @@
 
 void __init s5pv210_register_clocks(void)
 {
-	struct clk *clkp;
 	int ret;
 	int ptr;
 
@@ -1036,17 +1588,13 @@
 		s3c_register_clksrc(sysclks[ptr], 1);
 
 	s3c_register_clksrc(clksrcs, ARRAY_SIZE(clksrcs));
+
 	s3c_register_clocks(init_clocks, ARRAY_SIZE(init_clocks));
+	s3c_register_clocks(init_clocks_disable, ARRAY_SIZE(init_clocks_disable));
+	s3c_register_clocks(init_dmaclocks, ARRAY_SIZE(init_dmaclocks));
 
-	clkp = init_clocks_disable;
-	for (ptr = 0; ptr < ARRAY_SIZE(init_clocks_disable); ptr++, clkp++) {
-		ret = s3c24xx_register_clock(clkp);
-		if (ret < 0) {
-			printk(KERN_ERR "Failed to register clock %s (%d)\n",
-			       clkp->name, ret);
-		}
-		(clkp->enable)(clkp, 0);
-	}
+	s3c_disable_clocks(init_clocks_disable, ARRAY_SIZE(init_clocks_disable));
+	s3c_disable_clocks(init_dmaclocks, ARRAY_SIZE(init_dmaclocks));
 
 	s3c_pwmclk_init();
 }
--- linux-2.6.35.7/arch/arm/mach-s5pv210/cpu.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/cpu.c	2011-08-08 12:52:05.000000000 +0800
@@ -58,6 +58,50 @@
 		.pfn		= __phys_to_pfn(S5PV210_PA_SROMC),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S3C_VA_WATCHDOG,
+		.pfn		= __phys_to_pfn(S5P_PA_WDT),
+		.length 	= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S3C_VA_OTG,
+		.pfn		= __phys_to_pfn(S5PV210_PA_OTG),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S3C_VA_OTGSFR,
+		.pfn		= __phys_to_pfn(S5PV210_PA_OTGSFR),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE,
+	},
+#if defined(CONFIG_HRT_RTC)
+	{
+		.virtual	= (unsigned long)S5P_VA_RTC,
+		.pfn		= __phys_to_pfn(S5PV210_PA_RTC),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+#endif
+	{
+		.virtual	= (unsigned long)S5P_VA_DMC0,
+		.pfn		= __phys_to_pfn(S5P_PA_DMC0),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S5P_VA_DMC1,
+		.pfn		= __phys_to_pfn(S5P_PA_DMC1),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S5P_VA_AUDSS,
+		.pfn		= __phys_to_pfn(S5PV210_PA_AUDSS),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S5P_VA_BUS_AXI_DSYS,
+		.pfn		= __phys_to_pfn(S5PV210_PA_BUS_AXI_DSYS),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
 	}
 };
 
--- linux-2.6.35.7/arch/arm/mach-s5pv210/dev-audio.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/dev-audio.c	2011-08-08 12:52:05.000000000 +0800
@@ -39,7 +39,7 @@
 		s3c_gpio_cfgpin(S5PV210_GPC1(4), S3C_GPIO_SFN(4));
 		break;
 
-	case -1:
+	case 0:
 		s3c_gpio_cfgpin(S5PV210_GPI(0), S3C_GPIO_SFN(2));
 		s3c_gpio_cfgpin(S5PV210_GPI(1), S3C_GPIO_SFN(2));
 		s3c_gpio_cfgpin(S5PV210_GPI(2), S3C_GPIO_SFN(2));
@@ -80,8 +80,8 @@
 };
 
 struct platform_device s5pv210_device_iis0 = {
-	.name		  = "s3c64xx-iis-v4",
-	.id		  = -1,
+	.name		  = "s3c64xx-iis",
+	.id		  = 0,
 	.num_resources	  = ARRAY_SIZE(s5pv210_iis0_resource),
 	.resource	  = s5pv210_iis0_resource,
 	.dev = {
@@ -325,3 +325,43 @@
 		.coherent_dma_mask = DMA_BIT_MASK(32),
 	},
 };
+
+static int s5pv210_spdif_cfg_gpio(struct platform_device *pdev)
+{
+	s3c_gpio_cfgpin(S5PV210_GPC1(0), (0x3)<<0);
+	s3c_gpio_cfgpin(S5PV210_GPC1(1), (0x3)<<4);
+
+	return 0;
+}
+
+static struct resource s5pv210_spdif_resource[] = {
+	[0] = {
+		.start = S5PV210_PA_SPDIF,
+		.end   = S5PV210_PA_SPDIF + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = DMACH_SPDIF,
+		.end   = DMACH_SPDIF,
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+static struct s3c_audio_pdata s5pv210_spdif_pdata = {
+	.cfg_gpio = s5pv210_spdif_cfg_gpio,
+};
+
+static u64 s5pv210_spdif_dmamask = DMA_BIT_MASK(32);
+
+struct platform_device s5pv210_device_spdif = {
+	.name		= "samsung-spdif",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s5pv210_spdif_resource),
+	.resource	= s5pv210_spdif_resource,
+	.dev = {
+		.platform_data = &s5pv210_spdif_pdata,
+		.dma_mask = &s5pv210_spdif_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
--- linux-2.6.35.7/arch/arm/mach-s5pv210/dev-spi.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/dev-spi.c	2011-08-08 12:52:05.000000000 +0800
@@ -40,18 +40,22 @@
 		s3c_gpio_cfgpin(S5PV210_GPB(0), S3C_GPIO_SFN(2));
 		s3c_gpio_cfgpin(S5PV210_GPB(1), S3C_GPIO_SFN(2));
 		s3c_gpio_cfgpin(S5PV210_GPB(2), S3C_GPIO_SFN(2));
+		s3c_gpio_cfgpin(S5PV210_GPB(3), S3C_GPIO_SFN(2));
 		s3c_gpio_setpull(S5PV210_GPB(0), S3C_GPIO_PULL_UP);
 		s3c_gpio_setpull(S5PV210_GPB(1), S3C_GPIO_PULL_UP);
 		s3c_gpio_setpull(S5PV210_GPB(2), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S5PV210_GPB(3), S3C_GPIO_PULL_UP);
 		break;
 
 	case 1:
 		s3c_gpio_cfgpin(S5PV210_GPB(4), S3C_GPIO_SFN(2));
 		s3c_gpio_cfgpin(S5PV210_GPB(5), S3C_GPIO_SFN(2));
 		s3c_gpio_cfgpin(S5PV210_GPB(6), S3C_GPIO_SFN(2));
+		s3c_gpio_cfgpin(S5PV210_GPB(7), S3C_GPIO_SFN(2));
 		s3c_gpio_setpull(S5PV210_GPB(4), S3C_GPIO_PULL_UP);
 		s3c_gpio_setpull(S5PV210_GPB(5), S3C_GPIO_PULL_UP);
 		s3c_gpio_setpull(S5PV210_GPB(6), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S5PV210_GPB(7), S3C_GPIO_PULL_UP);
 		break;
 
 	default:
--- linux-2.6.35.7/arch/arm/mach-s5pv210/dma.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/dma.c	2011-08-08 12:52:05.000000000 +0800
@@ -30,6 +30,71 @@
 
 static u64 dma_dmamask = DMA_BIT_MASK(32);
 
+static struct resource s5pv210_mdma_resource[] = {
+	[0] = {
+		.start  = S5PV210_PA_MDMA,
+		.end    = S5PV210_PA_MDMA + SZ_4K,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MDMA,
+		.end	= IRQ_MDMA,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct s3c_pl330_platdata s5pv210_mdma_pdata = {
+	.peri = {
+		/* The DMAC can have max 8 channel so there
+		 * can be 8 M<->M requests served at any time.
+		 */
+		[0] = DMACH_MTOM_0,
+		[1] = DMACH_MTOM_1,
+		[2] = DMACH_MTOM_2,
+		[3] = DMACH_MTOM_3,
+		[4] = DMACH_MTOM_4,
+		[5] = DMACH_MTOM_5,
+		[6] = DMACH_MTOM_6,
+		[7] = DMACH_MTOM_7,
+		[8] = DMACH_MAX,
+		[9] = DMACH_MAX,
+		[10] = DMACH_MAX,
+		[11] = DMACH_MAX,
+		[12] = DMACH_MAX,
+		[13] = DMACH_MAX,
+		[14] = DMACH_MAX,
+		[15] = DMACH_MAX,
+		[16] = DMACH_MAX,
+		[17] = DMACH_MAX,
+		[18] = DMACH_MAX,
+		[19] = DMACH_MAX,
+		[20] = DMACH_MAX,
+		[21] = DMACH_MAX,
+		[22] = DMACH_MAX,
+		[23] = DMACH_MAX,
+		[24] = DMACH_MAX,
+		[25] = DMACH_MAX,
+		[26] = DMACH_MAX,
+		[27] = DMACH_MAX,
+		[28] = DMACH_MAX,
+		[29] = DMACH_MAX,
+		[30] = DMACH_MAX,
+		[31] = DMACH_MAX,
+	},
+};
+
+struct platform_device s5pv210_device_mdma = {
+	.name		= "s3c-pl330",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(s5pv210_mdma_resource),
+	.resource	= s5pv210_mdma_resource,
+	.dev		= {
+		.dma_mask = &dma_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &s5pv210_mdma_pdata,
+	},
+};
+
 static struct resource s5pv210_pdma0_resource[] = {
 	[0] = {
 		.start  = S5PV210_PA_PDMA0,
@@ -80,7 +145,7 @@
 	},
 };
 
-static struct platform_device s5pv210_device_pdma0 = {
+struct platform_device s5pv210_device_pdma0 = {
 	.name		= "s3c-pl330",
 	.id		= 1,
 	.num_resources	= ARRAY_SIZE(s5pv210_pdma0_resource),
@@ -142,7 +207,7 @@
 	},
 };
 
-static struct platform_device s5pv210_device_pdma1 = {
+struct platform_device s5pv210_device_pdma1 = {
 	.name		= "s3c-pl330",
 	.id		= 2,
 	.num_resources	= ARRAY_SIZE(s5pv210_pdma1_resource),
@@ -155,6 +220,7 @@
 };
 
 static struct platform_device *s5pv210_dmacs[] __initdata = {
+	&s5pv210_device_mdma,
 	&s5pv210_device_pdma0,
 	&s5pv210_device_pdma1,
 };
--- linux-2.6.35.7/arch/arm/mach-s5pv210/gpiolib.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/gpiolib.c	2011-08-08 12:52:05.000000000 +0800
@@ -14,10 +14,12 @@
 #include <linux/irq.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
+#include <linux/module.h>
 #include <plat/gpio-core.h>
 #include <plat/gpio-cfg.h>
 #include <plat/gpio-cfg-helpers.h>
 #include <mach/map.h>
+#include <mach/regs-gpio.h>
 
 static struct s3c_gpio_cfg gpio_cfg = {
 	.set_config	= s3c_gpio_setcfg_s3c64xx_4bit,
@@ -31,6 +33,19 @@
 	.get_pull	= s3c_gpio_getpull_updown,
 };
 
+static int s5p_gpiolib_eint_to_irq(struct gpio_chip *chip, unsigned int offset)
+{
+	struct s3c_gpio_chip *s3c_chip = to_s3c_gpio(chip);
+
+	return s3c_chip->eint_offset + offset;
+}
+
+/* be called from gpio_to_irq() for gpio interrupts */
+static int s5p_gpiolib_gpioint_to_irq(struct gpio_chip *chip, unsigned int offset)
+{
+	return S5P_IRQ_GPIOINT(chip->base + offset);
+}
+
 /* GPIO bank's base address given the index of the bank in the
  * list of all gpio banks.
  */
@@ -52,104 +67,122 @@
 			.base	= S5PV210_GPA0(0),
 			.ngpio	= S5PV210_GPIO_A0_NR,
 			.label	= "GPA0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPA1(0),
 			.ngpio	= S5PV210_GPIO_A1_NR,
 			.label	= "GPA1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPB(0),
 			.ngpio	= S5PV210_GPIO_B_NR,
 			.label	= "GPB",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPC0(0),
 			.ngpio	= S5PV210_GPIO_C0_NR,
 			.label	= "GPC0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPC1(0),
 			.ngpio	= S5PV210_GPIO_C1_NR,
 			.label	= "GPC1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPD0(0),
 			.ngpio	= S5PV210_GPIO_D0_NR,
 			.label	= "GPD0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPD1(0),
 			.ngpio	= S5PV210_GPIO_D1_NR,
 			.label	= "GPD1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPE0(0),
 			.ngpio	= S5PV210_GPIO_E0_NR,
 			.label	= "GPE0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPE1(0),
 			.ngpio	= S5PV210_GPIO_E1_NR,
 			.label	= "GPE1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPF0(0),
 			.ngpio	= S5PV210_GPIO_F0_NR,
 			.label	= "GPF0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPF1(0),
 			.ngpio	= S5PV210_GPIO_F1_NR,
 			.label	= "GPF1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPF2(0),
 			.ngpio	= S5PV210_GPIO_F2_NR,
 			.label	= "GPF2",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPF3(0),
 			.ngpio	= S5PV210_GPIO_F3_NR,
 			.label	= "GPF3",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPG0(0),
 			.ngpio	= S5PV210_GPIO_G0_NR,
 			.label	= "GPG0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPG1(0),
 			.ngpio	= S5PV210_GPIO_G1_NR,
 			.label	= "GPG1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPG2(0),
 			.ngpio	= S5PV210_GPIO_G2_NR,
 			.label	= "GPG2",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPG3(0),
 			.ngpio	= S5PV210_GPIO_G3_NR,
 			.label	= "GPG3",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
+		.config = &gpio_cfg_noint,
 		.chip	= {
 			.base	= S5PV210_GPI(0),
 			.ngpio	= S5PV210_GPIO_I_NR,
@@ -160,30 +193,35 @@
 			.base	= S5PV210_GPJ0(0),
 			.ngpio	= S5PV210_GPIO_J0_NR,
 			.label	= "GPJ0",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPJ1(0),
 			.ngpio	= S5PV210_GPIO_J1_NR,
 			.label	= "GPJ1",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPJ2(0),
 			.ngpio	= S5PV210_GPIO_J2_NR,
 			.label	= "GPJ2",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPJ3(0),
 			.ngpio	= S5PV210_GPIO_J3_NR,
 			.label	= "GPJ3",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.chip	= {
 			.base	= S5PV210_GPJ4(0),
 			.ngpio	= S5PV210_GPIO_J4_NR,
 			.label	= "GPJ4",
+			.to_irq = s5p_gpiolib_gpioint_to_irq,
 		},
 	}, {
 		.config	= &gpio_cfg_noint,
@@ -207,41 +245,404 @@
 			.label	= "MP03",
 		},
 	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP04(0),
+			.ngpio	= S5PV210_GPIO_MP04_NR,
+			.label	= "MP04",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP05(0),
+			.ngpio	= S5PV210_GPIO_MP05_NR,
+			.label	= "MP05",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP06(0),
+			.ngpio	= S5PV210_GPIO_MP06_NR,
+			.label	= "MP06",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP07(0),
+			.ngpio	= S5PV210_GPIO_MP07_NR,
+			.label	= "MP07",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP10(0),
+			.ngpio	= S5PV210_GPIO_MP10_NR,
+			.label	= "MP10",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP11(0),
+			.ngpio	= S5PV210_GPIO_MP11_NR,
+			.label	= "MP11",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP12(0),
+			.ngpio	= S5PV210_GPIO_MP12_NR,
+			.label	= "MP12",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP13(0),
+			.ngpio	= S5PV210_GPIO_MP13_NR,
+			.label	= "MP13",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP14(0),
+			.ngpio	= S5PV210_GPIO_MP14_NR,
+			.label	= "MP14",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP15(0),
+			.ngpio	= S5PV210_GPIO_MP15_NR,
+			.label	= "MP15",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP16(0),
+			.ngpio	= S5PV210_GPIO_MP16_NR,
+			.label	= "MP16",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP17(0),
+			.ngpio	= S5PV210_GPIO_MP17_NR,
+			.label	= "MP17",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP18(0),
+			.ngpio	= S5PV210_GPIO_MP18_NR,
+			.label	= "MP18",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP20(0),
+			.ngpio	= S5PV210_GPIO_MP20_NR,
+			.label	= "MP20",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP21(0),
+			.ngpio	= S5PV210_GPIO_MP21_NR,
+			.label	= "MP21",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP22(0),
+			.ngpio	= S5PV210_GPIO_MP22_NR,
+			.label	= "MP22",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP23(0),
+			.ngpio	= S5PV210_GPIO_MP23_NR,
+			.label	= "MP23",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP24(0),
+			.ngpio	= S5PV210_GPIO_MP24_NR,
+			.label	= "MP24",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP25(0),
+			.ngpio	= S5PV210_GPIO_MP25_NR,
+			.label	= "MP25",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP26(0),
+			.ngpio	= S5PV210_GPIO_MP26_NR,
+			.label	= "MP26",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP27(0),
+			.ngpio	= S5PV210_GPIO_MP27_NR,
+			.label	= "MP27",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_MP28(0),
+			.ngpio	= S5PV210_GPIO_MP28_NR,
+			.label	= "MP28",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_ETC0(0),
+			.ngpio	= S5PV210_GPIO_ETC0_NR,
+			.label	= "ETC0",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_ETC1(0),
+			.ngpio	= S5PV210_GPIO_ETC1_NR,
+			.label	= "ETC1",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_ETC2(0),
+			.ngpio	= S5PV210_GPIO_ETC2_NR,
+			.label	= "ETC2",
+		},
+	}, {
+		.config	= &gpio_cfg_noint,
+		.chip	= {
+			.base	= S5PV210_ETC4(0),
+			.ngpio	= S5PV210_GPIO_ETC4_NR,
+			.label	= "ETC4",
+		},
+	}, {
 		.base	= (S5P_VA_GPIO + 0xC00),
 		.config	= &gpio_cfg_noint,
+		.eint_offset = IRQ_EINT(0),
 		.chip	= {
 			.base	= S5PV210_GPH0(0),
 			.ngpio	= S5PV210_GPIO_H0_NR,
 			.label	= "GPH0",
+			.to_irq = s5p_gpiolib_eint_to_irq,
 		},
 	}, {
 		.base	= (S5P_VA_GPIO + 0xC20),
 		.config	= &gpio_cfg_noint,
+		.eint_offset = IRQ_EINT(8),
 		.chip	= {
 			.base	= S5PV210_GPH1(0),
 			.ngpio	= S5PV210_GPIO_H1_NR,
 			.label	= "GPH1",
+			.to_irq = s5p_gpiolib_eint_to_irq,
 		},
 	}, {
 		.base	= (S5P_VA_GPIO + 0xC40),
 		.config	= &gpio_cfg_noint,
+		.eint_offset = IRQ_EINT(16),
 		.chip	= {
 			.base	= S5PV210_GPH2(0),
 			.ngpio	= S5PV210_GPIO_H2_NR,
 			.label	= "GPH2",
+			.to_irq = s5p_gpiolib_eint_to_irq,
 		},
 	}, {
 		.base	= (S5P_VA_GPIO + 0xC60),
 		.config	= &gpio_cfg_noint,
+		.eint_offset = IRQ_EINT(24),
 		.chip	= {
 			.base	= S5PV210_GPH3(0),
 			.ngpio	= S5PV210_GPIO_H3_NR,
 			.label	= "GPH3",
+			.to_irq = s5p_gpiolib_eint_to_irq,
 		},
 	},
 };
 
-static __init int s5pv210_gpiolib_init(void)
+/* S5PV210 machine dependent GPIO help function */
+int s3c_gpio_slp_cfgpin(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if ((pin <= S5PV210_GPH3(7)) && (pin >= S5PV210_GPH0(0)))
+		return -EINVAL;
+
+	if (config > S3C_GPIO_SLP_PREV)
+		return -EINVAL;
+
+	reg = chip->base + 0x10;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+	con |= config << shift;
+	__raw_writel(con, reg);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+s3c_gpio_pull_t s3c_gpio_get_slp_cfgpin(unsigned int pin)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if ((pin <= S5PV210_GPH3(7)) && (pin >= S5PV210_GPH0(0)))
+		return -EINVAL;
+
+	reg = chip->base + 0x10;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con >>= shift;
+	con &= 0x3;
+
+	local_irq_restore(flags);
+
+	return (__force s3c_gpio_pull_t)con;
+}
+
+int s3c_gpio_slp_setpull_updown(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if ((pin <= S5PV210_GPH3(7)) && (pin >= S5PV210_GPH0(0)))
+		return -EINVAL;
+
+	if (config > S3C_GPIO_PULL_UP)
+		return -EINVAL;
+	reg = chip->base + 0x14;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+	con |= config << shift;
+	__raw_writel(con, reg);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c_gpio_slp_setpull_updown);
+
+int s3c_gpio_set_drvstrength(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if (config  > S3C_GPIO_DRVSTR_4X)
+		return -EINVAL;
+
+	reg = chip->base + 0x0c;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+	con |= config << shift;
+
+	__raw_writel(con, reg);
+#ifdef S5PC11X_ALIVEGPIO_STORE
+	con = __raw_readl(reg);
+#endif
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+int s3c_gpio_set_slewrate(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if (config > S3C_GPIO_SLEWRATE_SLOW)
+		return -EINVAL;
+
+	reg = chip->base + 0x0c;
+
+	offset = pin - chip->chip.base;
+	shift = offset;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con &= ~(1 << shift);
+	con |= config << shift;
+
+	__raw_writel(con, reg);
+#ifdef S5PC11X_ALIVEGPIO_STORE
+	con = __raw_readl(reg);
+#endif
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+__init int s5pv210_gpiolib_init(void)
 {
 	struct s3c_gpio_chip *chip = s5pv210_gpio_4bit;
 	int nr_chips = ARRAY_SIZE(s5pv210_gpio_4bit);
@@ -258,4 +659,3 @@
 
 	return 0;
 }
-core_initcall(s5pv210_gpiolib_init);
--- linux-2.6.35.7/arch/arm/mach-s5pv210/init.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/init.c	2011-08-08 12:52:05.000000000 +0800
@@ -20,7 +20,7 @@
 
 static struct s3c24xx_uart_clksrc s5pv210_serial_clocks[] = {
 	[0] = {
-		.name		= "pclk",
+		.name		= "sclk",
 		.divisor	= 1,
 		.min_baud	= 0,
 		.max_baud	= 0,
--- linux-2.6.35.7/arch/arm/mach-s5pv210/Kconfig	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/Kconfig	2011-08-17 19:52:49.000000000 +0800
@@ -19,11 +19,15 @@
 
 config S5PV210_SETUP_I2C1
 	bool
+	depends on S3C_DEV_I2C1
+	default	y
 	help
 	  Common setup code for i2c bus 1.
 
 config S5PV210_SETUP_I2C2
 	bool
+	depends on S3C_DEV_I2C2
+	default	y
 	help
 	  Common setup code for i2c bus 2.
 
@@ -43,7 +47,16 @@
 	help
 	  Common setup code for SDHCI gpio.
 
+config S5PV210_POWER_DOMAIN
+	bool
+	depends on REGULATOR
+	default y
+	help
+	  Enable S5PV210 power domain support.
+
 # machine support
+choice
+	prompt "Board selection"
 
 config MACH_AQUILA
 	bool "Samsung Aquila"
@@ -62,30 +75,201 @@
 	  Machine support for Samsung GONI board
 	  S5PC110(MCP) is one of package option of S5PV210
 
-config S5PC110_DEV_ONENAND
-	bool
+config MACH_MINI210
+	bool "MINI210"
+	select CPU_S5PV210
+	select ARCH_DISCONTIGMEM_ENABLE
+	select S3C_DEV_WDT
+	select HAVE_S3C2410_WATCHDOG
+	select S3C_DEV_I2C1
+	select S3C_DEV_I2C2
+	select HAVE_PWM
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC1 if !S5PV210_SD_CH0_8BIT
+	select S3C_DEV_HSMMC2
+	select S3C_DEV_HSMMC3 if !S5PV210_SD_CH2_8BIT
+	select S5PV210_SETUP_SDHCI
+	select S5PV210_POWER_DOMAIN
+	select WIRELESS_EXT
+	select WEXT_SPY
+	select WEXT_PRIV
+	select AVERAGE
 	help
-	  Compile in platform device definition for OneNAND1 controller
+	  Machine support for FriendlyARM mini210
 
 config MACH_SMDKV210
 	bool "SMDKV210"
 	select CPU_S5PV210
 	select ARCH_SPARSEMEM_ENABLE
-	select SAMSUNG_DEV_ADC
-	select SAMSUNG_DEV_TS
 	select S3C_DEV_WDT
 	select HAVE_S3C2410_WATCHDOG
+	select S3C_DEV_I2C1
+	select S3C_DEV_I2C2
+	select HAVE_PWM
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC1 if !S5PV210_SD_CH0_8BIT
+	select S3C_DEV_HSMMC3 if !S5PV210_SD_CH2_8BIT
+	select S5PV210_SETUP_SDHCI
+	select S5PV210_POWER_DOMAIN
 	help
 	  Machine support for Samsung SMDKV210
 
 config MACH_SMDKC110
 	bool "SMDKC110"
 	select CPU_S5PV210
-	select ARCH_SPARSEMEM_ENABLE
+	select ARCH_DISCONTIGMEM_ENABLE
 	select S3C_DEV_WDT
 	select HAVE_S3C2410_WATCHDOG
+	select S3C_DEV_I2C1
+	select S3C_DEV_I2C2
+	select HAVE_PWM
+	select ARCH_HAS_CPUFREQ
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC1 if !S5PV210_SD_CH0_8BIT
+	select S3C_DEV_HSMMC3 if !S5PV210_SD_CH2_8BIT
+	select S5PV210_SETUP_SDHCI
+	select S5PV210_POWER_DOMAIN
 	help
 	  Machine support for Samsung SMDKC110
 	  S5PC110(MCP) is one of package option of S5PV210
 
+config MACH_HERRING
+	bool "Herring"
+	select CPU_S5PV210
+	select ARCH_DISCONTIGMEM_ENABLE
+	select S3C_DEV_WDT
+	select HAVE_S3C2410_WATCHDOG
+	select S3C_DEV_I2C1
+	select S3C_DEV_I2C2
+	select HAVE_PWM
+	select ARCH_HAS_CPUFREQ
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC1 if !S5PV210_SD_CH0_8BIT
+	select S3C_DEV_HSMMC3 if !S5PV210_SD_CH2_8BIT
+	select S5PV210_SETUP_SDHCI
+	select S5PV210_POWER_DOMAIN
+	help
+	  Machine support for Herring
+
+endchoice
+
+choice
+	prompt "Select DMC0 memory type for S5PC110"
+	depends on MACH_SMDKC110
+	default S5PC110_MEM_DMC0_ONEDRAM
+
+config S5PC110_MEM_DMC0_ONEDRAM
+	bool "OneDRAM"
+	help
+	  If you have S5PC110 B-Type or D-Type, select it
+
+config S5PC110_MEM_DMC0_MDDR
+	bool "mDDR"
+	help
+	  If you have S5PC110 H-Type or N-Type, select it
+
+endchoice
+
+choice
+	prompt "Select board revision number for SMDKC110"
+	depends on MACH_SMDKC110
+	default SMDKC110_REV01
+
+config SMDKC110_REV01
+	bool "SMDKC110 Rev 0.1 or 0.2"
+	help
+	  If you have SMDKC110 CPU board revision 0.1 or 0.2, select it.
+
+config SMDKC110_REV03
+	bool "SMDKC110 Rev 0.3"
+	help
+	  If you have SMDKC110 CPU board revision 0.3, select it.
+
+endchoice
+
+choice
+	prompt "Select board revision number for SMDKV210"
+	depends on MACH_SMDKV210
+	default SMDKV210_REV01
+
+config SMDKV210_REV01
+	bool "SMDKV210 Rev 0.1"
+	help
+	  If you have SMDKV210 CPU board revision 0.1 or 0.2, select it.
+
+config SMDKV210_REV02
+	bool "SMDKV210 Rev 0.2"
+	help
+	  If you have SMDKV210 CPU board revision 0.2 and max8998 PMIC, select it.
+
+endchoice
+
+menu "Use 8-bit bus width"
+config S5PV210_SD_CH0_8BIT
+bool "Channel 0"
+depends on PLAT_S5P
+default n
+help
+IF channel 0 uses 8-bit bus, channel 1 is disabled.
+
+config S5PV210_SD_CH2_8BIT
+bool "Channel 2"
+depends on PLAT_S5P
+default n
+help
+IF channel 2 uses 8-bit bus, channel 3 is disabled.
+endmenu
+
+config S5PC110_DEV_ONENAND
+	bool
+	default y if CPU_S5PV210
+	help
+	  Compile in platform device definition for OneNAND1 controller
+
+config S5PV210_SETUP_FB
+	bool
+	depends on FB_S3C
+	default y
+	help
+	  Common setup code for FIMD controller.
+
+config S5P_ADC
+	bool	"S5PXXXX ADC driver"
+	depends on PLAT_S5P
+	default y
+	help
+	  ADC ( A/D Conversion ) driver for Samsung S5PXXXX
+
+config S5PV210_SETUP_FIMC0
+	bool
+	depends on VIDEO_FIMC
+	default y
+	help
+	  Common setup code for FIMC controller 0.
+
+config S5PV210_SETUP_FIMC1
+	bool
+	depends on VIDEO_FIMC
+	default y
+	help
+	  Common setup code for FIMC controller 1.
+
+config S5PV210_SETUP_FIMC2
+	bool
+	depends on VIDEO_FIMC
+	default y
+	help
+	  Common setup code for FIMC controller 2.
+
+config S5PV210_SETUP_CSIS
+	bool
+	depends on VIDEO_FIMC
+	default y
+	help
+	  Common setup code for MIPI-CSIS
+
+config WIFI_CONTROL_FUNC
+       bool "Enable WiFi control function abstraction"
+       help
+         Enables Power/Reset/Carddetect function abstraction
 endif
--- linux-2.6.35.7/arch/arm/mach-s5pv210/mach-smdkc110.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/mach-smdkc110.c	2011-08-08 12:52:05.000000000 +0800
@@ -12,19 +12,93 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/serial_core.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/regulator/consumer.h>
+#if defined(CONFIG_SMDKC110_REV03) || defined(CONFIG_SMDKV210_REV02)
+#include <linux/mfd/max8998.h>
+#else
+#include <linux/mfd/max8698.h>
+#endif
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/usb/ch9.h>
+#include <linux/pwm_backlight.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/clk.h>
+#include <linux/usb/ch9.h>
+#include <linux/input.h>
+#include <linux/irq.h>
+#include <linux/skbuff.h>
+#include <linux/console.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>
+#include <asm/system.h>
 
 #include <mach/map.h>
 #include <mach/regs-clock.h>
+#include <mach/regs-mem.h>
+#include <mach/gpio.h>
+#include <mach/gpio-smdkc110.h>
+#include <mach/regs-gpio.h>
+#include <mach/ts-s3c.h>
+#include <mach/adc.h>
+#include <mach/param.h>
+#include <mach/system.h>
+
+#ifdef CONFIG_S3C64XX_DEV_SPI
+#include <plat/s3c64xx-spi.h>
+#include <mach/spi-clocks.h>
+#endif
+
+#include <linux/usb/gadget.h>
+
+#include <plat/media.h>
+#include <mach/media.h>
+
+#ifdef CONFIG_ANDROID_PMEM
+#include <linux/android_pmem.h>
+#include <plat/media.h>
+#include <mach/media.h>
+#endif
+
+#ifdef CONFIG_S5PV210_POWER_DOMAIN
+#include <mach/power-domain.h>
+#endif
+
+#ifdef CONFIG_VIDEO_S5K4BA
+#include <media/s5k4ba_platform.h>
+#undef	CAM_ITU_CH_A
+#define	CAM_ITU_CH_B
+#endif
+
+#ifdef CONFIG_VIDEO_S5K4EA
+#include <media/s5k4ea_platform.h>
+#endif
 
 #include <plat/regs-serial.h>
 #include <plat/s5pv210.h>
 #include <plat/devs.h>
 #include <plat/cpu.h>
+#include <plat/fb.h>
+#include <plat/mfc.h>
+#include <plat/iic.h>
+#include <plat/pm.h>
+
+#include <plat/sdhci.h>
+#include <plat/fimc.h>
+#include <plat/csis.h>
+#include <plat/jpeg.h>
+#include <plat/clock.h>
+#include <plat/regs-otg.h>
+#include <../../../drivers/video/samsung/s3cfb.h>
 
 /* Following are default values for UCON, ULCON and UFCON UART registers */
 #define S5PV210_UCON_DEFAULT	(S3C2410_UCON_TXILEVEL |	\
@@ -40,29 +114,31 @@
 				 S5PV210_UFCON_TXTRIG4 |	\
 				 S5PV210_UFCON_RXTRIG4)
 
-static struct s3c2410_uartcfg smdkv210_uartcfgs[] __initdata = {
-	[0] = {
+static struct s3c2410_uartcfg smdkc110_uartcfgs[] __initdata = {
+	{
 		.hwport		= 0,
 		.flags		= 0,
 		.ucon		= S5PV210_UCON_DEFAULT,
 		.ulcon		= S5PV210_ULCON_DEFAULT,
 		.ufcon		= S5PV210_UFCON_DEFAULT,
 	},
-	[1] = {
+	{
 		.hwport		= 1,
 		.flags		= 0,
 		.ucon		= S5PV210_UCON_DEFAULT,
 		.ulcon		= S5PV210_ULCON_DEFAULT,
 		.ufcon		= S5PV210_UFCON_DEFAULT,
 	},
-	[2] = {
+#ifndef CONFIG_FIQ_DEBUGGER
+	{
 		.hwport		= 2,
 		.flags		= 0,
 		.ucon		= S5PV210_UCON_DEFAULT,
 		.ulcon		= S5PV210_ULCON_DEFAULT,
 		.ufcon		= S5PV210_UFCON_DEFAULT,
 	},
-	[3] = {
+#endif
+	{
 		.hwport		= 3,
 		.flags		= 0,
 		.ucon		= S5PV210_UCON_DEFAULT,
@@ -71,25 +147,1577 @@
 	},
 };
 
+#define S5PV210_LCD_WIDTH 800
+#define S5PV210_LCD_HEIGHT 480
+
+//#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0 (6144 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0 (24576 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC1 (9900 * SZ_1K)
+//#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC2 (6144 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC2 (24576 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0 (36864 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1 (36864 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMD (S5PV210_LCD_WIDTH * \
+					     S5PV210_LCD_HEIGHT * 4 * \
+					     CONFIG_FB_S3C_NR_BUFFERS)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_JPEG (8192 * SZ_1K)
+
+/* 1920 * 1080 * 4 (RGBA)
+ * - framesize == 1080p : 1920 * 1080 * 2(16bpp) * 2(double buffer) = 8MB
+ * - framesize <  1080p : 1080 *  720 * 4(32bpp) * 2(double buffer) = under 8MB
+ **/
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_G2D (8192 * SZ_1K)
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_TEXSTREAM (3000 * SZ_1K)
+#define  S5PV210_ANDROID_PMEM_MEMSIZE_PMEM_GPU1 (3300 * SZ_1K)
+
+static struct s5p_media_device smdkc110_media_devs[] = {
+	[0] = {
+		.id = S5P_MDEV_MFC,
+		.name = "mfc",
+		.bank = 0,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0,
+		.paddr = 0,
+	},
+	[1] = {
+		.id = S5P_MDEV_MFC,
+		.name = "mfc",
+		.bank = 1,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1,
+		.paddr = 0,
+	},
+	[2] = {
+		.id = S5P_MDEV_FIMC0,
+		.name = "fimc0",
+		.bank = 1,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0,
+		.paddr = 0,
+	},
+	[3] = {
+		.id = S5P_MDEV_FIMC1,
+		.name = "fimc1",
+		.bank = 1,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC1,
+		.paddr = 0,
+	},
+	[4] = {
+		.id = S5P_MDEV_FIMC2,
+		.name = "fimc2",
+		.bank = 1,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC2,
+		.paddr = 0,
+	},
+	[5] = {
+		.id = S5P_MDEV_JPEG,
+		.name = "jpeg",
+		.bank = 0,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_JPEG,
+		.paddr = 0,
+	},
+	[6] = {
+		.id = S5P_MDEV_FIMD,
+		.name = "fimd",
+		.bank = 1,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMD,
+		.paddr = 0,
+	},
+	[7] = {
+		.id = S5P_MDEV_TEXSTREAM,
+		.name = "texstream",
+		.bank = 1,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_TEXSTREAM,
+		.paddr = 0,
+	},
+	[8] = {
+		.id = S5P_MDEV_PMEM_GPU1,
+		.name = "pmem_gpu1",
+		.bank = 0, /* OneDRAM */
+		.memsize = S5PV210_ANDROID_PMEM_MEMSIZE_PMEM_GPU1,
+		.paddr = 0,
+	},
+	[9] = {
+		.id = S5P_MDEV_G2D,
+		.name = "g2d",
+		.bank = 0,
+		.memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_G2D,
+		.paddr = 0,
+	},
+};
+
+static struct regulator_consumer_supply ldo3_consumer[] = {
+	REGULATOR_SUPPLY("pd_io", "s3c-usbgadget")
+};
+
+static struct regulator_consumer_supply ldo4_consumer[] = {
+	{   .supply = "vddmipi", },
+};
+
+static struct regulator_consumer_supply ldo6_consumer[] = {
+	{   .supply = "vddlcd", },
+};
+
+static struct regulator_consumer_supply ldo7_consumer[] = {
+	{   .supply = "vddmodem", },
+};
+
+static struct regulator_consumer_supply ldo8_consumer[] = {
+	REGULATOR_SUPPLY("pd_core", "s3c-usbgadget")
+};
+
+static struct regulator_consumer_supply buck1_consumer[] = {
+	{   .supply = "vddarm", },
+};
+
+static struct regulator_consumer_supply buck2_consumer[] = {
+	{   .supply = "vddint", },
+};
+
+static struct regulator_init_data smdkc110_ldo2_data = {
+	.constraints	= {
+		.name		= "VALIVE_1.1V",
+		.min_uV		= 1100000,
+		.max_uV		= 1100000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.state_mem	= {
+			.enabled = 1,
+		},
+	},
+};
+
+static struct regulator_init_data smdkc110_ldo3_data = {
+	.constraints	= {
+		.name		= "VUOTG_D_1.1V/VUHOST_D_1.1V",
+		.min_uV		= 1100000,
+		.max_uV		= 1100000,
+		.apply_uV	= 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled = 1,
+		},
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(ldo3_consumer),
+	.consumer_supplies	= ldo3_consumer,
+};
+
+static struct regulator_init_data smdkc110_ldo4_data = {
+	.constraints	= {
+		.name		= "V_MIPI_1.8V",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled = 1,
+		},
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(ldo4_consumer),
+	.consumer_supplies	= ldo4_consumer,
+};
+
+static struct regulator_init_data smdkc110_ldo5_data = {
+	.constraints	= {
+		.name		= "VMMC_2.8V/VEXT_2.8V",
+		.min_uV		= 2800000,
+		.max_uV		= 2800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.state_mem	= {
+			.enabled = 1,
+		},
+	},
+};
+
+static struct regulator_init_data smdkc110_ldo6_data = {
+	.constraints	= {
+		.name		= "VCC_2.6V",
+		.min_uV		= 2600000,
+		.max_uV		= 2600000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	 = {
+			.disabled = 1,
+		},
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(ldo6_consumer),
+	.consumer_supplies	= ldo6_consumer,
+};
+
+static struct regulator_init_data smdkc110_ldo7_data = {
+	.constraints	= {
+		.name		= "VDAC_2.8V",
+		.min_uV		= 2800000,
+		.max_uV		= 2800000,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(ldo7_consumer),
+	.consumer_supplies  = ldo7_consumer,
+};
+
+static struct regulator_init_data smdkc110_ldo8_data = {
+	.constraints	= {
+		.name		= "VUOTG_A_3.3V/VUHOST_A_3.3V",
+		.min_uV		= 3300000,
+		.max_uV		= 3300000,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(ldo8_consumer),
+	.consumer_supplies	= ldo8_consumer,
+};
+
+static struct regulator_init_data smdkc110_ldo9_data = {
+	.constraints	= {
+		.name		= "{VADC/VSYS/VKEY}_2.8V",
+		.min_uV		= 2800000,
+		.max_uV		= 2800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.state_mem	= {
+			.enabled = 1,
+		},
+	},
+};
+
+static struct regulator_init_data smdkc110_buck1_data = {
+	.constraints	= {
+		.name		= "VCC_ARM",
+		.min_uV		= 750000,
+		.max_uV		= 1500000,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				  REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.uV	= 1250000,
+			.mode	= REGULATOR_MODE_NORMAL,
+			.disabled = 1,
+		},
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(buck1_consumer),
+	.consumer_supplies	= buck1_consumer,
+};
+
+static struct regulator_init_data smdkc110_buck2_data = {
+	.constraints	= {
+		.name		= "VCC_INTERNAL",
+		.min_uV		= 950000,
+		.max_uV		= 1200000,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				  REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.uV	= 1100000,
+			.mode	= REGULATOR_MODE_NORMAL,
+			.disabled = 1,
+		},
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(buck2_consumer),
+	.consumer_supplies  = buck2_consumer,
+};
+
+static struct regulator_init_data smdkc110_buck3_data = {
+	.constraints	= {
+		.name		= "VCC_MEM",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.always_on	= 1,
+		.apply_uV	= 1,
+		.state_mem	= {
+			.uV	= 1800000,
+			.mode	= REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+};
+
+#if defined(CONFIG_SMDKC110_REV03) || defined(CONFIG_SMDKV210_REV02)
+static struct max8998_regulator_data smdkc110_regulators[] = {
+	{ MAX8998_LDO2,  &smdkc110_ldo2_data },
+	{ MAX8998_LDO3,  &smdkc110_ldo3_data },
+	{ MAX8998_LDO4,  &smdkc110_ldo4_data },
+	{ MAX8998_LDO5,  &smdkc110_ldo5_data },
+	{ MAX8998_LDO6,  &smdkc110_ldo6_data },
+	{ MAX8998_LDO7,  &smdkc110_ldo7_data },
+	{ MAX8998_LDO8,  &smdkc110_ldo8_data },
+	{ MAX8998_LDO9,  &smdkc110_ldo9_data },
+	{ MAX8998_BUCK1, &smdkc110_buck1_data },
+	{ MAX8998_BUCK2, &smdkc110_buck2_data },
+	{ MAX8998_BUCK3, &smdkc110_buck3_data },
+};
+
+static struct max8998_platform_data max8998_pdata = {
+	.num_regulators	= ARRAY_SIZE(smdkc110_regulators),
+	.regulators	= smdkc110_regulators,
+	.charger	= NULL,
+};
+#else
+static struct max8698_regulator_data smdkc110_regulators[] = {
+	{ MAX8698_LDO2,  &smdkc110_ldo2_data },
+	{ MAX8698_LDO3,  &smdkc110_ldo3_data },
+	{ MAX8698_LDO4,  &smdkc110_ldo4_data },
+	{ MAX8698_LDO5,  &smdkc110_ldo5_data },
+	{ MAX8698_LDO6,  &smdkc110_ldo6_data },
+	{ MAX8698_LDO7,  &smdkc110_ldo7_data },
+	{ MAX8698_LDO8,  &smdkc110_ldo8_data },
+	{ MAX8698_LDO9,  &smdkc110_ldo9_data },
+	{ MAX8698_BUCK1, &smdkc110_buck1_data },
+	{ MAX8698_BUCK2, &smdkc110_buck2_data },
+	{ MAX8698_BUCK3, &smdkc110_buck3_data },
+};
+
+static struct max8698_platform_data max8698_pdata = {
+	.num_regulators = ARRAY_SIZE(smdkc110_regulators),
+	.regulators     = smdkc110_regulators,
+
+	/* 1GHz default voltage */
+	.dvsarm1        = 0xa,  /* 1.25v */
+	.dvsarm2        = 0x9,  /* 1.20V */
+	.dvsarm3        = 0x6,  /* 1.05V */
+	.dvsarm4        = 0x4,  /* 0.95V */
+	.dvsint1        = 0x7,  /* 1.10v */
+	.dvsint2        = 0x5,  /* 1.00V */
+
+	.set1       = S5PV210_GPH1(6),
+	.set2       = S5PV210_GPH1(7),
+	.set3       = S5PV210_GPH0(4),
+};
+#endif
+
+static void __init smdkc110_setup_clocks(void)
+{
+	struct clk *pclk;
+	struct clk *clk;
+
+#ifdef CONFIG_S3C_DEV_HSMMC
+	/* set MMC0 clock */
+	clk = clk_get(&s3c_device_hsmmc0.dev, "sclk_mmc");
+	pclk = clk_get(NULL, "mout_mpll");
+	clk_set_parent(clk, pclk);
+	clk_set_rate(clk, 50*MHZ);
+
+	pr_info("%s: %s: source is %s, rate is %ld\n",
+				__func__, clk->name, clk->parent->name,
+				clk_get_rate(clk));
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC1
+	/* set MMC1 clock */
+	clk = clk_get(&s3c_device_hsmmc1.dev, "sclk_mmc");
+	pclk = clk_get(NULL, "mout_mpll");
+	clk_set_parent(clk, pclk);
+	clk_set_rate(clk, 50*MHZ);
+
+	pr_info("%s: %s: source is %s, rate is %ld\n",
+				__func__, clk->name, clk->parent->name,
+				clk_get_rate(clk));
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC2
+	/* set MMC2 clock */
+	clk = clk_get(&s3c_device_hsmmc2.dev, "sclk_mmc");
+	pclk = clk_get(NULL, "mout_mpll");
+	clk_set_parent(clk, pclk);
+	clk_set_rate(clk, 50*MHZ);
+
+	pr_info("%s: %s: source is %s, rate is %ld\n",
+				__func__, clk->name, clk->parent->name,
+				clk_get_rate(clk));
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC3
+	/* set MMC3 clock */
+	clk = clk_get(&s3c_device_hsmmc3.dev, "sclk_mmc");
+	pclk = clk_get(NULL, "mout_mpll");
+	clk_set_parent(clk, pclk);
+	clk_set_rate(clk, 50*MHZ);
+
+	pr_info("%s: %s: source is %s, rate is %ld\n",
+				__func__, clk->name, clk->parent->name,
+			 clk_get_rate(clk));
+#endif
+}
+
+#if defined(CONFIG_TOUCHSCREEN_S3C)
+static struct s3c_ts_mach_info s3c_ts_platform __initdata = {
+	.delay                  = 10000,
+	.presc                  = 49,
+	.oversampling_shift     = 2,
+	.resol_bit              = 12,
+	.s3c_adc_con            = ADC_TYPE_2,
+};
+
+/* Touch srcreen */
+static struct resource s3c_ts_resource[] = {
+	[0] = {
+		.start = S3C_PA_ADC,
+		.end   = S3C_PA_ADC + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_PENDN,
+		.end   = IRQ_PENDN,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_ADC,
+		.end   = IRQ_ADC,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_ts = {
+	.name		  = "s3c-ts",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_ts_resource),
+	.resource	  = s3c_ts_resource,
+};
+
+void __init s3c_ts_set_platdata(struct s3c_ts_mach_info *pd)
+{
+	struct s3c_ts_mach_info *npd;
+
+	npd = kmalloc(sizeof(*npd), GFP_KERNEL);
+	if (npd) {
+		memcpy(npd, pd, sizeof(*npd));
+		s3c_device_ts.dev.platform_data = npd;
+	} else {
+		pr_err("no memory for Touchscreen platform data\n");
+	}
+}
+#endif
+
+#if defined(CONFIG_KEYPAD_S3C) || defined(CONFIG_KEYPAD_S3C_MODULE)
+#if defined(CONFIG_KEYPAD_S3C_MSM)
+void s3c_setup_keypad_cfg_gpio(void)
+{
+	unsigned int gpio;
+	unsigned int end;
+
+	/* gpio setting for KP_COL0 */
+	s3c_gpio_cfgpin(S5PV210_GPJ1(5), S3C_GPIO_SFN(3));
+	s3c_gpio_setpull(S5PV210_GPJ1(5), S3C_GPIO_PULL_NONE);
+
+	/* gpio setting for KP_COL1 ~ KP_COL7 and KP_ROW0 */
+	end = S5PV210_GPJ2(8);
+	for (gpio = S5PV210_GPJ2(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+
+	/* gpio setting for KP_ROW1 ~ KP_ROW8 */
+	end = S5PV210_GPJ3(8);
+	for (gpio = S5PV210_GPJ3(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+
+	/* gpio setting for KP_ROW9 ~ KP_ROW13 */
+	end = S5PV210_GPJ4(5);
+	for (gpio = S5PV210_GPJ4(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+}
+#else
+void s3c_setup_keypad_cfg_gpio(int rows, int columns)
+{
+	unsigned int gpio;
+	unsigned int end;
+
+	end = S5PV210_GPH3(rows);
+
+	/* Set all the necessary GPH2 pins to special-function 0 */
+	for (gpio = S5PV210_GPH3(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
+	}
+
+	end = S5PV210_GPH2(columns);
+
+	/* Set all the necessary GPK pins to special-function 0 */
+	for (gpio = S5PV210_GPH2(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+}
+#endif /* if defined(CONFIG_KEYPAD_S3C_MSM)*/
+EXPORT_SYMBOL(s3c_setup_keypad_cfg_gpio);
+#endif
+
+#ifdef CONFIG_DM9000
+static void __init smdkc110_dm9000_set(void)
+{
+	unsigned int tmp;
+
+	tmp = ((0<<28)|(0<<24)|(5<<16)|(0<<12)|(0<<8)|(0<<4)|(0<<0));
+	__raw_writel(tmp, (S5P_SROM_BW+0x18));
+
+	tmp = __raw_readl(S5P_SROM_BW);
+	tmp &= ~(0xf << 20);
+
+	tmp |= (0x1 << 20); /* dm9000 16bit */
+	__raw_writel(tmp, S5P_SROM_BW);
+
+	tmp = __raw_readl(S5PV210_MP01CON);
+	tmp &= ~(0xf << 20);
+	tmp |= (2 << 20);
+
+	__raw_writel(tmp, S5PV210_MP01CON);
+}
+#endif
+
+#ifdef CONFIG_FB_S3C_LTE480WV
+static struct s3cfb_lcd lte480wv = {
+	.width = S5PV210_LCD_WIDTH,
+	.height = S5PV210_LCD_HEIGHT,
+	.bpp = 32,
+	.freq = 60,
+
+	.timing = {
+		.h_fp = 8,
+		.h_bp = 13,
+		.h_sw = 3,
+		.v_fp = 5,
+		.v_fpe = 1,
+		.v_bp = 7,
+		.v_bpe = 1,
+		.v_sw = 1,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static void lte480wv_cfg_gpio(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		s3c_gpio_cfgpin(S5PV210_GPF0(i), S3C_GPIO_SFN(2));
+		s3c_gpio_setpull(S5PV210_GPF0(i), S3C_GPIO_PULL_NONE);
+	}
+
+	for (i = 0; i < 8; i++) {
+		s3c_gpio_cfgpin(S5PV210_GPF1(i), S3C_GPIO_SFN(2));
+		s3c_gpio_setpull(S5PV210_GPF1(i), S3C_GPIO_PULL_NONE);
+	}
+
+	for (i = 0; i < 8; i++) {
+		s3c_gpio_cfgpin(S5PV210_GPF2(i), S3C_GPIO_SFN(2));
+		s3c_gpio_setpull(S5PV210_GPF2(i), S3C_GPIO_PULL_NONE);
+	}
+
+	for (i = 0; i < 4; i++) {
+		s3c_gpio_cfgpin(S5PV210_GPF3(i), S3C_GPIO_SFN(2));
+		s3c_gpio_setpull(S5PV210_GPF3(i), S3C_GPIO_PULL_NONE);
+	}
+
+	/* mDNIe SEL: why we shall write 0x2 ? */
+	writel(0x2, S5P_MDNIE_SEL);
+
+	/* drive strength to max */
+	writel(0xffffffff, S5PV210_GPF0_BASE + 0xc);
+	writel(0xffffffff, S5PV210_GPF1_BASE + 0xc);
+	writel(0xffffffff, S5PV210_GPF2_BASE + 0xc);
+	writel(0x000000ff, S5PV210_GPF3_BASE + 0xc);
+}
+
+#define S5PV210_GPD_0_0_TOUT_0  (0x2)
+#define S5PV210_GPD_0_1_TOUT_1  (0x2 << 4)
+#define S5PV210_GPD_0_2_TOUT_2  (0x2 << 8)
+#define S5PV210_GPD_0_3_TOUT_3  (0x2 << 12)
+static int lte480wv_backlight_on(struct platform_device *pdev)
+{
+	int err;
+
+	err = gpio_request(S5PV210_GPD0(3), "GPD0");
+
+	if (err) {
+		printk(KERN_ERR "failed to request GPD0 for "
+			"lcd backlight control\n");
+		return err;
+	}
+
+	gpio_direction_output(S5PV210_GPD0(3), 1);
+
+	s3c_gpio_cfgpin(S5PV210_GPD0(3), S5PV210_GPD_0_3_TOUT_3);
+
+	gpio_free(S5PV210_GPD0(3));
+	return 0;
+}
+
+static int lte480wv_backlight_off(struct platform_device *pdev, int onoff)
+{
+	int err;
+
+	err = gpio_request(S5PV210_GPD0(3), "GPD0");
+
+	if (err) {
+		printk(KERN_ERR "failed to request GPD0 for "
+				"lcd backlight control\n");
+		return err;
+	}
+
+	gpio_direction_output(S5PV210_GPD0(3), 0);
+	gpio_free(S5PV210_GPD0(3));
+	return 0;
+}
+
+static int lte480wv_reset_lcd(struct platform_device *pdev)
+{
+	int err;
+
+	err = gpio_request(S5PV210_GPH0(6), "GPH0");
+	if (err) {
+		printk(KERN_ERR "failed to request GPH0 for "
+				"lcd reset control\n");
+		return err;
+	}
+
+	gpio_direction_output(S5PV210_GPH0(6), 1);
+	mdelay(100);
+
+	gpio_set_value(S5PV210_GPH0(6), 0);
+	mdelay(10);
+
+	gpio_set_value(S5PV210_GPH0(6), 1);
+	mdelay(10);
+
+	gpio_free(S5PV210_GPH0(6));
+
+	return 0;
+}
+
+static struct s3c_platform_fb lte480wv_fb_data __initdata = {
+	.hw_ver	= 0x62,
+	.nr_wins = 5,
+	.default_win = CONFIG_FB_S3C_DEFAULT_WINDOW,
+	.swap = FB_SWAP_WORD | FB_SWAP_HWORD,
+
+	.lcd = &lte480wv,
+	.cfg_gpio	= lte480wv_cfg_gpio,
+	.backlight_on	= lte480wv_backlight_on,
+	.backlight_onoff    = lte480wv_backlight_off,
+	.reset_lcd	= lte480wv_reset_lcd,
+};
+#endif
+
+#ifdef CONFIG_S3C64XX_DEV_SPI
+
+#define SMDK_MMCSPI_CS 0
+static struct s3c64xx_spi_csinfo smdk_spi0_csi[] = {
+	[SMDK_MMCSPI_CS] = {
+		.line = S5PV210_GPB(1),
+		.set_level = gpio_set_value,
+		.fb_delay = 0x0,
+	},
+};
+
+static struct s3c64xx_spi_csinfo smdk_spi1_csi[] = {
+	[SMDK_MMCSPI_CS] = {
+		.line = S5PV210_GPB(5),
+		.set_level = gpio_set_value,
+		.fb_delay = 0x0,
+	},
+};
+
+static struct spi_board_info s3c_spi_devs[] __initdata = {
+	[0] = {
+		.modalias        = "spidev",	/* device node name */
+		.mode            = SPI_MODE_0,	/* CPOL=0, CPHA=0 */
+		.max_speed_hz    = 10000000,
+		/* Connected to SPI-0 as 1st Slave */
+		.bus_num         = 0,
+		.irq             = IRQ_SPI0,
+		.chip_select     = 0,
+		.controller_data = &smdk_spi0_csi[SMDK_MMCSPI_CS],
+	},
+	[1] = {
+		.modalias        = "spidev",	/* device node name */
+		.mode            = SPI_MODE_0,	/* CPOL=0, CPHA=0 */
+		.max_speed_hz    = 10000000,
+		/* Connected to SPI-1 as 1st Slave */
+		.bus_num         = 1,
+		.irq             = IRQ_SPI1,
+		.chip_select     = 0,
+		.controller_data = &smdk_spi1_csi[SMDK_MMCSPI_CS],
+	},
+};
+#endif
+
+#ifdef CONFIG_HAVE_PWM
+struct s3c_pwm_data {
+	/* PWM output port */
+	unsigned int gpio_no;
+	const char  *gpio_name;
+	unsigned int gpio_set_value;
+};
+
+struct s3c_pwm_data pwm_data[] = {
+	{
+		.gpio_no    = S5PV210_GPD0(0),
+		.gpio_name  = "GPD",
+		.gpio_set_value = S5PV210_GPD_0_0_TOUT_0,
+	}, {
+		.gpio_no    = S5PV210_GPD0(1),
+		.gpio_name  = "GPD",
+		.gpio_set_value = S5PV210_GPD_0_1_TOUT_1,
+	}, {
+		.gpio_no    = S5PV210_GPD0(2),
+		.gpio_name      = "GPD",
+		.gpio_set_value = S5PV210_GPD_0_2_TOUT_2,
+	}, {
+		.gpio_no    = S5PV210_GPD0(3),
+		.gpio_name      = "GPD",
+		.gpio_set_value = S5PV210_GPD_0_3_TOUT_3,
+	}
+};
+#endif
+
+#if defined(CONFIG_BACKLIGHT_PWM)
+static struct platform_pwm_backlight_data smdk_backlight_data = {
+	.pwm_id  = 3,
+	.max_brightness = 255,
+	.dft_brightness = 255,
+	.pwm_period_ns  = 25000,
+};
+
+static struct platform_device smdk_backlight_device = {
+	.name      = "pwm-backlight",
+	.id        = -1,
+	.dev        = {
+		.parent = &s3c_device_timer[3].dev,
+		.platform_data = &smdk_backlight_data,
+	},
+};
+
+static void __init smdk_backlight_register(void)
+{
+	int ret;
+#ifdef CONFIG_HAVE_PWM
+	int i, ntimer;
+
+	/* Timer GPIO Set */
+	ntimer = ARRAY_SIZE(pwm_data);
+	for (i = 0; i < ntimer; i++) {
+		if (gpio_is_valid(pwm_data[i].gpio_no)) {
+			ret = gpio_request(pwm_data[i].gpio_no,
+				pwm_data[i].gpio_name);
+			if (ret) {
+				printk(KERN_ERR "failed to get GPIO for PWM\n");
+				return;
+			}
+			s3c_gpio_cfgpin(pwm_data[i].gpio_no,
+				pwm_data[i].gpio_set_value);
+
+			gpio_free(pwm_data[i].gpio_no);
+		}
+	}
+#endif
+	ret = platform_device_register(&smdk_backlight_device);
+	if (ret)
+		printk(KERN_ERR "smdk: failed to register backlight device: %d\n", ret);
+}
+#endif
+
+#ifdef CONFIG_S5P_ADC
+static struct s3c_adc_mach_info s3c_adc_platform __initdata = {
+	/* s5pc110 support 12-bit resolution */
+	.delay  = 10000,
+	.presc  = 49,
+	.resolution = 12,
+};
+#endif
+
+/*
+ * External camera reset
+ * Because the most of cameras take i2c bus signal, so that
+ * you have to reset at the boot time for other i2c slave devices.
+ * This function also called at fimc_init_camera()
+ * Do optimization for cameras on your platform.
+*/
+#ifdef CAM_ITU_CH_A
+static int smdkv210_cam0_power(int onoff)
+{
+	int err;
+	/* Camera A */
+	err = gpio_request(GPIO_PS_VOUT, "GPH0");
+	if (err)
+		printk(KERN_ERR "failed to request GPH0 for CAM_2V8\n");
+
+	s3c_gpio_setpull(GPIO_PS_VOUT, S3C_GPIO_PULL_NONE);
+	gpio_direction_output(GPIO_PS_VOUT, 0);
+	gpio_direction_output(GPIO_PS_VOUT, 1);
+	gpio_free(GPIO_PS_VOUT);
+
+	return 0;
+}
+#else
+static int smdkv210_cam1_power(int onoff)
+{
+	int err;
+
+	/* S/W workaround for the SMDK_CAM4_type board
+	 * When SMDK_CAM4 type module is initialized at power reset,
+	 * it needs the cam_mclk.
+	 *
+	 * Now cam_mclk is set as below, need only set the gpio mux.
+	 * CAM_SRC1 = 0x0006000, CLK_DIV1 = 0x00070400.
+	 * cam_mclk source is SCLKMPLL, and divider value is 8.
+	*/
+
+	/* gpio mux select the cam_mclk */
+	err = gpio_request(GPIO_PS_ON, "GPJ1");
+	if (err)
+		printk(KERN_ERR "failed to request GPJ1 for CAM_2V8\n");
+
+	s3c_gpio_setpull(GPIO_PS_ON, S3C_GPIO_PULL_NONE);
+	s3c_gpio_cfgpin(GPIO_PS_ON, (0x3<<16));
+
+
+	/* Camera B */
+	err = gpio_request(GPIO_BUCK_1_EN_A, "GPH0");
+	if (err)
+		printk(KERN_ERR "failed to request GPH0 for CAM_2V8\n");
+
+	s3c_gpio_setpull(GPIO_BUCK_1_EN_A, S3C_GPIO_PULL_NONE);
+	gpio_direction_output(GPIO_BUCK_1_EN_A, 0);
+	gpio_direction_output(GPIO_BUCK_1_EN_A, 1);
+
+	udelay(1000);
+
+	gpio_free(GPIO_PS_ON);
+	gpio_free(GPIO_BUCK_1_EN_A);
+
+	return 0;
+}
+#endif
+static int s5k5ba_power_en(int onoff)
+{
+	if (onoff) {
+#ifdef CAM_ITU_CH_A
+		smdkv210_cam0_power(onoff);
+#else
+		smdkv210_cam1_power(onoff);
+#endif
+	} else {
+#ifdef CAM_ITU_CH_A
+		smdkv210_cam0_power(onoff);
+#else
+		smdkv210_cam1_power(onoff);
+#endif
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_S5K4EA
+/* Set for MIPI-CSI Camera module Power Enable */
+static int smdkv210_mipi_cam_pwr_en(int enabled)
+{
+	int err;
+
+	err = gpio_request(S5PV210_GPH1(2), "GPH1");
+	if (err)
+		printk(KERN_ERR "#### failed to request(GPH1)for CAM_2V8\n");
+
+	s3c_gpio_setpull(S5PV210_GPH1(2), S3C_GPIO_PULL_NONE);
+	gpio_direction_output(S5PV210_GPH1(2), enabled);
+	gpio_free(S5PV210_GPH1(2));
+
+	return 0;
+}
+
+/* Set for MIPI-CSI Camera module Reset */
+static int smdkv210_mipi_cam_rstn(int enabled)
+{
+	int err;
+
+	err = gpio_request(S5PV210_GPH0(3), "GPH0");
+	if (err)
+		printk(KERN_ERR "#### failed to reset(GPH0) for MIPI CAM\n");
+
+	s3c_gpio_setpull(S5PV210_GPH0(3), S3C_GPIO_PULL_NONE);
+	gpio_direction_output(S5PV210_GPH0(3), enabled);
+	gpio_free(S5PV210_GPH0(3));
+
+	return 0;
+}
+
+/* MIPI-CSI Camera module Power up/down sequence */
+static int smdkv210_mipi_cam_power(int on)
+{
+	if (on) {
+		smdkv210_mipi_cam_pwr_en(1);
+		mdelay(5);
+		smdkv210_mipi_cam_rstn(1);
+	} else {
+		smdkv210_mipi_cam_rstn(0);
+		mdelay(5);
+		smdkv210_mipi_cam_pwr_en(0);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_S5K4BA
+static struct s5k4ba_platform_data s5k4ba_plat = {
+	.default_width = 800,
+	.default_height = 600,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 44000000,
+	.is_mipi = 0,
+};
+
+static struct i2c_board_info  s5k4ba_i2c_info = {
+	I2C_BOARD_INFO("S5K4BA", 0x2d),
+	.platform_data = &s5k4ba_plat,
+};
+
+static struct s3c_platform_camera s5k4ba = {
+	#ifdef CAM_ITU_CH_A
+	.id		= CAMERA_PAR_A,
+	#else
+	.id		= CAMERA_PAR_B,
+	#endif
+	.type		= CAM_TYPE_ITU,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.i2c_busnum	= 0,
+	.info		= &s5k4ba_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.srclk_name	= "mout_mpll",
+	/* .srclk_name	= "xusbxti", */
+	.clk_name	= "sclk_cam1",
+	.clk_rate	= 44000000,
+	.line_length	= 1920,
+	.width		= 800,
+	.height		= 600,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 800,
+		.height	= 600,
+	},
+
+	/* Polarity */
+	.inv_pclk	= 0,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+
+	.initialized	= 0,
+	.cam_power	= s5k5ba_power_en,
+};
+#endif
+
+/* 2 MIPI Cameras */
+#ifdef CONFIG_VIDEO_S5K4EA
+static struct s5k4ea_platform_data s5k4ea_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 1,
+};
+
+static struct i2c_board_info  s5k4ea_i2c_info = {
+	I2C_BOARD_INFO("S5K4EA", 0x2d),
+	.platform_data = &s5k4ea_plat,
+};
+
+static struct s3c_platform_camera s5k4ea = {
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.i2c_busnum	= 0,
+	.info		= &s5k4ea_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.srclk_name	= "mout_mpll",
+	.clk_name	= "sclk_cam0",
+	/* .clk_name	= "sclk_cam1", */
+	.clk_rate	= 48000000,
+	.line_length	= 1920,
+	.width		= 1920,
+	.height		= 1080,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1920,
+		.height	= 1080,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 32,
+
+	/* Polarity */
+	.inv_pclk	= 0,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+
+	.initialized	= 0,
+	.cam_power	= smdkv210_mipi_cam_power,
+};
+#endif
+
+/* Interface setting */
+static struct s3c_platform_fimc fimc_plat_lsi = {
+	.srclk_name	= "mout_mpll",
+	.clk_name	= "sclk_fimc",
+	.lclk_name	= "sclk_fimc_lclk",
+	.clk_rate	= 166750000,
+#if defined(CONFIG_VIDEO_S5K4EA)
+	.default_cam	= CAMERA_CSI_C,
+#else
+#ifdef CAM_ITU_CH_A
+	.default_cam	= CAMERA_PAR_A,
+#else
+	.default_cam	= CAMERA_PAR_B,
+#endif
+#endif
+	.camera		= {
+#ifdef CONFIG_VIDEO_S5K4ECGX
+			&s5k4ecgx,
+#endif
+#ifdef CONFIG_VIDEO_S5KA3DFX
+			&s5ka3dfx,
+#endif
+#ifdef CONFIG_VIDEO_S5K4BA
+			&s5k4ba,
+#endif
+#ifdef CONFIG_VIDEO_S5K4EA
+			&s5k4ea,
+#endif
+	},
+	.hw_ver		= 0x43,
+};
+
+#ifdef CONFIG_VIDEO_JPEG_V2
+static struct s3c_platform_jpeg jpeg_plat __initdata = {
+	.max_main_width	= 800,
+	.max_main_height	= 480,
+	.max_thumb_width	= 320,
+	.max_thumb_height	= 240,
+};
+#endif
+
+
+/* I2C0 */
+static struct i2c_board_info i2c_devs0[] __initdata = {
+#ifdef CONFIG_SND_SOC_WM8580
+	{
+		I2C_BOARD_INFO("wm8580", 0x1b),
+	},
+#endif
+};
+
+/* I2C1 */
+static struct i2c_board_info i2c_devs1[] __initdata = {
+#ifdef CONFIG_VIDEO_TV20
+	{
+		I2C_BOARD_INFO("s5p_ddc", (0x74>>1)),
+	},
+#endif
+};
+
+/* I2C2 */
+static struct i2c_board_info i2c_devs2[] __initdata = {
+	{
+#if defined(CONFIG_SMDKC110_REV03) || defined(CONFIG_SMDKV210_REV02)
+		/* The address is 0xCC used since SRAD = 0 */
+		I2C_BOARD_INFO("max8998", (0xCC >> 1)),
+		.platform_data = &max8998_pdata,
+#else
+		/* The address is 0xCC used since SRAD = 0 */
+		I2C_BOARD_INFO("max8698", (0xCC >> 1)),
+		.platform_data = &max8698_pdata,
+#endif
+	},
+};
+
+#define S5PV210_PS_HOLD_CONTROL_REG (S3C_VA_SYS+0xE81C)
+static void smdkc110_power_off(void)
+{
+	/* PS_HOLD output High --> Low */
+	writel(readl(S5PV210_PS_HOLD_CONTROL_REG) & 0xFFFFFEFF,
+			S5PV210_PS_HOLD_CONTROL_REG);
+
+	while (1);
+}
+
+#ifdef CONFIG_BATTERY_S3C
+struct platform_device sec_device_battery = {
+	.name   = "sec-fake-battery",
+	.id = -1,
+};
+#endif
+
+#ifdef CONFIG_ANDROID_PMEM
+static struct android_pmem_platform_data pmem_gpu1_pdata = {
+	.name = "pmem_gpu1",
+	.no_allocator = 1,
+	.cached = 1,
+	.buffered = 1,
+	.start = 0,
+	.size = 0,
+};
+
+static struct platform_device pmem_gpu1_device = {
+	.name = "android_pmem",
+	.id = 1,
+	.dev = { .platform_data = &pmem_gpu1_pdata },
+};
+
+static void __init android_pmem_set_platdata(void)
+{
+	pmem_gpu1_pdata.start =
+		(u32)s5p_get_media_memory_bank(S5P_MDEV_PMEM_GPU1, 0);
+	pmem_gpu1_pdata.size =
+		(u32)s5p_get_media_memsize_bank(S5P_MDEV_PMEM_GPU1, 0);
+}
+#endif
+
 static struct platform_device *smdkc110_devices[] __initdata = {
+#ifdef CONFIG_FIQ_DEBUGGER
+	&s5pv210_device_fiqdbg_uart2,
+#endif
+#ifdef CONFIG_MTD_ONENAND
+	&s5pc110_device_onenand,
+#endif
+#ifdef CONFIG_MTD_NAND
+	&s3c_device_nand,
+#endif
+	&s5p_device_rtc,
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_V4
 	&s5pv210_device_iis0,
+#endif
+#ifdef CONFIG_SND_S3C_SOC_AC97
 	&s5pv210_device_ac97,
+#endif
+#ifdef CONFIG_SND_S3C_SOC_PCM
+	&s5pv210_device_pcm0,
+#endif
+#ifdef CONFIG_SND_SOC_SPDIF
+	&s5pv210_device_spdif,
+#endif
 	&s3c_device_wdt,
+
+#ifdef CONFIG_FB_S3C
+	&s3c_device_fb,
+#endif
+#ifdef CONFIG_DM9000
+	&s5p_device_dm9000,
+#endif
+
+#ifdef CONFIG_VIDEO_MFC50
+	&s3c_device_mfc,
+#endif
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	&s3c_device_ts,
+#endif
+	&s3c_device_keypad,
+#ifdef CONFIG_S5P_ADC
+	&s3c_device_adc,
+#endif
+#ifdef CONFIG_VIDEO_FIMC
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_fimc2,
+#endif
+#ifdef CONFIG_VIDEO_FIMC_MIPI
+	&s3c_device_csis,
+#endif
+#ifdef CONFIG_VIDEO_JPEG_V2
+	&s3c_device_jpeg,
+#endif
+#ifdef CONFIG_VIDEO_G2D
+	&s3c_device_g2d,
+#endif
+#ifdef CONFIG_VIDEO_TV20
+	&s5p_device_tvout,
+	&s5p_device_cec,
+	&s5p_device_hpd,
+#endif
+
+	&s3c_device_g3d,
+	&s3c_device_lcd,
+
+	&s3c_device_i2c0,
+#ifdef CONFIG_S3C_DEV_I2C1
+	&s3c_device_i2c1,
+#endif
+#ifdef CONFIG_S3C_DEV_I2C2
+	&s3c_device_i2c2,
+#endif
+
+#ifdef CONFIG_USB_EHCI_HCD
+	&s3c_device_usb_ehci,
+#endif
+#ifdef CONFIG_USB_OHCI_HCD
+	&s3c_device_usb_ohci,
+#endif
+
+#ifdef CONFIG_USB_GADGET
+	&s3c_device_usbgadget,
+#endif
+#ifdef CONFIG_USB_ANDROID
+	&s3c_device_android_usb,
+#ifdef CONFIG_USB_ANDROID_MASS_STORAGE
+	&s3c_device_usb_mass_storage,
+#endif
+#ifdef CONFIG_USB_ANDROID_RNDIS
+	&s3c_device_rndis,
+#endif
+#endif
+#ifdef CONFIG_BATTERY_S3C
+	&sec_device_battery,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC
+	&s3c_device_hsmmc0,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC1
+	&s3c_device_hsmmc1,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC2
+	&s3c_device_hsmmc2,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC3
+	&s3c_device_hsmmc3,
+#endif
+
+#ifdef CONFIG_S3C64XX_DEV_SPI
+	&s5pv210_device_spi0,
+	&s5pv210_device_spi1,
+#endif
+#ifdef CONFIG_S5PV210_POWER_DOMAIN
+	&s5pv210_pd_audio,
+	&s5pv210_pd_cam,
+	&s5pv210_pd_tv,
+	&s5pv210_pd_lcd,
+	&s5pv210_pd_g3d,
+	&s5pv210_pd_mfc,
+#endif
+
+#ifdef CONFIG_HAVE_PWM
+	&s3c_device_timer[0],
+	&s3c_device_timer[1],
+	&s3c_device_timer[2],
+	&s3c_device_timer[3],
+#endif
 };
 
 static void __init smdkc110_map_io(void)
 {
 	s5p_init_io(NULL, 0, S5P_VA_CHIPID);
 	s3c24xx_init_clocks(24000000);
-	s3c24xx_init_uarts(smdkv210_uartcfgs, ARRAY_SIZE(smdkv210_uartcfgs));
+	s5pv210_gpiolib_init();
+	s3c24xx_init_uarts(smdkc110_uartcfgs, ARRAY_SIZE(smdkc110_uartcfgs));
+	s5p_reserve_bootmem(smdkc110_media_devs, ARRAY_SIZE(smdkc110_media_devs));
+#ifdef CONFIG_MTD_ONENAND
+	s5pc110_device_onenand.name = "s5pc110-onenand";
+#endif
+#ifdef CONFIG_MTD_NAND
+	s3c_device_nand.name = "s5pv210-nand";
+#endif
+	s5p_device_rtc.name = "smdkc110-rtc";
+}
+
+unsigned int pm_debug_scratchpad;
+
+static void __init sound_init(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(S5P_CLK_OUT);
+	reg &= ~(0x1f << 12);
+	reg &= ~(0xf << 20);
+	reg |= 0x12 << 12;
+	reg |= 0x1  << 20;
+	__raw_writel(reg, S5P_CLK_OUT);
+
+	reg = __raw_readl(S5P_OTHERS);
+	reg &= ~(0x3 << 8);
+	reg |= 0x0 << 8;
+	__raw_writel(reg, S5P_OTHERS);
+}
+
+#ifdef CONFIG_VIDEO_TV20
+static void s3c_set_qos(void)
+{
+	/* VP QoS */
+	__raw_writel(0x00400001, S5P_VA_DMC0 + 0xC8);
+	__raw_writel(0x387F0022, S5P_VA_DMC0 + 0xCC);
+	/* MIXER QoS */
+	__raw_writel(0x00400001, S5P_VA_DMC0 + 0xD0);
+	__raw_writel(0x3FFF0062, S5P_VA_DMC0 + 0xD4);
+	/* LCD1 QoS */
+	__raw_writel(0x00800001, S5P_VA_DMC1 + 0x90);
+	__raw_writel(0x3FFF005B, S5P_VA_DMC1 + 0x94);
+	/* LCD2 QoS */
+	__raw_writel(0x00800001, S5P_VA_DMC1 + 0x98);
+	__raw_writel(0x3FFF015B, S5P_VA_DMC1 + 0x9C);
+	/* VP QoS */
+	__raw_writel(0x00400001, S5P_VA_DMC1 + 0xC8);
+	__raw_writel(0x387F002B, S5P_VA_DMC1 + 0xCC);
+	/* DRAM Controller QoS */
+	__raw_writel(((__raw_readl(S5P_VA_DMC0)&~(0xFFF<<16))|(0x100<<16)),
+			S5P_VA_DMC0 + 0x0);
+	__raw_writel(((__raw_readl(S5P_VA_DMC1)&~(0xFFF<<16))|(0x100<<16)),
+			S5P_VA_DMC1 + 0x0);
+	/* BUS QoS AXI_DSYS Control */
+	__raw_writel(0x00000007, S5P_VA_BUS_AXI_DSYS + 0x400);
+	__raw_writel(0x00000007, S5P_VA_BUS_AXI_DSYS + 0x420);
+	__raw_writel(0x00000030, S5P_VA_BUS_AXI_DSYS + 0x404);
+	__raw_writel(0x00000030, S5P_VA_BUS_AXI_DSYS + 0x424);
+}
+#endif
+
+static bool console_flushed;
+
+static void flush_console(void)
+{
+	if (console_flushed)
+		return;
+
+	console_flushed = true;
+
+	printk("\n");
+	pr_emerg("Restarting %s\n", linux_banner);
+	if (!try_acquire_console_sem()) {
+		release_console_sem();
+		return;
+	}
+
+	mdelay(50);
+
+	local_irq_disable();
+	if (try_acquire_console_sem())
+		pr_emerg("flush_console: console was locked! busting!\n");
+	else
+		pr_emerg("flush_console: console was locked!\n");
+	release_console_sem();
+}
+
+static void smdkc110_pm_restart(char mode, const char *cmd)
+{
+	flush_console();
+	arm_machine_restart(mode, cmd);
 }
 
 static void __init smdkc110_machine_init(void)
 {
+	arm_pm_restart = smdkc110_pm_restart;
+
+	s3c_usb_set_serial();
 	platform_add_devices(smdkc110_devices, ARRAY_SIZE(smdkc110_devices));
+#ifdef CONFIG_ANDROID_PMEM
+	platform_device_register(&pmem_gpu1_device);
+#endif
+	pm_power_off = smdkc110_power_off ;
+
+#ifdef CONFIG_ANDROID_PMEM
+	android_pmem_set_platdata();
+#endif
+	/* i2c */
+	s3c_i2c0_set_platdata(NULL);
+	s3c_i2c1_set_platdata(NULL);
+	s3c_i2c2_set_platdata(NULL);
+
+	sound_init();
+
+	i2c_register_board_info(0, i2c_devs0, ARRAY_SIZE(i2c_devs0));
+	i2c_register_board_info(1, i2c_devs1, ARRAY_SIZE(i2c_devs1));
+	i2c_register_board_info(2, i2c_devs2, ARRAY_SIZE(i2c_devs2));
+
+#ifdef CONFIG_DM9000
+	smdkc110_dm9000_set();
+#endif
+
+#ifdef CONFIG_FB_S3C_LTE480WV
+	s3cfb_set_platdata(&lte480wv_fb_data);
+#endif
+
+	/* spi */
+#ifdef CONFIG_S3C64XX_DEV_SPI
+	if (!gpio_request(S5PV210_GPB(1), "SPI_CS0")) {
+		gpio_direction_output(S5PV210_GPB(1), 1);
+		s3c_gpio_cfgpin(S5PV210_GPB(1), S3C_GPIO_SFN(1));
+		s3c_gpio_setpull(S5PV210_GPB(1), S3C_GPIO_PULL_UP);
+		s5pv210_spi_set_info(0, S5PV210_SPI_SRCCLK_PCLK,
+			ARRAY_SIZE(smdk_spi0_csi));
+	}
+	if (!gpio_request(S5PV210_GPB(5), "SPI_CS1")) {
+		gpio_direction_output(S5PV210_GPB(5), 1);
+		s3c_gpio_cfgpin(S5PV210_GPB(5), S3C_GPIO_SFN(1));
+		s3c_gpio_setpull(S5PV210_GPB(5), S3C_GPIO_PULL_UP);
+		s5pv210_spi_set_info(1, S5PV210_SPI_SRCCLK_PCLK,
+			ARRAY_SIZE(smdk_spi1_csi));
+	}
+	spi_register_board_info(s3c_spi_devs, ARRAY_SIZE(s3c_spi_devs));
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_S3C)
+	s3c_ts_set_platdata(&s3c_ts_platform);
+#endif
+
+#if defined(CONFIG_S5P_ADC)
+	s3c_adc_set_platdata(&s3c_adc_platform);
+#endif
+
+#if defined(CONFIG_PM)
+	s3c_pm_init();
+#endif
+
+#ifdef CONFIG_VIDEO_FIMC
+	/* fimc */
+	s3c_fimc0_set_platdata(&fimc_plat_lsi);
+	s3c_fimc1_set_platdata(&fimc_plat_lsi);
+	s3c_fimc2_set_platdata(&fimc_plat_lsi);
+	/* external camera */
+	/* smdkv210_cam0_power(1); */
+	/* smdkv210_cam1_power(1); */
+#endif
+
+#ifdef CONFIG_VIDEO_FIMC_MIPI
+	s3c_csis_set_platdata(NULL);
+#endif
+
+#ifdef CONFIG_VIDEO_JPEG_V2
+	s3c_jpeg_set_platdata(&jpeg_plat);
+#endif
+
+#ifdef CONFIG_VIDEO_MFC50
+	/* mfc */
+	s3c_mfc_set_platdata(NULL);
+#endif
+
+#ifdef CONFIG_VIDEO_TV20
+	s3c_set_qos();
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC
+	s5pv210_default_sdhci0();
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC1
+	s5pv210_default_sdhci1();
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC2
+	s5pv210_default_sdhci2();
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC3
+	s5pv210_default_sdhci3();
+#endif
+#ifdef CONFIG_S5PV210_SETUP_SDHCI
+	s3c_sdhci_set_platdata();
+#endif
+
+#ifdef CONFIG_BACKLIGHT_PWM
+	smdk_backlight_register();
+#endif
+
+	regulator_has_full_constraints();
+
+	smdkc110_setup_clocks();
+}
+
+#ifdef CONFIG_USB_SUPPORT
+/* Initializes OTG Phy. */
+void otg_phy_init(void)
+{
+	/* USB PHY0 Enable */
+	writel(readl(S5P_USB_PHY_CONTROL) | (0x1<<0),
+			S5P_USB_PHY_CONTROL);
+	writel((readl(S3C_USBOTG_PHYPWR) & ~(0x3<<3) & ~(0x1<<0)) | (0x1<<5),
+			S3C_USBOTG_PHYPWR);
+	writel((readl(S3C_USBOTG_PHYCLK) & ~(0x5<<2)) | (0x3<<0),
+			S3C_USBOTG_PHYCLK);
+	writel((readl(S3C_USBOTG_RSTCON) & ~(0x3<<1)) | (0x1<<0),
+			S3C_USBOTG_RSTCON);
+	msleep(1);
+	writel(readl(S3C_USBOTG_RSTCON) & ~(0x7<<0),
+			S3C_USBOTG_RSTCON);
+	msleep(1);
+
+	/* rising/falling time */
+	writel(readl(S3C_USBOTG_PHYTUNE) | (0x1<<20),
+			S3C_USBOTG_PHYTUNE);
+
+	/* set DC level as 6 (6%) */
+	writel((readl(S3C_USBOTG_PHYTUNE) & ~(0xf)) | (0x1<<2) | (0x1<<1),
+			S3C_USBOTG_PHYTUNE);
+}
+EXPORT_SYMBOL(otg_phy_init);
+
+/* USB Control request data struct must be located here for DMA transfer */
+struct usb_ctrlrequest usb_ctrl __attribute__((aligned(64)));
+
+/* OTG PHY Power Off */
+void otg_phy_off(void)
+{
+	writel(readl(S3C_USBOTG_PHYPWR) | (0x3<<3),
+			S3C_USBOTG_PHYPWR);
+	writel(readl(S5P_USB_PHY_CONTROL) & ~(1<<0),
+			S5P_USB_PHY_CONTROL);
+}
+EXPORT_SYMBOL(otg_phy_off);
+
+void usb_host_phy_init(void)
+{
+	struct clk *otg_clk;
+
+	otg_clk = clk_get(NULL, "otg");
+	clk_enable(otg_clk);
+
+	if (readl(S5P_USB_PHY_CONTROL) & (0x1<<1))
+		return;
+
+	__raw_writel(__raw_readl(S5P_USB_PHY_CONTROL) | (0x1<<1),
+			S5P_USB_PHY_CONTROL);
+	__raw_writel((__raw_readl(S3C_USBOTG_PHYPWR)
+			& ~(0x1<<7) & ~(0x1<<6)) | (0x1<<8) | (0x1<<5),
+			S3C_USBOTG_PHYPWR);
+	__raw_writel((__raw_readl(S3C_USBOTG_PHYCLK) & ~(0x1<<7)) | (0x3<<0),
+			S3C_USBOTG_PHYCLK);
+	__raw_writel((__raw_readl(S3C_USBOTG_RSTCON)) | (0x1<<4) | (0x1<<3),
+			S3C_USBOTG_RSTCON);
+	__raw_writel(__raw_readl(S3C_USBOTG_RSTCON) & ~(0x1<<4) & ~(0x1<<3),
+			S3C_USBOTG_RSTCON);
+}
+EXPORT_SYMBOL(usb_host_phy_init);
+
+void usb_host_phy_off(void)
+{
+	__raw_writel(__raw_readl(S3C_USBOTG_PHYPWR) | (0x1<<7)|(0x1<<6),
+			S3C_USBOTG_PHYPWR);
+	__raw_writel(__raw_readl(S5P_USB_PHY_CONTROL) & ~(1<<1),
+			S5P_USB_PHY_CONTROL);
+}
+EXPORT_SYMBOL(usb_host_phy_off);
+#endif
+
+void s3c_setup_uart_cfg_gpio(unsigned char port)
+{
 }
+EXPORT_SYMBOL(s3c_setup_uart_cfg_gpio);
 
+#ifdef CONFIG_MACH_SMDKC110
 MACHINE_START(SMDKC110, "SMDKC110")
+#elif CONFIG_MACH_SMDKV210
+MACHINE_START(SMDKV210, "SMDKV210")
+#endif
 	/* Maintainer: Kukjin Kim <kgene.kim@samsung.com> */
 	.phys_io	= S3C_PA_UART & 0xfff00000,
 	.io_pg_offst	= (((u32)S3C_VA_UART) >> 18) & 0xfffc,
@@ -97,5 +1725,5 @@
 	.init_irq	= s5pv210_init_irq,
 	.map_io		= smdkc110_map_io,
 	.init_machine	= smdkc110_machine_init,
-	.timer		= &s3c24xx_timer,
+	.timer		= &s5p_systimer,
 MACHINE_END
--- linux-2.6.35.7/arch/arm/mach-s5pv210/mach-smdkv210.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/mach-smdkv210.c	2011-08-08 12:52:05.000000000 +0800
@@ -27,6 +27,7 @@
 #include <plat/cpu.h>
 #include <plat/adc.h>
 #include <plat/ts.h>
+#include <plat/pm.h>
 
 /* Following are default values for UCON, ULCON and UFCON UART registers */
 #define S5PV210_UCON_DEFAULT	(S3C2410_UCON_TXILEVEL |	\
@@ -96,6 +97,7 @@
 
 static void __init smdkv210_machine_init(void)
 {
+	s3c_pm_init();
 	s3c24xx_ts_set_platdata(&s3c_ts_platform);
 	platform_add_devices(smdkv210_devices, ARRAY_SIZE(smdkv210_devices));
 }
@@ -108,5 +110,9 @@
 	.init_irq	= s5pv210_init_irq,
 	.map_io		= smdkv210_map_io,
 	.init_machine	= smdkv210_machine_init,
+#ifdef CONFIG_S5P_HIGH_RES_TIMERS
+	.timer		= &s5p_systimer,
+#else
 	.timer		= &s3c24xx_timer,
+#endif
 MACHINE_END
--- linux-2.6.35.7/arch/arm/mach-s5pv210/Makefile.boot	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/Makefile.boot	2011-08-08 12:52:05.000000000 +0800
@@ -1,2 +1,10 @@
-   zreladdr-y	:= 0x20008000
+zreladdr-y	:= 0x20008000
 params_phys-y	:= 0x20000100
+
+# override for Herring
+zreladdr-$(CONFIG_MACH_HERRING)	:= 0x30008000
+params_phys-$(CONFIG_MACH_HERRING)	:= 0x30000100
+
+# override for SMDKC110
+zreladdr-$(CONFIG_MACH_SMDKC110)	:= 0x30008000
+params_phys-$(CONFIG_MACH_SMDKC110)	:= 0x30000100
--- linux-2.6.35.7/arch/arm/mach-s5pv210/Makefile	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/Makefile	2011-08-17 19:52:49.000000000 +0800
@@ -1,7 +1,7 @@
 # arch/arm/mach-s5pv210/Makefile
 #
 # Copyright (c) 2010 Samsung Electronics Co., Ltd.
-# 		http://www.samsung.com/
+#		http://www.samsung.com/
 #
 # Licensed under GPLv2
 
@@ -12,24 +12,49 @@
 
 # Core support for S5PV210 system
 
-obj-$(CONFIG_CPU_S5PV210)	+= cpu.o init.o clock.o dma.o gpiolib.o
-obj-$(CONFIG_CPU_S5PV210)	+= setup-i2c0.o
+obj-$(CONFIG_CPU_S5PV210)	+= cpu.o init.o clock.o dma.o gpiolib.o pmu.o
+obj-$(CONFIG_CPU_S5PV210)	+= setup-i2c0.o setup-i2c1.o setup-i2c2.o
+obj-$(CONFIG_PM)	+= pm.o sleep.o
+
+obj-$(CONFIG_S5PV210_POWER_DOMAIN)	+= power-domain.o
 
 # machine support
 
+obj-$(CONFIG_MACH_MINI210)	+= mini210-lcds.o
+obj-$(CONFIG_MACH_MINI210)	+= mach-mini210.o smdkc110-rtc.o
+
 obj-$(CONFIG_MACH_AQUILA)	+= mach-aquila.o
-obj-$(CONFIG_MACH_SMDKV210)	+= mach-smdkv210.o
+obj-$(CONFIG_MACH_SMDKV210)	+= mach-smdkc110.o
 obj-$(CONFIG_MACH_SMDKC110)	+= mach-smdkc110.o
+obj-$(CONFIG_MACH_SMDKV210)	+= smdkc110-rtc.o
+obj-$(CONFIG_MACH_SMDKC110)	+= smdkc110-rtc.o
 obj-$(CONFIG_MACH_GONI)		+= mach-goni.o
+obj-$(CONFIG_MACH_HERRING)	+= mach-herring.o herring-rfkill.o
+obj-$(CONFIG_MACH_HERRING)	+= herring-vibrator.o
+obj-$(CONFIG_MACH_HERRING)	+= herring-btlpm.o
+obj-$(CONFIG_MACH_HERRING)	+= herring-watchdog.o
+obj-$(CONFIG_MACH_HERRING)	+= herring-panel.o
+
+obj-$(CONFIG_MACH_HERRING)	+= dev-herring-phone.o
+
+obj-$(CONFIG_CPU_FREQ)		+= cpu-freq.o
+obj-$(CONFIG_S5PV210_SETUP_SDHCI)       += setup-sdhci.o
 
 # device support
 
 obj-y				+= dev-audio.o
+obj-y				+= dev-fiqdbg.o
 obj-$(CONFIG_S3C64XX_DEV_SPI)	+= dev-spi.o
 obj-$(CONFIG_S5PC110_DEV_ONENAND) += dev-onenand.o
 
-obj-$(CONFIG_S5PV210_SETUP_FB_24BPP)	+= setup-fb-24bpp.o
-obj-$(CONFIG_S5PV210_SETUP_I2C1) 	+= setup-i2c1.o
-obj-$(CONFIG_S5PV210_SETUP_I2C2) 	+= setup-i2c2.o
-obj-$(CONFIG_S5PV210_SETUP_SDHCI)       += setup-sdhci.o
-obj-$(CONFIG_S5PV210_SETUP_SDHCI_GPIO)	+= setup-sdhci-gpio.o
+
+obj-$(CONFIG_S5P_ADC) += adc.o
+
+obj-$(CONFIG_S5PV210_SETUP_FB)		+= setup-fb.o
+obj-$(CONFIG_S5PV210_SETUP_FIMC0)	+= setup-fimc0.o
+obj-$(CONFIG_S5PV210_SETUP_FIMC1)	+= setup-fimc1.o
+obj-$(CONFIG_S5PV210_SETUP_FIMC2)	+= setup-fimc2.o
+obj-$(CONFIG_S5PV210_SETUP_CSIS)	+= setup-csis.o
+
+
+obj-$(CONFIG_CPU_IDLE)		+= cpuidle.o didle.o
--- linux-2.6.35.7/arch/arm/mach-s5pv210/setup-i2c0.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/setup-i2c0.c	2011-08-08 12:52:05.000000000 +0800
@@ -24,7 +24,7 @@
 void s3c_i2c0_cfg_gpio(struct platform_device *dev)
 {
 	s3c_gpio_cfgpin(S5PV210_GPD1(0), S3C_GPIO_SFN(2));
-	s3c_gpio_setpull(S5PV210_GPD1(0), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S5PV210_GPD1(0), S3C_GPIO_PULL_NONE);
 	s3c_gpio_cfgpin(S5PV210_GPD1(1), S3C_GPIO_SFN(2));
-	s3c_gpio_setpull(S5PV210_GPD1(1), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S5PV210_GPD1(1), S3C_GPIO_PULL_NONE);
 }
--- linux-2.6.35.7/arch/arm/mach-s5pv210/setup-i2c1.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/setup-i2c1.c	2011-08-08 12:52:05.000000000 +0800
@@ -24,7 +24,7 @@
 void s3c_i2c1_cfg_gpio(struct platform_device *dev)
 {
 	s3c_gpio_cfgpin(S5PV210_GPD1(2), S3C_GPIO_SFN(2));
-	s3c_gpio_setpull(S5PV210_GPD1(2), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S5PV210_GPD1(2), S3C_GPIO_PULL_NONE);
 	s3c_gpio_cfgpin(S5PV210_GPD1(3), S3C_GPIO_SFN(2));
-	s3c_gpio_setpull(S5PV210_GPD1(3), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S5PV210_GPD1(3), S3C_GPIO_PULL_NONE);
 }
--- linux-2.6.35.7/arch/arm/mach-s5pv210/setup-i2c2.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/setup-i2c2.c	2011-08-08 12:52:05.000000000 +0800
@@ -24,7 +24,7 @@
 void s3c_i2c2_cfg_gpio(struct platform_device *dev)
 {
 	s3c_gpio_cfgpin(S5PV210_GPD1(4), S3C_GPIO_SFN(2));
-	s3c_gpio_setpull(S5PV210_GPD1(4), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S5PV210_GPD1(4), S3C_GPIO_PULL_NONE);
 	s3c_gpio_cfgpin(S5PV210_GPD1(5), S3C_GPIO_SFN(2));
-	s3c_gpio_setpull(S5PV210_GPD1(5), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S5PV210_GPD1(5), S3C_GPIO_PULL_NONE);
 }
--- linux-2.6.35.7/arch/arm/mach-s5pv210/setup-sdhci.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/arch/arm/mach-s5pv210/setup-sdhci.c	2011-08-17 19:49:59.000000000 +0800
@@ -15,6 +15,7 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/irq.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -22,42 +23,345 @@
 #include <plat/regs-sdhci.h>
 #include <plat/sdhci.h>
 
+#include <plat/gpio-cfg.h>
+#include <mach/regs-gpio.h>
+#include <mach/gpio.h>
+#include <asm/mach-types.h>
+
 /* clock sources for the mmc bus clock, order as for the ctrl2[5..4] */
 
 char *s5pv210_hsmmc_clksrcs[4] = {
 	[0] = "hsmmc",		/* HCLK */
 	[1] = "hsmmc",		/* HCLK */
 	[2] = "sclk_mmc",	/* mmc_bus */
-	/*[4] = reserved */
+	[3] = NULL,		/*reserved */
 };
 
+void s5pv210_setup_sdhci0_cfg_gpio(struct platform_device *dev, int width)
+{
+	struct s3c_sdhci_platdata *pdata = dev->dev.platform_data;
+	unsigned int gpio;
+
+	switch (width) {
+	/* Channel 0 supports 4 and 8-bit bus width */
+	case 8:
+		/* Set all the necessary GPIO function and pull up/down */
+		for (gpio = S5PV210_GPG1(3); gpio <= S5PV210_GPG1(6); gpio++) {
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+			s3c_gpio_set_drvstrength(gpio, S3C_GPIO_DRVSTR_1X);
+		}
+
+	case 0:
+	case 1:
+	case 4:
+		/* Set all the necessary GPIO function and pull up/down */
+		for (gpio = S5PV210_GPG0(0); gpio <= S5PV210_GPG0(6); gpio++) {
+			if (gpio != S5PV210_GPG0(2)) {
+				s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+				s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+			}
+			s3c_gpio_set_drvstrength(gpio, S3C_GPIO_DRVSTR_1X);
+		}
+		break;
+	default:
+		printk(KERN_ERR "Wrong SD/MMC bus width : %d\n", width);
+	}
+
+	if (machine_is_herring()) {
+		s3c_gpio_cfgpin(S5PV210_GPJ2(7), S3C_GPIO_OUTPUT);
+		s3c_gpio_setpull(S5PV210_GPJ2(7), S3C_GPIO_PULL_NONE);
+		gpio_set_value(S5PV210_GPJ2(7), 1);
+	}
+
+	if (pdata->cd_type == S3C_SDHCI_CD_INTERNAL) {
+		s3c_gpio_setpull(S5PV210_GPG0(2), S3C_GPIO_PULL_UP);
+		s3c_gpio_cfgpin(S5PV210_GPG0(2), S3C_GPIO_SFN(2));
+	}
+}
+
+void s5pv210_setup_sdhci1_cfg_gpio(struct platform_device *dev, int width)
+{
+	struct s3c_sdhci_platdata *pdata = dev->dev.platform_data;
+	unsigned int gpio;
+
+	switch (width) {
+	/* Channel 1 supports 4-bit bus width */
+	case 0:
+	case 1:
+	case 4:
+		/* Set all the necessary GPIO function and pull up/down */
+		for (gpio = S5PV210_GPG1(0); gpio <= S5PV210_GPG1(6); gpio++) {
+			if (gpio != S5PV210_GPG1(2)) {
+				s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+				s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+			}
+			s3c_gpio_set_drvstrength(gpio, S3C_GPIO_DRVSTR_1X);
+		}
+		break;
+	default:
+		printk(KERN_ERR "Wrong SD/MMC bus width : %d\n", width);
+	}
+
+	if (pdata->cd_type == S3C_SDHCI_CD_INTERNAL) {
+		s3c_gpio_setpull(S5PV210_GPG1(2), S3C_GPIO_PULL_UP);
+		s3c_gpio_cfgpin(S5PV210_GPG1(2), S3C_GPIO_SFN(2));
+	}
+}
+
+void s5pv210_setup_sdhci2_cfg_gpio(struct platform_device *dev, int width)
+{
+	struct s3c_sdhci_platdata *pdata = dev->dev.platform_data;
+	unsigned int gpio;
+
+	switch (width) {
+	/* Channel 2 supports 4 and 8-bit bus width */
+	case 8:
+		/* Set all the necessary GPIO function and pull up/down */
+		for (gpio = S5PV210_GPG3(3); gpio <= S5PV210_GPG3(6); gpio++) {
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+			s3c_gpio_set_drvstrength(gpio, S3C_GPIO_DRVSTR_1X);
+		}
+
+	case 0:
+	case 1:
+	case 4:
+		/* Set all the necessary GPIO function and pull up/down */
+		for (gpio = S5PV210_GPG2(0); gpio <= S5PV210_GPG2(6); gpio++) {
+			if (gpio != S5PV210_GPG2(2)) {
+				s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+				s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+			}
+			s3c_gpio_set_drvstrength(gpio, S3C_GPIO_DRVSTR_1X);
+		}
+		break;
+	default:
+		printk(KERN_ERR "Wrong SD/MMC bus width : %d\n", width);
+	}
+
+	if (pdata->cd_type == S3C_SDHCI_CD_INTERNAL) {
+		s3c_gpio_setpull(S5PV210_GPG2(2), S3C_GPIO_PULL_UP);
+		s3c_gpio_cfgpin(S5PV210_GPG2(2), S3C_GPIO_SFN(2));
+	}
+}
+
+void s5pv210_setup_sdhci3_cfg_gpio(struct platform_device *dev, int width)
+{
+	struct s3c_sdhci_platdata *pdata = dev->dev.platform_data;
+	unsigned int gpio;
+
+	switch (width) {
+	/* Channel 3 supports 4-bit bus width */
+	case 0:
+	case 1:
+	case 4:
+		/* Set all the necessary GPIO function and pull up/down */
+		for (gpio = S5PV210_GPG3(0); gpio <= S5PV210_GPG3(6); gpio++) {
+			if (gpio != S5PV210_GPG3(2)) {
+				s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+				s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
+			}
+			s3c_gpio_set_drvstrength(gpio, S3C_GPIO_DRVSTR_1X);
+		}
+		break;
+	default:
+		printk(KERN_ERR "Wrong SD/MMC bus width : %d\n", width);
+	}
+
+	if (pdata->cd_type == S3C_SDHCI_CD_INTERNAL) {
+		s3c_gpio_setpull(S5PV210_GPG3(2), S3C_GPIO_PULL_UP);
+		s3c_gpio_cfgpin(S5PV210_GPG3(2), S3C_GPIO_SFN(2));
+	}
+}
+
+#define S3C_SDHCI_CTRL3_FCSELTX_INVERT  (0)
+#define S3C_SDHCI_CTRL3_FCSELTX_BASIC \
+	(S3C_SDHCI_CTRL3_FCSEL3 | S3C_SDHCI_CTRL3_FCSEL2)
+#define S3C_SDHCI_CTRL3_FCSELRX_INVERT  (0)
+#define S3C_SDHCI_CTRL3_FCSELRX_BASIC \
+	(S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0)
+
 void s5pv210_setup_sdhci_cfg_card(struct platform_device *dev,
 				    void __iomem *r,
 				    struct mmc_ios *ios,
 				    struct mmc_card *card)
 {
-	u32 ctrl2, ctrl3;
-
-	/* don't need to alter anything acording to card-type */
-
-	writel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA, r + S3C64XX_SDHCI_CONTROL4);
+	u32 ctrl2;
+	u32 ctrl3;
 
 	ctrl2 = readl(r + S3C_SDHCI_CONTROL2);
 	ctrl2 &= S3C_SDHCI_CTRL2_SELBASECLK_MASK;
 	ctrl2 |= (S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR |
 		  S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |
-		  S3C_SDHCI_CTRL2_ENFBCLKRX |
 		  S3C_SDHCI_CTRL2_DFCNT_NONE |
 		  S3C_SDHCI_CTRL2_ENCLKOUTHOLD);
 
-	if (ios->clock < 25 * 1000000)
-		ctrl3 = (S3C_SDHCI_CTRL3_FCSEL3 |
-			 S3C_SDHCI_CTRL3_FCSEL2 |
-			 S3C_SDHCI_CTRL3_FCSEL1 |
-			 S3C_SDHCI_CTRL3_FCSEL0);
-	else
-		ctrl3 = (S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0);
+	if (ios->clock <= (400 * 1000)) {
+		ctrl2 &= ~(S3C_SDHCI_CTRL2_ENFBCLKTX |
+			   S3C_SDHCI_CTRL2_ENFBCLKRX);
+		ctrl3 = 0;
+	} else {
+		u32 range_start;
+		u32 range_end;
+
+		ctrl2 |= S3C_SDHCI_CTRL2_ENFBCLKTX |
+			 S3C_SDHCI_CTRL2_ENFBCLKRX;
+
+		if (card->type == MMC_TYPE_MMC)  /* MMC */
+			range_start = 20 * 1000 * 1000;
+		else    /* SD, SDIO */
+			range_start = 25 * 1000 * 1000;
+
+		range_end = 37 * 1000 * 1000;
+
+		if ((ios->clock > range_start) && (ios->clock < range_end))
+			ctrl3 = S3C_SDHCI_CTRL3_FCSELTX_BASIC |
+				S3C_SDHCI_CTRL3_FCSELRX_BASIC;
+		else
+			ctrl3 = S3C_SDHCI_CTRL3_FCSELTX_BASIC |
+				S3C_SDHCI_CTRL3_FCSELRX_INVERT;
+	}
+
+	writel(ctrl2, r + S3C_SDHCI_CONTROL2);
+	writel(ctrl3, r + S3C_SDHCI_CONTROL3);
+}
+
+void s5pv210_adjust_sdhci_cfg_card(struct s3c_sdhci_platdata *pdata,
+				   void __iomem *r, int rw)
+{
+	u32 ctrl2, ctrl3;
+
+	ctrl2 = readl(r + S3C_SDHCI_CONTROL2);
+	ctrl3 = readl(r + S3C_SDHCI_CONTROL3);
+
+	if (rw == 0) {
+		pdata->rx_cfg++;
+		if (pdata->rx_cfg == 1) {
+			ctrl2 |= S3C_SDHCI_CTRL2_ENFBCLKRX;
+			ctrl3 |= S3C_SDHCI_CTRL3_FCSELRX_BASIC;
+		} else if (pdata->rx_cfg == 2) {
+			ctrl2 |= S3C_SDHCI_CTRL2_ENFBCLKRX;
+			ctrl3 &= ~S3C_SDHCI_CTRL3_FCSELRX_BASIC;
+		} else if (pdata->rx_cfg == 3) {
+			ctrl2 &= ~(S3C_SDHCI_CTRL2_ENFBCLKTX |
+				   S3C_SDHCI_CTRL2_ENFBCLKRX);
+			pdata->rx_cfg = 0;
+		}
+	} else if (rw == 1) {
+		pdata->tx_cfg++;
+		if (pdata->tx_cfg == 1) {
+			if (ctrl2 & S3C_SDHCI_CTRL2_ENFBCLKRX) {
+				ctrl2 |= S3C_SDHCI_CTRL2_ENFBCLKTX;
+				ctrl3 |= S3C_SDHCI_CTRL3_FCSELTX_BASIC;
+			} else {
+				ctrl2 &= ~S3C_SDHCI_CTRL2_ENFBCLKTX;
+			}
+		} else if (pdata->tx_cfg == 2) {
+			ctrl2 &= ~S3C_SDHCI_CTRL2_ENFBCLKTX;
+			pdata->tx_cfg = 0;
+		}
+	} else {
+		printk(KERN_ERR "%s, unknown value rw:%d\n", __func__, rw);
+		return;
+	}
 
 	writel(ctrl2, r + S3C_SDHCI_CONTROL2);
 	writel(ctrl3, r + S3C_SDHCI_CONTROL3);
 }
+
+#if defined(CONFIG_MACH_SMDKV210)
+#define S5PV210_GPH0DAT (S5PV210_GPH0_BASE + 0x04)
+static void setup_sdhci0_gpio_wp(void)
+{
+	s3c_gpio_cfgpin(S5PV210_GPH0(7), S3C_GPIO_INPUT);
+	s3c_gpio_setpull(S5PV210_GPH0(7), S3C_GPIO_PULL_DOWN);
+}
+
+static int sdhci0_get_ro(struct mmc_host *mmc)
+{
+	return !!(readl(S5PV210_GPH0DAT) & 0x80);
+}
+#endif
+
+unsigned int universal_sdhci2_detect_ext_cd(void)
+{
+	unsigned int card_status = 0;
+
+#ifdef CONFIG_MMC_DEBUG
+	printk(KERN_DEBUG "Universal :SD Detect function\n");
+	printk(KERN_DEBUG "eint conf %x  eint filter conf %x",
+		readl(S5P_EINT_CON(3)), readl(S5P_EINT_FLTCON(3, 1)));
+	printk(KERN_DEBUG "eint pend %x  eint mask %x",
+		readl(S5P_EINT_PEND(3)), readl(S5P_EINT_MASK(3)));
+#endif
+	card_status = gpio_get_value(S5PV210_GPH3(4));
+	printk(KERN_DEBUG "Universal : Card status %d\n", card_status ? 0 : 1);
+	return card_status ? 0 : 1;
+
+}
+
+void universal_sdhci2_cfg_ext_cd(void)
+{
+	printk(KERN_DEBUG "Universal :SD Detect configuration\n");
+	s3c_gpio_setpull(S5PV210_GPH3(4), S3C_GPIO_PULL_NONE);
+	set_irq_type(IRQ_EINT(28), IRQ_TYPE_EDGE_BOTH);
+}
+
+static struct s3c_sdhci_platdata hsmmc0_platdata = {
+#if defined(CONFIG_S5PV210_SD_CH0_8BIT)
+	.max_width	= 8,
+	.host_caps	= MMC_CAP_8_BIT_DATA,
+#endif
+	.cd_type	= S3C_SDHCI_CD_INTERNAL,
+#if defined(CONFIG_MACH_SMDKV210)
+	.cfg_wp		= setup_sdhci0_gpio_wp,
+	.get_ro		= sdhci0_get_ro,
+#endif
+};
+
+#if defined(CONFIG_S3C_DEV_HSMMC1)
+static struct s3c_sdhci_platdata hsmmc1_platdata = {
+	.cd_type	= S3C_SDHCI_CD_INTERNAL,
+};
+#endif
+
+#if defined(CONFIG_S3C_DEV_HSMMC2)
+static struct s3c_sdhci_platdata hsmmc2_platdata = {
+#if defined(CONFIG_S5PV210_SD_CH2_8BIT)
+	.max_width	= 8,
+	.host_caps	= MMC_CAP_8_BIT_DATA,
+#endif
+	.cd_type	= S3C_SDHCI_CD_PERMANENT,
+};
+#endif
+
+#if defined(CONFIG_S3C_DEV_HSMMC3)
+static struct s3c_sdhci_platdata hsmmc3_platdata = {
+	.cd_type	= S3C_SDHCI_CD_PERMANENT,
+};
+#endif
+
+void s3c_sdhci_set_platdata(void)
+{
+#if defined(CONFIG_S3C_DEV_HSMMC)
+	s3c_sdhci0_set_platdata(&hsmmc0_platdata);
+#endif
+#if defined(CONFIG_S3C_DEV_HSMMC1)
+	s3c_sdhci0_set_platdata(&hsmmc1_platdata);
+#endif
+#if defined(CONFIG_S3C_DEV_HSMMC2)
+	if (machine_is_herring()) {
+		hsmmc2_platdata.ext_cd = IRQ_EINT(28);
+		hsmmc2_platdata.cfg_ext_cd = universal_sdhci2_cfg_ext_cd;
+		hsmmc2_platdata.detect_ext_cd = universal_sdhci2_detect_ext_cd;
+	}
+
+	s3c_sdhci2_set_platdata(&hsmmc2_platdata);
+#endif
+#if defined(CONFIG_S3C_DEV_HSMMC3)
+	if (machine_is_herring())
+		hsmmc3_platdata.built_in = 1;
+	s3c_sdhci3_set_platdata(&hsmmc3_platdata);
+#endif
+};
