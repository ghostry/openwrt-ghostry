From 052d395ea78d08f13554de4c920130b423db38bc Mon Sep 17 00:00:00 2001
From: Tekkaman Ninja <tekkaman@MAGI-Linux.(none)>
Date: Sun, 18 Apr 2010 21:11:00 +0800
Subject: [PATCH 1/3] first commit for Friendly-ARM mini2440

---
 Makefile                                     |   10 +-
 board/tekkamanninja/mini2440/Makefile        |   51 ++
 board/tekkamanninja/mini2440/config.mk       |   23 +
 board/tekkamanninja/mini2440/flash.c         |  491 +++++++++++++++++++
 board/tekkamanninja/mini2440/lowlevel_init.S |  173 +++++++
 board/tekkamanninja/mini2440/mini2440.c      |  296 ++++++++++++
 board/tekkamanninja/mini2440/nand_read.c     |  234 +++++++++
 common/Makefile                              |    3 +
 common/cmd_load.c                            |   85 ++++
 common/cmd_mem.c                             |   43 ++
 common/cmd_mmc.c                             |    2 +-
 common/cmd_nand.c                            |   24 +
 common/cmd_usbslave.c                        |   84 ++++
 common/serial.c                              |    4 +-
 cpu/arm920t/config.mk                        |    3 +-
 cpu/arm920t/s3c24x0/Makefile                 |    2 +-
 cpu/arm920t/s3c24x0/interrupts.c             |   10 +
 cpu/arm920t/s3c24x0/mmc.c                    |  593 +++++++++++++++++++++++
 cpu/arm920t/s3c24x0/speed.c                  |   24 +-
 cpu/arm920t/s3c24x0/timer.c                  |    1 +
 cpu/arm920t/start.S                          |  266 ++++++++++-
 cpu/arm920t/u-boot.lds                       |    2 +
 drivers/i2c/s3c24x0_i2c.c                    |   10 +-
 drivers/mtd/nand/nand_base.c                 |   43 ++-
 drivers/mtd/nand/nand_util.c                 |   49 ++-
 drivers/mtd/nand/s3c2410_nand.c              |   62 +++-
 drivers/net/dm9000x.c                        |    9 +-
 drivers/usb/slave/2440usb.h                  |  117 +++++
 drivers/usb/slave/Makefile                   |   45 ++
 drivers/usb/slave/common_usb.h               |   37 ++
 drivers/usb/slave/def.h                      |   74 +++
 drivers/usb/slave/interrupt.c                |  137 ++++++
 drivers/usb/slave/usb.h                      |  167 +++++++
 drivers/usb/slave/usbin.c                    |  110 +++++
 drivers/usb/slave/usbin.h                    |   13 +
 drivers/usb/slave/usbinit.c                  |  320 ++++++++++++
 drivers/usb/slave/usbinit.h                  |   20 +
 drivers/usb/slave/usblib.c                   |  237 +++++++++
 drivers/usb/slave/usblib.h                   |   29 ++
 drivers/usb/slave/usbmain.c                  |  158 ++++++
 drivers/usb/slave/usbmain.h                  |   17 +
 drivers/usb/slave/usbout.c                   |  240 +++++++++
 drivers/usb/slave/usbout.h                   |   17 +
 drivers/usb/slave/usbsetup.c                 |  669 ++++++++++++++++++++++++++
 drivers/usb/slave/usbsetup.h                 |   55 +++
 drivers/video/Makefile                       |    1 +
 drivers/video/cfb_console.c                  |    7 +-
 drivers/video/s3c2410_fb.c                   |  168 +++++++
 drivers/video/videomodes.c                   |    2 +
 drivers/video/videomodes.h                   |   10 +-
 include/asm-arm/arch-s3c24x0/mmc.h           |  113 +++++
 include/asm-arm/arch-s3c24x0/regs-sdi.h      |  110 +++++
 include/asm-arm/arch-s3c24x0/s3c24x0.h       |   72 +++-
 include/asm-arm/arch-s3c24x0/s3c24x0_cpu.h   |    2 +
 include/configs/mini2440.h                   |  378 +++++++++++++++
 include/linux/mtd/mtd.h                      |    6 +
 include/mmc.h                                |   10 +-
 include/part.h                               |    1 +
 include/serial.h                             |    2 +-
 lib_arm/board.c                              |   34 ++-
 net/nfs.c                                    |    2 +-
 61 files changed, 5915 insertions(+), 62 deletions(-)
 create mode 100644 board/tekkamanninja/mini2440/Makefile
 create mode 100644 board/tekkamanninja/mini2440/config.mk
 create mode 100644 board/tekkamanninja/mini2440/flash.c
 create mode 100644 board/tekkamanninja/mini2440/lowlevel_init.S
 create mode 100644 board/tekkamanninja/mini2440/mini2440.c
 create mode 100644 board/tekkamanninja/mini2440/nand_read.c
 create mode 100644 common/cmd_usbslave.c
 create mode 100644 cpu/arm920t/s3c24x0/mmc.c
 create mode 100644 drivers/usb/slave/2440usb.h
 create mode 100644 drivers/usb/slave/Makefile
 create mode 100644 drivers/usb/slave/common_usb.h
 create mode 100644 drivers/usb/slave/def.h
 create mode 100644 drivers/usb/slave/interrupt.c
 create mode 100644 drivers/usb/slave/usb.h
 create mode 100644 drivers/usb/slave/usbin.c
 create mode 100644 drivers/usb/slave/usbin.h
 create mode 100644 drivers/usb/slave/usbinit.c
 create mode 100644 drivers/usb/slave/usbinit.h
 create mode 100644 drivers/usb/slave/usblib.c
 create mode 100644 drivers/usb/slave/usblib.h
 create mode 100644 drivers/usb/slave/usbmain.c
 create mode 100644 drivers/usb/slave/usbmain.h
 create mode 100644 drivers/usb/slave/usbout.c
 create mode 100644 drivers/usb/slave/usbout.h
 create mode 100644 drivers/usb/slave/usbsetup.c
 create mode 100644 drivers/usb/slave/usbsetup.h
 create mode 100644 drivers/video/s3c2410_fb.c
 create mode 100644 include/asm-arm/arch-s3c24x0/mmc.h
 create mode 100644 include/asm-arm/arch-s3c24x0/regs-sdi.h
 create mode 100644 include/configs/mini2440.h

diff --git a/Makefile b/Makefile
index e141cb2..5b58d34 100644
--- a/Makefile
+++ b/Makefile
@@ -157,7 +157,7 @@ sinclude $(obj)include/autoconf.mk
 # load ARCH, BOARD, and CPU configuration
 include $(obj)include/config.mk
 export	ARCH CPU BOARD VENDOR SOC
-
+CROSS_COMPILE =  arm-tekkaman-linux-gnueabi-
 # set default to nothing for native builds
 ifeq ($(HOSTARCH),$(ARCH))
 CROSS_COMPILE ?=
@@ -240,6 +240,11 @@ LIBS += drivers/twserial/libtws.a
 LIBS += drivers/usb/gadget/libusb_gadget.a
 LIBS += drivers/usb/host/libusb_host.a
 LIBS += drivers/usb/musb/libusb_musb.a
+ 
+# Apollo +
+LIBS += drivers/usb/slave/libusb_slave.a
+# Apollo -
+
 LIBS += drivers/usb/phy/libusb_phy.a
 LIBS += drivers/video/libvideo.a
 LIBS += drivers/watchdog/libwatchdog.a
@@ -3044,6 +3049,9 @@ smdk2400_config	:	unconfig
 
 smdk2410_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 samsung s3c24x0
+ 
+mini2440_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t mini2440 tekkamanninja s3c24x0
 
 spear300_config \
 spear310_config \
diff --git a/board/tekkamanninja/mini2440/Makefile b/board/tekkamanninja/mini2440/Makefile
new file mode 100644
index 0000000..56a3bc5
--- /dev/null
+++ b/board/tekkamanninja/mini2440/Makefile
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= nand_read.o mini2440.o  flash.o 
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/tekkamanninja/mini2440/config.mk b/board/tekkamanninja/mini2440/config.mk
new file mode 100644
index 0000000..dc59d08
--- /dev/null
+++ b/board/tekkamanninja/mini2440/config.mk
@@ -0,0 +1,23 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+
+TEXT_BASE = 0x33F80000
diff --git a/board/tekkamanninja/mini2440/flash.c b/board/tekkamanninja/mini2440/flash.c
new file mode 100644
index 0000000..dd97294
--- /dev/null
+++ b/board/tekkamanninja/mini2440/flash.c
@@ -0,0 +1,491 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+//#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_ERASE_CONFIRM	0x00000050
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#ifdef  CONFIG_SST_VF1601
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x000005555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x000002AAA << 1)))
+#else
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x000002AA << 1)))
+#endif
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#elif defined(CONFIG_SST_VF1601)
+			(SST_MANUFACT & FLASH_VENDMASK) |
+			(SST_ID_xF1601 & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CONFIG_SYS_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+#ifndef CONFIG_SST_VF1601
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -1) *0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+#else
+				flash_info[i].start[j] =
+					flashbase + (j) * MAIN_SECT_SIZE;
+#endif
+
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_SYS_FLASH_BASE,
+		       CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("1x SST39VF1601 (2MB)\n");
+		break;
+
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+//	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+//	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+#ifdef CONFIG_SST_VF1601
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+#else 
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+#endif    
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+#if 0
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CONFIG_SYS_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+#endif
+                        /* wait until flash is ready */
+                     while(1){
+                            unsigned short i;
+                            i = *((volatile unsigned short *)addr) & 0x40;
+                            if(i != (*((volatile unsigned short *)addr) & 0x40))
+                                   continue;
+                            if((*((volatile unsigned short *)addr)) & 0x80)
+                                   break;
+                     }
+                     printf ("ok.\n");
+
+              } else {   /* it was protected */
+                     printf ("protected!\n");
+              }
+       }
+
+
+
+
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+//      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+//	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+//	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+//	*addr = CMD_PROGRAM;
+	MEM_FLASH_ADDR1 = CMD_PROGRAM;
+
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+#if 0
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+#endif
+
+           /* wait until flash is ready */
+       while(1){
+              unsigned short i = *(volatile unsigned short *)addr & 0x40;
+              if(i != (*(volatile unsigned short *)addr & 0x40))   //D6 == D6
+                     continue;
+              if((*(volatile unsigned short *)addr & 0x80) == (data & 0x80)){
+                     rc = ERR_OK;
+                     break;     //D7 == D7
+              }
+       }
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff --git a/board/tekkamanninja/mini2440/lowlevel_init.S b/board/tekkamanninja/mini2440/lowlevel_init.S
new file mode 100644
index 0000000..f44049e
--- /dev/null
+++ b/board/tekkamanninja/mini2440/lowlevel_init.S
@@ -0,0 +1,173 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * Modified for the friendly-arm SBC-2410X by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/*
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW16)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+#define B0_Tacs			0x0
+#define B0_Tcos			0x0
+#define B0_Tacc			0x7
+#define B0_Tcoh			0x0
+#define B0_Tah			0x0
+#define B0_Tacp			0x0
+#define B0_PMC			0x0
+
+#define B1_Tacs			0x0
+#define B1_Tcos			0x0
+#define B1_Tacc			0x7
+#define B1_Tcoh			0x0
+#define B1_Tah			0x0
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0xc
+#define B3_Tcos			0x7
+#define B3_Tacc			0xf
+#define B3_Tcoh			0x1
+#define B3_Tah			0x0
+#define B3_Tacp			0x0
+#define B3_PMC			0x0
+
+#define B4_Tacs			0x0
+#define B4_Tcos			0x0
+#define B4_Tacc			0x7
+#define B4_Tcoh			0x0
+#define B4_Tah			0x0
+#define B4_Tacp			0x0
+#define B4_PMC			0x0
+
+#define B5_Tacs			0xc
+#define B5_Tcos			0x7
+#define B5_Tacc			0xf
+#define B5_Tcoh			0x1
+#define B5_Tah			0x0
+#define B5_Tacp			0x0
+#define B5_PMC			0x0
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+
+#if defined(CONFIG_S3C2440)
+#define Trp			0x2	/* 4clk */
+#define REFCNT			1012
+#else
+#define Trp			0x0	/* 2clk */
+#define REFCNT			0x0459
+#endif
+
+
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, =lowlevel_init
+	sub	r0, r0, r1
+	adr	r3, lowlevel_init		/* r3 <- current position of code   */
+	add     r0, r0, r3
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb2
+    .word 0x30
+    .word 0x30
diff --git a/board/tekkamanninja/mini2440/mini2440.c b/board/tekkamanninja/mini2440/mini2440.c
new file mode 100644
index 0000000..22bb118
--- /dev/null
+++ b/board/tekkamanninja/mini2440/mini2440.c
@@ -0,0 +1,296 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <video_fb.h>
+
+#if defined(CONFIG_CMD_NAND)
+#include <linux/mtd/nand.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+
+#if defined(CONFIG_S3C2410)
+/* Fout = 202.8MHz */
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#endif
+
+#if defined(CONFIG_S3C2440)
+/* Fout = 405MHz */
+#define M_MDIV 0x7f	
+#define M_PDIV 0x2
+#define M_SDIV 0x1
+#endif
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+
+#if defined(CONFIG_S3C2410)
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#endif
+
+#if defined(CONFIG_S3C2440)
+#define U_M_MDIV 0x38
+#define U_M_PDIV 0x2
+#endif
+
+#define U_M_SDIV	0x2
+#endif
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+			  "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	struct s3c24x0_clock_power * const clk_power =
+					s3c24x0_get_base_clock_power();
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+	gpio->GPACON = 0x007FFFFF;
+
+#if defined(CONFIG_MINI2440) 
+	gpio->GPBCON = 0x00295551;
+#else
+	gpio->GPBCON = 0x00044556;
+#endif
+
+	gpio->GPBUP = 0x000007FF;
+
+#if defined(CONFIG_MINI2440) 
+	gpio->GPCCON = 0xAAAAA6AA;
+	gpio->GPCDAT &= ~(1<<5);
+#else
+	gpio->GPCCON = 0xAAAAAAAA;
+#endif
+	gpio->GPCUP = 0xFFFFFFFF;
+	gpio->GPDCON = 0xAAAAAAAA;
+	gpio->GPDUP = 0xFFFFFFFF;
+
+    gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+	gpio->GPFCON = 0x000055AA;
+	gpio->GPFUP = 0x000000FF;
+	gpio->GPGCON = 0xFF95FF3A;
+	gpio->GPGUP = 0x0000FFFF;
+	gpio->GPHCON = 0x0016FAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	gpio->EXTINT0=0x22222222;
+	gpio->EXTINT1=0x22222222;
+	gpio->EXTINT2=0x22222222;
+
+#if defined(CONFIG_S3C2410)
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+#endif
+
+#if defined(CONFIG_S3C2440)
+/* arch number of S3C2440-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_MINI2440 ;
+#endif
+
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+#if	defined(CONFIG_MINI2440_LED)
+	gpio->GPBDAT = 0x00000181;
+#endif
+	return 0;
+}
+
+
+
+#define MVAL		(0)
+#define MVAL_USED 	(0)		//0=each frame   1=rate by MVAL
+#define INVVDEN		(1)		//0=normal       1=inverted
+#define BSWP		(0)		//Byte swap control
+#define HWSWP		(1)		//Half word swap control
+
+
+//TFT 240320
+#define LCD_XSIZE_TFT_240320 	(240)	
+#define LCD_YSIZE_TFT_240320 	(320)
+
+//TFT240320
+#define HOZVAL_TFT_240320	(LCD_XSIZE_TFT_240320-1)
+#define LINEVAL_TFT_240320	(LCD_YSIZE_TFT_240320-1)
+
+//Timing parameter for NEC3.5"
+#define VBPD_240320		(3)		
+#define VFPD_240320		(10)
+#define VSPW_240320		(1)
+
+#define HBPD_240320		(5)
+#define HFPD_240320		(2)
+#define HSPW_240320_NEC		(36)  //Adjust the horizontal displacement of the screen :tekkamanninja@163.com
+#define HSPW_240320_TD		(23)  //64MB nand mini2440 is 36 ,128MB is 23
+				      //+ ： -->    - : <--
+#define CLKVAL_TFT_240320	(3) 	
+//FCLK=101.25MHz,HCLK=50.625MHz,VCLK=6.33MHz
+
+
+void board_video_init(GraphicDevice *pGD) 
+{ 
+	struct s3c24x0_lcd * const lcd	 = s3c24x0_get_base_lcd(); 
+	struct s3c2410_nand * const nand = s3c2410_get_base_nand();
+    /* FIXME: select LCM type by env variable */ 
+	 
+	/* Configuration for GTA01 LCM on QT2410 */ 
+	lcd->LCDCON1 = 0x00000378; /* CLKVAL=4, BPPMODE=16bpp, TFT, ENVID=0 */ 
+	lcd->LCDCON2 = (VBPD_240320<<24)|(LINEVAL_TFT_240320<<14)|(VFPD_240320<<6)|(VSPW_240320); 
+	lcd->LCDCON3 = (HBPD_240320<<19)|(HOZVAL_TFT_240320<<8)|(HFPD_240320); 
+
+	if ( (nand->NFCONF) & 0x08 )	{ 
+	lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320_TD);
+	}
+	else	{
+	  lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320_NEC);
+	}
+	
+	lcd->LCDCON5 = 0x00000f09; 
+	lcd->LPCSEL  = 0x00000000; 
+} 
+
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+#if 0
+#if defined(CONFIG_CMD_NAND)
+extern ulong nand_probe(ulong physadr);
+
+static inline void NF_Reset(void)
+{
+	int i;
+
+	NF_SetCE(NFCE_LOW);
+	NF_Cmd(0xFF);		/* reset command */
+	for(i = 0; i < 10; i++);	/* tWB = 100ns. */
+	NF_WaitRB();		/* wait 200~500us; */
+	NF_SetCE(NFCE_HIGH);
+}
+
+static inline void NF_Init(void)
+{
+#if 1
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+#else
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+#endif
+
+	NF_Conf((1<<15)|(0<<14)|(0<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0));
+	/*nand->NFCONF = (1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0); */
+	/* 1  1    1     1,   1      xxx,  r xxx,   r xxx */
+	/* En 512B 4step ECCR nFCE=H tACLS   tWRPH0   tWRPH1 */
+
+	NF_Reset();
+}
+
+void nand_init(void)
+{
+	struct s3c2410_nand * const nand = s3c2410_get_base_nand();
+
+	NF_Init();
+#ifdef DEBUG
+	printf("NAND flash probing at 0x%.8lX\n", (ulong)nand);
+#endif
+	printf ("%4lu MB\n", nand_probe((ulong)nand) >> 20);
+}
+#endif
+#endif
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_CS8900
+	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
+#endif
+#ifdef CONFIG_DRIVER_DM9000
+	rc = dm9000_initialize(bis);
+#endif
+	return rc;
+}
+#endif
diff --git a/board/tekkamanninja/mini2440/nand_read.c b/board/tekkamanninja/mini2440/nand_read.c
new file mode 100644
index 0000000..fe8e825
--- /dev/null
+++ b/board/tekkamanninja/mini2440/nand_read.c
@@ -0,0 +1,234 @@
+/*
+ * nand_read.c: Simple NAND read functions for booting from NAND
+ *
+ * This is used by cpu/arm920/start.S assembler code,
+ * and the board-specific linker script must make sure this
+ * file is linked within the first 4kB of NAND flash.
+ *
+ * Taken from GPLv2 licensed vivi bootloader,
+ * Copyright (C) 2002 MIZI Research, Inc.
+ *
+ * Author: Hwang, Chideok <hwang@mizi.com>
+ * Date  : $Date: 2004/02/04 10:37:37 $
+ *
+ * u-boot integration and bad-block skipping (C) 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ */
+
+#include <common.h>
+#include <linux/mtd/nand.h>
+
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGw(x)	(*(volatile unsigned short *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+#define NF_BASE		0x4e000000
+#if defined(CONFIG_S3C2410)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCMD		__REGb(NF_BASE + 0x4)
+#define NFADDR		__REGb(NF_BASE + 0x8)
+#define NFDATA		__REGb(NF_BASE + 0xc)
+#define NFSTAT		__REGb(NF_BASE + 0x10)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONF &= ~0x800)
+#define nand_deselect()	(NFCONF |= 0x800)
+#define nand_clear_RnB()	do {} while (0)
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCONT		__REGi(NF_BASE + 0x4)
+#define NFCMD		__REGb(NF_BASE + 0x8)
+#define NFADDR		__REGb(NF_BASE + 0xc)
+#define NFDATA		__REGb(NF_BASE + 0x10)
+#define NFDATA16	__REGw(NF_BASE + 0x10)
+#define NFSTAT		__REGb(NF_BASE + 0x20)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONT &= ~(1 << 1))
+#define nand_deselect()	(NFCONT |= (1 << 1))
+#define nand_clear_RnB()	(NFSTAT |= (1 << 2))
+#endif
+
+static inline void nand_wait(void)
+{
+	int i;
+
+	while (!(NFSTAT & NFSTAT_BUSY))
+		for (i=0; i<10; i++);
+}
+
+struct boot_nand_t {
+	int page_size;
+	int block_size;
+	int bad_block_offset;
+//	unsigned long size;
+};
+
+#if 0
+#if defined(CONFIG_S3C2410) || defined(CONFIG_MINI2440)
+/* configuration for 2410 with 512byte sized flash */
+#define NAND_PAGE_SIZE		512
+#define BAD_BLOCK_OFFSET	5
+#define NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		0x4000
+#else
+/* configuration for 2440 with 2048byte sized flash */
+#define NAND_5_ADDR_CYCLE
+#define NAND_PAGE_SIZE		2048
+#define BAD_BLOCK_OFFSET	NAND_PAGE_SIZE
+#define	NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		(NAND_PAGE_SIZE * 64)
+#endif
+
+/* compile time failure in case of an invalid configuration */
+#if defined(CONFIG_S3C2410) && (NAND_PAGE_SIZE != 512)
+#error "S3C2410 does not support nand page size != 512"
+#endif
+#endif
+
+static int is_bad_block(struct boot_nand_t * nand, unsigned long i)
+{
+	unsigned char data;
+	unsigned long page_num;
+
+	nand_clear_RnB();
+	if (nand->page_size == 512) {
+		NFCMD = NAND_CMD_READOOB; /* 0x50 */
+		NFADDR = nand->bad_block_offset & 0xf;
+		NFADDR = (i >> 9) & 0xff;
+		NFADDR = (i >> 17) & 0xff;
+		NFADDR = (i >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = i >> 11; /* addr / 2048 */
+		NFCMD = NAND_CMD_READ0;
+		NFADDR = nand->bad_block_offset & 0xff;
+		NFADDR = (nand->bad_block_offset >> 8) & 0xff;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+	data = (NFDATA & 0xff);
+	if (data != 0xff)
+		return 1;
+
+	return 0;
+}
+
+static int nand_read_page_ll(struct boot_nand_t * nand, unsigned char *buf, unsigned long addr)
+{
+	unsigned short *ptr16 = (unsigned short *)buf;
+	unsigned int i, page_num;
+
+	nand_clear_RnB();
+
+	NFCMD = NAND_CMD_READ0;
+
+	if (nand->page_size == 512) {
+		/* Write Address */
+		NFADDR = addr & 0xff;
+		NFADDR = (addr >> 9) & 0xff;
+		NFADDR = (addr >> 17) & 0xff;
+		NFADDR = (addr >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = addr >> 11; /* addr / 2048 */
+		/* Write Address */
+		NFADDR = 0;
+		NFADDR = 0;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+
+#if defined(CONFIG_S3C2410)
+	for (i = 0; i < nand->page_size; i++) {
+		*buf = (NFDATA & 0xff);
+		buf++;
+	}
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	for (i = 0; i < (nand->page_size>>1); i++) {
+		*ptr16 = NFDATA16;
+		ptr16++;
+	}
+#endif
+
+	return nand->page_size;
+}
+
+static unsigned short nand_read_id()
+{
+	unsigned short res = 0;
+	NFCMD = NAND_CMD_READID;
+	NFADDR = 0;
+	res = NFDATA;
+	res = (res << 8) | NFDATA;
+	return res;
+}
+
+extern unsigned int dynpart_size[];
+
+/* low level nand read function */
+int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+	int i, j;
+	unsigned short nand_id;
+	struct boot_nand_t nand;
+
+	/* chip Enable */
+	nand_select();
+	nand_clear_RnB();
+	
+	for (i = 0; i < 10; i++)
+		;
+	nand_id = nand_read_id();
+	if (0) { /* dirty little hack to detect if nand id is misread */
+		unsigned short * nid = (unsigned short *)0x31fffff0;
+		*nid = nand_id;
+	}	
+
+       if (nand_id == 0xec76 ||		/* Samsung K91208 */
+           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
+		nand.page_size = 512;
+		nand.block_size = 16 * 1024;
+		nand.bad_block_offset = 5;
+	//	nand.size = 0x4000000;
+	} else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
+		   nand_id == 0xecda ||	/* Samsung K9F2G08U0B */
+		   nand_id == 0xecd3 )	{ /* Samsung K9K8G08 */
+		nand.page_size = 2048;
+		nand.block_size = 128 * 1024;
+		nand.bad_block_offset = nand.page_size;
+	//	nand.size = 0x8000000;
+	} else {
+		return -1; // hang
+	}
+	if ((start_addr & (nand.block_size-1)) || (size & ((nand.block_size-1))))
+		return -1;	/* invalid alignment */
+
+	for (i=start_addr; i < (start_addr + size);) {
+#ifdef CONFIG_S3C2410_NAND_SKIP_BAD
+		if (i & (nand.block_size-1)== 0) {
+			if (is_bad_block(&nand, i) ||
+			    is_bad_block(&nand, i + nand.page_size)) {
+				/* Bad block */
+				i += nand.block_size;
+				size += nand.block_size;
+				continue;
+			}
+		}
+#endif
+		j = nand_read_page_ll(&nand, buf, i);
+		i += j;
+		buf += j;
+	}
+
+	/* chip Disable */
+	nand_deselect();
+
+	return 0;
+}
diff --git a/common/Makefile b/common/Makefile
index dbf7a05..cd983fb 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -166,6 +166,9 @@ COBJS-$(CONFIG_MODEM_SUPPORT) += modem.o
 COBJS-$(CONFIG_UPDATE_TFTP) += update.o
 COBJS-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
 
+# Apollo +
+COBJS-$(CONFIG_USB_DEVICE) += cmd_usbslave.o
+# Apollo -
 
 COBJS	:= $(sort $(COBJS-y))
 SRCS	:= $(AOBJS:.o=.S) $(COBJS:.o=.c)
diff --git a/common/cmd_load.c b/common/cmd_load.c
index d6bbb78..f22dcc2 100644
--- a/common/cmd_load.c
+++ b/common/cmd_load.c
@@ -34,6 +34,9 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_CMD_LOADB)
+#if defined(ENABLE_CMD_LOADB_X)
+static ulong load_serial_xmodem (ulong offset);
+#endif
 static ulong load_serial_ymodem (ulong offset);
 #endif
 
@@ -475,7 +478,19 @@ int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		}
 	}
 
+#if defined(ENABLE_CMD_LOADB_X)
+	if (strcmp(argv[0],"loadx")==0) {
+		printf ("## Ready for binary (xmodem) download "
+			"to 0x%08lX at %d bps...\n",
+			offset,
+			load_baudrate);
+
+		addr = load_serial_xmodem (offset);
+
+	} else if (strcmp(argv[0],"loady")==0) {
+#else
 	if (strcmp(argv[0],"loady")==0) {
+#endif
 		printf ("## Ready for binary (ymodem) download "
 			"to 0x%08lX at %d bps...\n",
 			offset,
@@ -963,6 +978,66 @@ static int getcxmodem(void) {
 		return (getc());
 	return -1;
 }
+
+#if defined(ENABLE_CMD_LOADB_X)
+static ulong load_serial_xmodem (ulong offset)
+{
+	int size;
+	char buf[32];
+	int err;
+	int res;
+	connection_info_t info;
+	char xmodemBuf[1024];
+	ulong store_addr = ~0;
+	ulong addr = 0;
+
+	size = 0;
+	info.mode = xyzModem_xmodem;
+	res = xyzModem_stream_open (&info, &err);
+	if (!res) {
+
+		while ((res =
+			xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
+			store_addr = addr + offset;
+			size += res;
+			addr += res;
+#ifndef CFG_NO_FLASH
+			if (addr2info (store_addr)) {
+				int rc;
+
+				rc = flash_write ((char *) xmodemBuf,
+				store_addr, res);
+				if (rc != 0) {
+				flash_perror (rc);
+				return (~0);
+				}
+			} else
+#endif
+			{
+				memcpy ((char *) (store_addr), xmodemBuf,
+					res);
+			}
+
+		}
+	} else {
+		printf ("%s\n", xyzModem_error (err));
+	}
+
+	xyzModem_stream_close (&err);
+	xyzModem_stream_terminate (false, &getcxmodem);
+
+
+	flush_cache (offset, size);
+
+	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
+	sprintf (buf, "%X", size);
+	setenv ("filesize", buf);
+
+	return offset;
+}
+#endif
+
+
 static ulong load_serial_ymodem (ulong offset)
 {
 	int size;
@@ -1078,6 +1153,16 @@ U_BOOT_CMD(
 	" with offset 'off' and baudrate 'baud'"
 );
 
+#if defined(ENABLE_CMD_LOADB_X)
+U_BOOT_CMD(
+	loadx, 3, 0,    do_load_serial_bin,
+	"load binary file over serial line (xmodem mode)",
+	"[ off ] [ baud ]\n"
+	"    - load binary file over serial line"
+	" with offset 'off' and baudrate 'baud'"
+);
+#endif
+
 U_BOOT_CMD(
 	loady, 3, 0,	do_load_serial_bin,
 	"load binary file over serial line (ymodem mode)",
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index 1839330..dfc8f9c 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -32,6 +32,9 @@
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
+#if defined(CONFIG_CMD_MMC)
+#include <mmc.h>
+#endif
 #include <watchdog.h>
 
 #include <u-boot/md5.h>
@@ -404,6 +407,46 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 #endif
 
+#if defined(CONFIG_CMD_MMC)
+	if (mmc2info(dest)) {
+		int rc;
+
+		puts ("Copy to MMC... ");
+		switch (rc = mmc_write ((uchar *)addr, dest, count*size)) {
+		case 0:
+			putc ('\n');
+			return 1;
+		case -1:
+			puts ("failed\n");
+			return 1;
+		default:
+			printf ("%s[%d] FIXME: rc=%d\n",__FILE__,__LINE__,rc);
+			return 1;
+		}
+		puts ("done\n");
+		return 0;
+	}
+
+	if (mmc2info(addr)) {
+		int rc;
+
+		puts ("Copy from MMC... ");
+		switch (rc = mmc_read (addr, (uchar *)dest, count*size)) {
+		case 0:
+			putc ('\n');
+			return 1;
+		case -1:
+			puts ("failed\n");
+			return 1;
+		default:
+			printf ("%s[%d] FIXME: rc=%d\n",__FILE__,__LINE__,rc);
+			return 1;
+		}
+		puts ("done\n");
+		return 0;
+	}
+#endif
+
 #ifdef CONFIG_HAS_DATAFLASH
 	/* Check if we are copying from RAM or Flash to DataFlash */
 	if (addr_dataflash(dest) && !addr_dataflash(addr)){
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index c67c9cf..667d184 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -50,7 +50,7 @@ int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 			return 1;
 		}
 
-		if (mmc_legacy_init(dev) != 0) {
+		if (mmc_init(dev) != 0) {
 			puts("No MMC card found\n");
 			return 1;
 		}
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 075a8af..c9432f6 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -378,6 +378,25 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			else
 				ret = nand_write_skip_bad(nand, off, &size,
 							  (u_char *)addr);
+#if defined(ENABLE_CMD_NAND_YAFFS)
+		}else if ( s != NULL &&
+			(!strcmp(s, ".yaffs") || !strcmp(s, ".yaffs1"))){
+			    if(read)  {
+				  printf("nand read.yaffs[1] is not provide temporarily!"); 
+			    } else    {
+				nand->rw_oob = 1;
+#if defined(ENABLE_CMD_NAND_YAFFS_SKIPFB)
+				nand->skipfirstblk = 1;
+#else
+				nand->skipfirstblk = 0;
+#endif
+				ret = nand_write_skip_bad(nand,off,&size,(u_char *)addr);
+#if defined(ENABLE_CMD_NAND_YAFFS_SKIPFB)
+				nand->skipfirstblk = 0;
+#endif
+				nand->rw_oob = 0;
+			    }
+#endif
 		} else if (!strcmp(s, ".oob")) {
 			/* out-of-band data */
 			mtd_oob_ops_t ops = {
@@ -485,6 +504,11 @@ U_BOOT_CMD(nand, CONFIG_SYS_MAXARGS, 1, do_nand,
 	"    to/from memory address 'addr', skipping bad blocks.\n"
 	"nand erase [clean] [off size] - erase 'size' bytes from\n"
 	"    offset 'off' (entire device if not specified)\n"
+#if defined(ENABLE_CMD_NAND_YAFFS)
+	"nand read[.yaffs[1]] is not provide temporarily!\n"
+	"nand write[.yaffs[1]]    addr off size - write the `size' byte yaffs image starting\n"
+	"     at offset `off' from memory address `addr' (.yaffs1 for 512+16 NAND)\n"
+#endif
 	"nand bad - show bad blocks\n"
 	"nand dump[.oob] off - dump page\n"
 	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
diff --git a/common/cmd_usbslave.c b/common/cmd_usbslave.c
new file mode 100644
index 0000000..a743a97
--- /dev/null
+++ b/common/cmd_usbslave.c
@@ -0,0 +1,84 @@
+#include <common.h>
+#include <command.h>
+#include <asm/byteorder.h>
+
+#ifdef CONFIG_USB_DEVICE
+
+#ifdef CONFIG_USE_IRQ
+    #define IRQ_STACK_START    (_armboot_start - CONFIG_SYS_MALLOC_LEN - CONFIG_SYS_GBL_DATA_SIZE - 4)
+    #define FIQ_STACK_START    (IRQ_STACK_START - CONFIG_STACKSIZE_IRQ)
+    #define FREE_RAM_END        (FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE)
+    #define FREE_RAM_SIZE        (FREE_RAM_END - PHYS_SDRAM_1)
+#else
+    #define    FREE_RAM_END    (_armboot_start - CONFIG_SYS_MALLOC_LEN - CONFIG_SYS_GBL_DATA_SIZE - 4 - CONFIG_STACKSIZE)
+    #define    FREE_RAM_SIZE    (FREE_RAM_END - PHYS_SDRAM_1)
+#endif
+
+
+
+int g_bUSBWait = 1;
+u32 g_dwDownloadLen = 0;
+
+extern int download_run;
+extern volatile unsigned int dwUSBBufBase;
+extern volatile unsigned int dwUSBBufSize;
+
+extern __u32 usb_receive(char *buf, size_t len, unsigned int wait);
+
+int do_usbslave (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int i;
+    size_t len = ~0UL;
+    char buf[32];
+
+    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
+     * download_run为0时表示将文件保存在参数argv[2]指定的位置
+     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
+     */
+    download_run = 1;
+    switch (argc) {
+        case 1:
+        {
+            break;
+        }
+        case 2:
+        {
+            g_bUSBWait = (int)simple_strtoul(argv[1], NULL, 16);
+            break;
+        }
+
+        case 3:
+        {
+            g_bUSBWait = (int)simple_strtoul(argv[1], NULL, 16);
+            load_addr = simple_strtoul(argv[2], NULL, 16);
+            download_run = 0;
+            break;
+        }
+        
+        default:
+        {
+            printf ("Usage:\n%s\n", cmdtp->usage);
+            return 1;
+        }
+    }
+
+    dwUSBBufBase = load_addr;
+    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));
+    if (g_bUSBWait)
+        len = FREE_RAM_SIZE;
+
+    g_dwDownloadLen = usb_receive(dwUSBBufBase, len, g_bUSBWait);
+    sprintf(buf, "%X", g_dwDownloadLen);
+    setenv("filesize", buf);
+    
+    return 0;
+}
+
+U_BOOT_CMD(
+    usbslave,    3,    0,    do_usbslave,
+    "usbslave - get file from host(PC)\n",
+    "[wait] [loadAddress]\n"
+    "\"wait\" is 0 or 1, 0 means for return immediately, not waits for the finish of transferring\n"
+);
+
+#endif
diff --git a/common/serial.c b/common/serial.c
index 5f9ffd7..52b3055 100644
--- a/common/serial.c
+++ b/common/serial.c
@@ -59,7 +59,7 @@ struct serial_device *__default_serial_console (void)
 #else
 		return &serial0_device;
 #endif
-#elif defined(CONFIG_S3C2410)
+#elif defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
 #if defined(CONFIG_SERIAL1)
 	return &s3c24xx_serial0_device;
 #elif defined(CONFIG_SERIAL2)
@@ -148,7 +148,7 @@ void serial_initialize (void)
 #if defined (CONFIG_STUART)
 	serial_register(&serial_stuart_device);
 #endif
-#if defined(CONFIG_S3C2410)
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
 	serial_register(&s3c24xx_serial0_device);
 	serial_register(&s3c24xx_serial1_device);
 	serial_register(&s3c24xx_serial2_device);
diff --git a/cpu/arm920t/config.mk b/cpu/arm920t/config.mk
index 8f6c1a3..ee23ffd 100644
--- a/cpu/arm920t/config.mk
+++ b/cpu/arm920t/config.mk
@@ -21,7 +21,8 @@
 # MA 02111-1307 USA
 #
 
-PLATFORM_RELFLAGS += -fno-common -ffixed-r8 -msoft-float
+PLATFORM_RELFLAGS += -fno-common -ffixed-r8 
+#-msoft-float
 
 PLATFORM_CPPFLAGS += -march=armv4
 # =========================================================================
diff --git a/cpu/arm920t/s3c24x0/Makefile b/cpu/arm920t/s3c24x0/Makefile
index 7e8d6ed..78d2396 100644
--- a/cpu/arm920t/s3c24x0/Makefile
+++ b/cpu/arm920t/s3c24x0/Makefile
@@ -30,7 +30,7 @@ COBJS-y	+= speed.o
 COBJS-y	+= timer.o
 COBJS-y	+= usb.o
 COBJS-y	+= usb_ohci.o
-
+COBJS-y	+= mmc.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS-y))
diff --git a/cpu/arm920t/s3c24x0/interrupts.c b/cpu/arm920t/s3c24x0/interrupts.c
index 879fda6..dfd01f3 100644
--- a/cpu/arm920t/s3c24x0/interrupts.c
+++ b/cpu/arm920t/s3c24x0/interrupts.c
@@ -34,9 +34,19 @@
 #include <asm/arch/s3c24x0_cpu.h>
 #include <asm/proc-armv/ptrace.h>
 
+#include <asm/io.h>
+
 void do_irq (struct pt_regs *pt_regs)
 {
 	struct s3c24x0_interrupt *irq = s3c24x0_get_base_interrupt();
 	u_int32_t intpnd = readl(&irq->INTPND);
 
 }
+
+//Apollo +
+
+int arch_interrupt_init (void)
+{
+	return 0;
+}
+//Apollo -
diff --git a/cpu/arm920t/s3c24x0/mmc.c b/cpu/arm920t/s3c24x0/mmc.c
new file mode 100644
index 0000000..cfaa7d9
--- /dev/null
+++ b/cpu/arm920t/s3c24x0/mmc.c
@@ -0,0 +1,593 @@
+/*
+ * u-boot S3C2410 MMC/SD card driver
+ * (C) Copyright 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * based on u-boot pxa MMC driver and linux/drivers/mmc/s3c2410mci.c
+ * (C) 2005-2005 Thomas Kleffel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/arch/mmc.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <part.h>
+#include <fat.h>
+
+#if defined(CONFIG_MMC) && defined(CONFIG_MMC_S3C)
+
+#ifdef DEBUG
+#define pr_debug(fmt, args...) printf(fmt, ##args)
+#else
+#define pr_debug(...) do { } while(0)
+#endif
+
+#define CONFIG_MMC_WIDE
+
+static struct s3c2410_sdi *sdi;
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static mmc_csd_t mmc_csd;
+static int mmc_ready = 0;
+static int wide = 0;
+
+
+#define CMD_F_RESP	0x01
+#define CMD_F_RESP_LONG	0x02
+
+#define CMD_F_RESP_R7 CMD_F_RESP
+
+static u_int32_t *mmc_cmd(ushort cmd, ulong arg, ushort flags)
+{
+	static u_int32_t resp[5];
+
+	u_int32_t ccon, csta;
+	u_int32_t csta_rdy_bit = S3C2410_SDICMDSTAT_CMDSENT;
+
+	memset(resp, 0, sizeof(resp));
+
+	debug("mmc_cmd CMD%d arg=0x%08x flags=%x\n", cmd, arg, flags);
+
+	writel(0xffffffff, &sdi->SDICSTA);
+	writel(0xffffffff, &sdi->SDIDSTA);
+	writel(0xffffffff, &sdi->SDIFSTA);
+	writel(arg, &sdi->SDICARG);
+
+	ccon = cmd & S3C2410_SDICMDCON_INDEX;
+	ccon |= S3C2410_SDICMDCON_SENDERHOST|S3C2410_SDICMDCON_CMDSTART;
+
+	if (flags & CMD_F_RESP) {
+		ccon |= S3C2410_SDICMDCON_WAITRSP;
+		csta_rdy_bit = S3C2410_SDICMDSTAT_RSPFIN; /* 1 << 9 */
+	}
+
+	if (flags & CMD_F_RESP_LONG)
+		ccon |= S3C2410_SDICMDCON_LONGRSP;
+	writel(ccon, &sdi->SDICCON);
+
+	while (1) {
+		csta = readl(&sdi->SDICSTA);
+		if (csta & csta_rdy_bit)
+			break;
+		if (csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {
+			printf("===============> MMC CMD Timeout\n");
+			writel((readl(&sdi->SDICSTA) | S3C2410_SDICMDSTAT_CMDTIMEOUT), &sdi->SDICSTA);
+			break;
+		}
+	}
+
+	debug("final MMC CMD status 0x%x\n", csta);
+	writel((readl(&sdi->SDICSTA) | csta_rdy_bit), &sdi->SDICSTA);
+
+	if (flags & CMD_F_RESP) {
+		resp[0] = readl(&sdi->SDIRSP0);
+		resp[1] = readl(&sdi->SDIRSP1);
+		resp[2] = readl(&sdi->SDIRSP2);
+		resp[3] = readl(&sdi->SDIRSP3);
+	}
+
+	return resp;
+}
+
+#define FIFO_FILL(host) ((host->SDIFSTA & S3C2410_SDIFSTA_COUNTMASK) >> 2)
+
+static int mmc_block_read(uchar *dst, ulong src, ulong len)
+{
+	u_int32_t dcon, fifo;
+	u_int32_t *dst_u32 = (u_int32_t *)dst;
+	u_int32_t *resp;
+
+	if (len == 0)
+		return 0;
+
+	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong)dst, src, len);
+
+	/* set block len */
+	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, len, CMD_F_RESP);
+	writel(len, &sdi->SDIBSIZE);
+
+	//sdi->SDIPRE = 0xff;
+
+	/* setup data */
+	dcon = (len >> 9) & S3C2410_SDIDCON_BLKNUM;
+	dcon |= S3C2410_SDIDCON_BLOCKMODE;
+	dcon |= S3C2410_SDIDCON_RXAFTERCMD|S3C2410_SDIDCON_XFER_RXSTART;
+	if (wide)
+		dcon |= S3C2410_SDIDCON_WIDEBUS;
+#if defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	dcon |= S3C2440_SDIDCON_DS_WORD | S3C2440_SDIDCON_DATSTART;
+#endif
+	writel(dcon, &sdi->SDIDCON);
+
+	/* send read command */
+	resp = mmc_cmd(MMC_CMD_READ_BLOCK, (mmc_dev.if_type == IF_TYPE_SDHC) ? (src >> 9) : src, CMD_F_RESP);
+
+	while (len > 0) {
+		u_int32_t sdidsta = readl(&sdi->SDIDSTA);
+		fifo = FIFO_FILL(sdi);
+		if (sdidsta & (S3C2410_SDIDSTA_FIFOFAIL|
+				S3C2410_SDIDSTA_CRCFAIL|
+				S3C2410_SDIDSTA_RXCRCFAIL|
+				S3C2410_SDIDSTA_DATATIMEOUT)) {
+			printf("mmc_block_read: err SDIDSTA=0x%08x\n", sdidsta);
+			return -EIO;
+		}
+
+		while (fifo--) {
+			//debug("dst_u32 = 0x%08x\n", dst_u32);
+			*(dst_u32++) = readl(&sdi->SDIDAT);
+			if (len >= 4)
+				len -= 4;
+			else {
+				len = 0;
+				break;
+			}
+		}
+	}
+
+	debug("waiting for SDIDSTA  (currently 0x%08x\n", readl(&sdi->SDIDSTA));
+	while (!(readl(&sdi->SDIDSTA) & (1 << 4))) {}
+	debug("done waiting for SDIDSTA (currently 0x%08x\n", readl(&sdi->SDIDSTA));
+
+	writel(0, &sdi->SDIDCON);
+
+	if (!(readl(&sdi->SDIDSTA) & S3C2410_SDIDSTA_XFERFINISH))
+		debug("mmc_block_read; transfer not finished!\n");
+
+	return 0;
+}
+
+static int mmc_block_write(ulong dst, uchar *src, int len)
+{
+	printf("MMC block write not yet supported on S3C2410!\n");
+	return -1;
+}
+
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0)
+		return 0;
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0)
+			return -1;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && src < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0)
+		return 0;
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0)
+			return -1;
+
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0)
+			return -1;
+
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0)
+			return -1;
+
+	}
+	return 0;
+}
+
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, void *dst)
+{
+	int mmc_block_size = MMC_BLOCK_SIZE;
+	ulong src = blknr * mmc_block_size + CFG_MMC_BASE;
+
+	mmc_read(src, dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+/* MMC_DEFAULT_RCA should probably be just 1, but this may break other code
+   that expects it to be shifted. */
+static u_int16_t rca = MMC_DEFAULT_RCA >> 16;
+
+static u_int32_t mmc_size(const struct mmc_csd *csd)
+{
+	u_int32_t block_len, mult, blocknr;
+
+	block_len = csd->read_bl_len << 12;
+	mult = csd->c_size_mult1 << 8;
+	blocknr = (csd->c_size+1) * mult;
+
+	return blocknr * block_len;
+}
+
+struct sd_cid {
+	char		pnm_0;	/* product name */
+	char		oid_1;	/* OEM/application ID */
+	char		oid_0;
+	uint8_t		mid;	/* manufacturer ID */
+	char		pnm_4;
+	char		pnm_3;
+	char		pnm_2;
+	char		pnm_1;
+	uint8_t		psn_2;	/* product serial number */
+	uint8_t		psn_1;
+	uint8_t		psn_0;	/* MSB */
+	uint8_t		prv;	/* product revision */
+	uint8_t		crc;	/* CRC7 checksum, b0 is unused and set to 1 */
+	uint8_t		mdt_1;	/* manufacturing date, LSB, RRRRyyyy yyyymmmm */
+	uint8_t		mdt_0;	/* MSB */
+	uint8_t		psn_3;	/* LSB */
+};
+
+static void print_mmc_cid(mmc_cid_t *cid)
+{
+	printf("MMC found. Card desciption is:\n");
+	printf("Manufacturer ID = %02x%02x%02x\n",
+		cid->id[0], cid->id[1], cid->id[2]);
+	printf("HW/FW Revision = %x %x\n",cid->hwrev, cid->fwrev);
+	cid->hwrev = cid->fwrev = 0;	/* null terminate string */
+	printf("Product Name = %s\n",cid->name);
+	printf("Serial Number = %02x%02x%02x\n",
+		cid->sn[0], cid->sn[1], cid->sn[2]);
+	printf("Month = %d\n",cid->month);
+	printf("Year = %d\n",1997 + cid->year);
+}
+
+static void print_sd_cid(const struct sd_cid *cid)
+{
+	printf("Manufacturer:       0x%02x, OEM \"%c%c\"\n",
+	    cid->mid, cid->oid_0, cid->oid_1);
+	printf("Product name:       \"%c%c%c%c%c\", revision %d.%d\n",
+	    cid->pnm_0, cid->pnm_1, cid->pnm_2, cid->pnm_3, cid->pnm_4,
+	    cid->prv >> 4, cid->prv & 15);
+	printf("Serial number:      %u\n",
+	    cid->psn_0 << 24 | cid->psn_1 << 16 | cid->psn_2 << 8 |
+	    cid->psn_3);
+	printf("Manufacturing date: %d/%d\n",
+	    cid->mdt_1 & 15,
+	    2000+((cid->mdt_0 & 15) << 4)+((cid->mdt_1 & 0xf0) >> 4));
+	printf("CRC:                0x%02x, b0 = %d\n",
+	    cid->crc >> 1, cid->crc & 1);
+}
+
+int mmc_init(int verbose)
+{
+ 	int retries, rc = -ENODEV;
+	int is_sd = 0;
+	u_int32_t *resp;
+	struct s3c24x0_clock_power * const clk_power = s3c24x0_get_base_clock_power();
+	block_dev_desc_t *mmc_blkdev_p = &mmc_dev;
+
+	sdi = s3c2410_get_base_sdi();
+
+	debug("mmc_init(PCLK=%u)\n", get_PCLK());
+
+	clk_power->CLKCON |= (1 << 9);
+	writel(512, &sdi->SDIBSIZE);
+#if defined(CONFIG_S3C2410)
+	/* S3C2410 has some bug that prevents reliable operation at higher speed */
+	//sdi->SDIPRE = 0x3e;  /* SDCLK = PCLK/2 / (SDIPRE+1) = 396kHz */
+	writel(0x02, &sdi->SDIPRE); /* 2410: SDCLK = PCLK/2 / (SDIPRE+1) = 11MHz */
+	writel(0xffff, &sdi->SDIDTIMER);
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	writel(0x05, &sdi->SDIPRE); /* 2410: SDCLK = PCLK / (SDIPRE+1) = 11MHz */
+	writel(0x7fffff, &sdi->SDIDTIMER);
+#endif
+	writel(0x0, &sdi->SDIIMSK);
+	writel((S3C2410_SDICON_FIFORESET | S3C2410_SDICON_CLOCKTYPE), &sdi->SDICON);
+	udelay(125000); /* FIXME: 74 SDCLK cycles */
+
+	mmc_csd.c_size = 0;
+
+	/* reset */
+	retries = 10;
+	resp = mmc_cmd(MMC_CMD_RESET, 0, 0);
+
+	mmc_dev.if_type = IF_TYPE_UNKNOWN;
+	if(verbose)
+		puts("mmc: Probing for SDHC ...\n");
+
+	/* Send supported voltage range */
+	/* SD cards 1.x do not answer to CMD8 */
+        resp = mmc_cmd(MMC_CMD_IF_COND, ((1 << 8) | 0xAA), CMD_F_RESP_R7);
+        if (!resp[0]) {
+             /*
+              * ARC: No answer let's try SD 1.x
+              */
+             if(verbose)
+                     puts("mmc: No answer to CMD8 trying SD\n");
+             mmc_blkdev_p->if_type = IF_TYPE_SD;
+        } else {
+             /*
+              * ARC: probably an SDHC card
+              */
+             mmc_blkdev_p->if_type = IF_TYPE_SDHC;
+             if(verbose)
+                     puts("mmc: SD 2.0 or later card found\n");
+
+             /* Check if the card supports this voltage */
+             if (resp[0] != ((1 << 8) | 0xAA)) {
+                     pr_debug("mmc: Invalid voltage range\n");
+                     return -ENODEV;
+             }
+        }
+
+	/*
+	 * ARC: HC (30) bit set according to response to
+	 * CMD8 command
+	 */
+
+	pr_debug("mmc: Sending ACMD41 %s HC set\n",
+		         ((mmc_blkdev_p->if_type ==
+		           IF_TYPE_SDHC) ? "with" : "without"));
+
+	printf("trying to detect SD Card...\n");
+	while (retries--) {
+		udelay(100000);
+		resp = mmc_cmd(55, 0x00000000, CMD_F_RESP);
+		resp = mmc_cmd(41, (mmc_blkdev_p->if_type == IF_TYPE_SDHC)? (0x00300000 | (1<<30)) : 0x00300000, CMD_F_RESP);
+
+		if (resp[0] & (1 << 31)) {
+			is_sd = 1;
+			break;
+		}
+	}
+
+	/*
+	* ARC: check for HC bit, if its not set
+	* sd card is SD
+	*/
+	if (is_sd && (resp[0] & 0xc0000000) == 0x80000000) {
+	       mmc_dev.if_type = IF_TYPE_SD;
+	}
+
+	if (retries == 0 && !is_sd) {
+		retries = 10;
+		printf("failed to detect SD Card, trying MMC\n");
+		mmc_blkdev_p->if_type = IF_TYPE_MMC;
+		resp = mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ffc000, CMD_F_RESP);
+		while (retries-- && resp && !(resp[4] & 0x80)) {
+			debug("resp %x %x\n", resp[0], resp[1]);
+			udelay(50);
+			resp = mmc_cmd(1, 0x00ffff00, CMD_F_RESP);
+		}
+	}
+
+	/* try to get card id */
+	resp = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, CMD_F_RESP|CMD_F_RESP_LONG);
+	if (resp) {
+		if (!is_sd) {
+			/* TODO configure mmc driver depending on card
+			   attributes */
+			mmc_cid_t *cid = (mmc_cid_t *)resp;
+
+			if (verbose)
+				print_mmc_cid(cid);
+			sprintf((char *) mmc_dev.vendor,
+				"Man %02x%02x%02x Snr %02x%02x%02x",
+				cid->id[0], cid->id[1], cid->id[2],
+				cid->sn[0], cid->sn[1], cid->sn[2]);
+			sprintf((char *) mmc_dev.product,"%s",cid->name);
+			sprintf((char *) mmc_dev.revision,"%x %x",
+				cid->hwrev, cid->fwrev);
+		}
+		else {
+			struct sd_cid *cid = (struct sd_cid *) resp;
+
+			if (verbose)
+				print_sd_cid(cid);
+			sprintf((char *) mmc_dev.vendor, "Man %02x OEM %c%c \"%c%c%c%c%c\"", cid->mid, cid->oid_0, cid->oid_1, cid->pnm_0, cid->pnm_1, cid->pnm_2, cid->pnm_3, cid->pnm_4);
+			sprintf((char *) mmc_dev.product, "%d",
+			    cid->psn_0 << 24 | cid->psn_1 << 16 |
+			    cid->psn_2 << 8 | cid->psn_3);
+			sprintf((char *) mmc_dev.revision, "%d.%d",
+			    cid->prv >> 4, cid->prv & 15);
+		}
+
+		/* fill in device description */
+		if (mmc_dev.if_type == IF_TYPE_UNKNOWN)
+			mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		mmc_dev.removable = 0;
+		mmc_dev.block_read = mmc_bread;
+
+		/* MMC exists, get CSD too */
+		resp = mmc_cmd(MMC_CMD_SET_RCA, MMC_DEFAULT_RCA, CMD_F_RESP);
+		if (is_sd)
+			rca = resp[0] >> 16;
+
+		resp = mmc_cmd(MMC_CMD_SEND_CSD, rca<<16, CMD_F_RESP|CMD_F_RESP_LONG);
+		if (resp) {
+			mmc_csd_t *csd = (mmc_csd_t *)resp;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			rc = 0;
+			mmc_ready = 1;
+			/* FIXME add verbose printout for csd */
+			printf("READ_BL_LEN=%u, C_SIZE_MULT=%u, C_SIZE=%u\n",
+				csd->read_bl_len, csd->c_size_mult1, csd->c_size);
+			printf("size = %u\n", mmc_size(csd));
+		}
+	}
+
+	resp = mmc_cmd(MMC_CMD_SELECT_CARD, rca<<16, CMD_F_RESP);
+
+	if (verbose)
+	       printf("SD Card detected RCA: 0x%x type: %s\n",
+	              rca, ((mmc_dev.if_type == IF_TYPE_SDHC) ? "SDHC" : ((mmc_dev.if_type == IF_TYPE_SD) ? "SD" : "MMC")));
+
+#ifdef CONFIG_MMC_WIDE
+	if (is_sd) {
+		resp = mmc_cmd(55, rca<<16, CMD_F_RESP);
+		resp = mmc_cmd(6, 0x02, CMD_F_RESP);
+		wide = 1;
+	}
+#endif
+
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return rc;
+}
+
+int
+mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int
+mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000)
+		return 1;
+
+	return 0;
+}
+
+#endif	/* defined(CONFIG_MMC) && defined(CONFIG_MMC_S3C) */
diff --git a/cpu/arm920t/s3c24x0/speed.c b/cpu/arm920t/s3c24x0/speed.c
index b13283a..42cda5e 100644
--- a/cpu/arm920t/s3c24x0/speed.c
+++ b/cpu/arm920t/s3c24x0/speed.c
@@ -63,7 +63,13 @@ static ulong get_PLLCLK(int pllreg)
 	m = ((r & 0xFF000) >> 12) + 8;
 	p = ((r & 0x003F0) >> 4) + 2;
 	s = r & 0x3;
-
+//tekkaman
+#if defined(CONFIG_S3C2440)
+	if (pllreg == MPLL)
+	return ((CONFIG_SYS_CLK_FREQ * m * 2) /(p << s));
+	else if (pllreg == UPLL)
+#endif
+//tekkaman
 	return (CONFIG_SYS_CLK_FREQ * m) / (p << s);
 }
 
@@ -78,7 +84,21 @@ ulong get_HCLK(void)
 {
 	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
 
-	return (readl(&clk_power->CLKDIVN) & 2) ? get_FCLK() / 2 : get_FCLK();
+//	return (readl(&clk_power->CLKDIVN) & 2) ? get_FCLK() / 2 : get_FCLK();
+//tekkaman
+#if defined(CONFIG_S3C2440)
+	if (readl(&clk_power->CLKDIVN) & 0x6) 
+				{
+				if ((readl(&clk_power->CLKDIVN) & 0x6)==2) return(get_FCLK()/2);
+				if ((readl(&clk_power->CLKDIVN) & 0x6)==6) return((readl(&clk_power->CAMDIVN) & 0x100) ? get_FCLK()/6 : get_FCLK()/3);
+				if ((readl(&clk_power->CLKDIVN) & 0x6)==4) return((readl(&clk_power->CAMDIVN) & 0x200) ? get_FCLK()/8 : get_FCLK()/4);
+				return(get_FCLK());
+				}
+	else	return(get_FCLK());
+#else
+	return((readl(&clk_power->CLKDIVN) & 0x2) ? get_FCLK()/2 : get_FCLK());
+#endif
+//tekkaman
 }
 
 /* return PCLK frequency */
diff --git a/cpu/arm920t/s3c24x0/timer.c b/cpu/arm920t/s3c24x0/timer.c
index 7d47354..019bf0b 100644
--- a/cpu/arm920t/s3c24x0/timer.c
+++ b/cpu/arm920t/s3c24x0/timer.c
@@ -181,6 +181,7 @@ ulong get_tbclk(void)
 	tbclk = timer_load_val * 100;
 #elif defined(CONFIG_SBC2410X) || \
       defined(CONFIG_SMDK2410) || \
+      defined(CONFIG_MINI2440) || \
       defined(CONFIG_VCMA9)
 	tbclk = CONFIG_SYS_HZ;
 #else
diff --git a/cpu/arm920t/start.S b/cpu/arm920t/start.S
index 779f192..c13463c 100644
--- a/cpu/arm920t/start.S
+++ b/cpu/arm920t/start.S
@@ -114,8 +114,8 @@ start_code:
 	orr	r0, r0, #0xd3
 	msr	cpsr, r0
 
-	bl	coloured_LED_init
-	bl	red_LED_on
+@	bl	coloured_LED_init
+@	bl	red_LED_on
 
 #if	defined(CONFIG_AT91RM9200DK) || defined(CONFIG_AT91RM9200EK)
 	/*
@@ -144,6 +144,12 @@ copyex:
 #  define INTSUBMSK	0x4A00001C
 #  define CLKDIVN	0x4C000014	/* clock divisor register */
 # endif
+#define CLK_CTL_BASE	0x4C000000	/* tekkaman */
+#define MDIV_405	0x7f << 12	/* tekkaman */
+#define PSDIV_405	0x21		/* tekkaman */
+#define MDIV_200	0xa1 << 12	/* tekkaman */
+#define PSDIV_200	0x31		/* tekkaman */
+
 
 	ldr	r0, =pWTCON
 	mov	r1, #0x0
@@ -156,16 +162,52 @@ copyex:
 	ldr	r0, =INTMSK
 	str	r1, [r0]
 # if defined(CONFIG_S3C2410)
-	ldr	r1, =0x3ff
+	ldr	r1, =0x7ff
 	ldr	r0, =INTSUBMSK
 	str	r1, [r0]
 # endif
 
+#if defined(CONFIG_S3C2440)
+	ldr	r1, =0x7fff	
+	ldr	r0, =INTSUBMSK
+	str	r1, [r0]
+#endif
+
+
+#if defined(CONFIG_S3C2440)
+	/* FCLK:HCLK:PCLK = 1:4:8 */
+	ldr	r0, =CLKDIVN
+	mov	r1, #5
+	str	r1, [r0]
+	
+	mrc	p15, 0, r1, c1, c0, 0	
+	orr	r1, r1, #0xc0000000		
+	mcr	p15, 0, r1, c1, c0, 0	
+	
+	
+	mov	r1, #CLK_CTL_BASE	
+	mov	r2, #MDIV_405	
+	add	r2, r2, #PSDIV_405	
+	str	r2, [r1, #0x04]		/* MPLLCON tekkaman */
+
+#else
 	/* FCLK:HCLK:PCLK = 1:2:4 */
 	/* default FCLK is 120 MHz ! */
 	ldr	r0, =CLKDIVN
 	mov	r1, #3
 	str	r1, [r0]
+
+	
+	mrc	p15, 0, r1, c1, c0, 0	
+	orr	r1, r1, #0xc0000000	
+	mcr	p15, 0, r1, c1, c0, 0	/*write ctrl register tekkaman*/
+	
+	
+	mov	r1, #CLK_CTL_BASE	/* tekkaman*/
+	mov	r2, #MDIV_200	
+	add	r2, r2, #PSDIV_200	
+	str	r2, [r1, #0x04]
+#endif
 #endif	/* CONFIG_S3C24X0 */
 
 	/*
@@ -176,13 +218,189 @@ copyex:
 	bl	cpu_init_crit
 #endif
 
-#ifndef CONFIG_SKIP_RELOCATE_UBOOT
-relocate:				/* relocate U-Boot to RAM	    */
+/***************** CHECK_CODE_POSITION ******************************************/
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	cmp	r0, r1			/* don't reloc during debug         */
 	beq	stack_setup
+/***************** CHECK_CODE_POSITION ******************************************/
+
+/***************** CHECK_BOOT_FLASH ******************************************/
+	ldr	r1, =( (4<<28)|(3<<4)|(3<<2) )		/* address of Internal SRAM  0x4000003C*/
+	mov	r0, #0		/* r0 = 0 */
+	str	r0, [r1]
+
+
+	mov	r1, #0x3c		/* address of men  0x0000003C*/
+	ldr	r0, [r1]
+	cmp	r0, #0
+	bne	relocate
+
+	/* recovery  */
+	ldr	r0, =(0xdeadbeef)
+	ldr	r1, =( (4<<28)|(3<<4)|(3<<2) )
+	str	r0, [r1]
+/***************** CHECK_BOOT_FLASH ******************************************/
+
+/***************** NAND_BOOT *************************************************/
+
+#define LENGTH_UBOOT 0x60000
+#define NAND_CTL_BASE 0x4E000000
+
+#ifdef CONFIG_S3C2440
+/* Offset */
+#define oNFCONF 0x00
+#define oNFCONT 0x04
+#define oNFCMD 0x08
+#define oNFSTAT 0x20
+
+	@ reset NAND
+	mov	r1, #NAND_CTL_BASE
+	ldr	r2, =( (7<<12)|(7<<8)|(7<<4)|(0<<0) )
+	str	r2, [r1, #oNFCONF]
+	ldr	r2, [r1, #oNFCONF]
+	
+	ldr	r2, =( (1<<4)|(0<<1)|(1<<0) )	@ Active low CE Control 
+	str	r2, [r1, #oNFCONT]
+	ldr	r2, [r1, #oNFCONT]
+	
+	ldr	r2, =(0x6)	@ RnB Clear
+	str	r2, [r1, #oNFSTAT]
+	ldr	r2, [r1, #oNFSTAT]
+	
+	mov	r2, #0xff	@ RESET command
+	strb	r2, [r1, #oNFCMD]
+	
+	mov	r3, #0	@ wait
+nand1: 
+	add	r3, r3, #0x1
+	cmp	r3, #0xa
+	blt	nand1
+
+nand2:
+	ldr	r2, [r1, #oNFSTAT]	@ wait ready
+	tst	r2, #0x4
+	beq	nand2
+	
+	
+	ldr	r2, [r1, #oNFCONT]
+	orr	r2, r2, #0x2	@ Flash Memory Chip Disable
+	str	r2, [r1, #oNFCONT]
+	
+	@ get read to call C functions (for nand_read())
+	ldr	sp, DW_STACK_START	@ setup stack pointer
+	mov	fp, #0	@ no previous frame, so fp=0
+
+	@ copy U-Boot to RAM
+	ldr	r0, =TEXT_BASE
+	mov	r1, #0x0
+	mov	r2, #LENGTH_UBOOT
+	bl	nand_read_ll
+	tst	r0, #0x0
+	beq	ok_nand_read
+
+bad_nand_read:
+loop2:
+	b	loop2	@ infinite loop
+ok_nand_read:
+	@ verify
+	mov	r0, #0
+	ldr	r1, =TEXT_BASE
+	mov	r2, #0x400	@ 4 bytes * 1024 = 4K-bytes
+go_next:
+	ldr	r3, [r0], #4
+	ldr	r4, [r1], #4
+	teq	r3, r4
+	bne	notmatch
+	subs	r2, r2, #4
+	beq	stack_setup
+	bne	go_next
+
+notmatch:
+loop3:
+	b	loop3	@ infinite loop
+#endif
+
+#ifdef	CONFIG_S3C2410
+
+/* Offset */
+#define oNFCONF 0x00
+#define oNFCMD 0x04
+#define oNFSTAT 0x10
+
+	@ reset NAND
+	mov	r1, #NAND_CTL_BASE
+	ldr	r2, =0xf830	@ initial value
+	str	r2, [r1, #oNFCONF]
+	ldr	r2, [r1, #oNFCONF]
+	bic	r2, r2, #0x800	@ enable chip
+	str	r2, [r1, #oNFCONF]
+	mov	r2, #0xff		@ RESET command
+	strb	r2, [r1, #oNFCMD]
+	
+	
+	mov	r3, #0	@ wait
+nand1:
+	add	r3, r3, #0x1
+	cmp	r3, #0xa
+	blt	nand1
+
+nand2:
+	ldr	r2, [r1, #oNFSTAT]	@ wait ready
+	tst	r2, #0x1
+	beq	nand2
+	
+	ldr	r2, [r1, #oNFCONF]
+	orr	r2, r2, #0x800	@ disable chip
+	str	r2, [r1, #oNFCONF]
+	
+	@ get read to call C functions (for nand_read())
+	ldr	sp, DW_STACK_START	@ setup stack pointer
+	mov	fp, #0	@ no previous frame, so fp=0
+	
+	@ copy U-Boot to RAM
+	ldr	r0, =TEXT_BASE
+	mov	r1, #0x0
+	mov	r2, #LENGTH_UBOOT
+	bl	nand_read_ll
+	tst	r0, #0x0
+	beq	ok_nand_read
+
+bad_nand_read:
+loop2:
+	b	loop2	@ infinite loop
+
+
+ok_nand_read:
+	@ verify
+	mov	r0, #0
+	ldr	r1, =TEXT_BASE
+	mov	r2, #0x400	@ 4 bytes * 1024 = 4K-bytes
+go_next:
+	ldr	r3, [r0], #4
+	ldr	r4, [r1], #4
+	teq	r3, r4
+	bne	notmatch
+	subs	r2, r2, #4
+	beq	stack_setup
+	bne	go_next
 
+notmatch:
+loop3:
+	b	loop3	@ infinite loop
+
+#endif
+/***************** NAND_BOOT *************************************************/
+
+/***************** NOR_BOOT *************************************************/
+relocate:				/* relocate U-Boot to RAM	    */
+      /*********** CHECK_FOR_MAGIC_NUMBER***************/
+	ldr	r1, =(0xdeadbeef)
+	cmp	r0, r1
+	bne	loop3
+      /*********** CHECK_FOR_MAGIC_NUMBER***************/
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	ldr	r2, _armboot_start
 	ldr	r3, _bss_start
 	sub	r2, r3, r2		/* r2 <- size of armboot            */
@@ -193,7 +411,7 @@ copy_loop:
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
-#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
+/***************** NOR_BOOT *************************************************/
 
 	/* Set up the stack						    */
 stack_setup:
@@ -217,8 +435,29 @@ clbss_l:str	r2, [r0]		/* clear loop...                    */
 
 	ldr	pc, _start_armboot
 
-_start_armboot:	.word start_armboot
+#if defined(CONFIG_MINI2440_LED)
+#define GPIO_CTL_BASE 0x56000000
+#define oGPIO_B 0x10
+#define oGPIO_CON 0x0
+/* R/W, Configures the pins of the port */
+#define oGPIO_DAT 0x4
+#define oGPIO_UP 0x8
+/* R/W, Pull-up disable register */
+	mov	r1, #GPIO_CTL_BASE
+	add	r1, r1, #oGPIO_B
+	ldr	r2, =0x295551
+	str	r2, [r1, #oGPIO_CON]
+	mov	r2, #0xff
+	str	r2, [r1, #oGPIO_UP]
+	ldr	r2, =0x1c1
+	str	r2, [r1, #oGPIO_DAT]
+#endif
 
+_start_armboot:	.word start_armboot
+#define STACK_BASE 0x33f00000
+#define STACK_SIZE 0x10000
+	.align	2
+DW_STACK_START:	.word	STACK_BASE+STACK_SIZE-4 
 
 /*
  *************************************************************************
@@ -406,10 +645,23 @@ not_used:
 
 	.align	5
 irq:
+//Apollo +
+/*
 	get_irq_stack
 	irq_save_user_regs
 	bl	do_irq
 	irq_restore_user_regs
+*/
+    /* use IRQ for USB and DMA */
+        sub    lr, lr, #4             @ the return address
+        ldr    sp, IRQ_STACK_START     @ the stack for irq
+       stmdb   sp!,  { r0-r12,lr }     @ save registers
+        
+        ldr    lr, =int_return         @ set the return addr
+        ldr    pc, =IRQ_Handle         @ call the isr
+int_return:
+        ldmia  sp!, { r0-r12,pc }^    @ return from interrupt
+//Apollo -
 
 	.align	5
 fiq:
diff --git a/cpu/arm920t/u-boot.lds b/cpu/arm920t/u-boot.lds
index d9bfbee..05220d4 100644
--- a/cpu/arm920t/u-boot.lds
+++ b/cpu/arm920t/u-boot.lds
@@ -40,6 +40,8 @@ SECTIONS
 	.text :
 	{
 		cpu/arm920t/start.o	(.text)
+		board/tekkamanninja/mini2440/lowlevel_init.o	(.text)
+		board/tekkamanninja/mini2440/nand_read.o	(.text)
 		*(.text)
 	}
 
diff --git a/drivers/i2c/s3c24x0_i2c.c b/drivers/i2c/s3c24x0_i2c.c
index c8371cf..312ccab 100644
--- a/drivers/i2c/s3c24x0_i2c.c
+++ b/drivers/i2c/s3c24x0_i2c.c
@@ -57,7 +57,7 @@ static int GetI2CSDA(void)
 {
 	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
 
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	return (readl(&gpio->GPEDAT) & 0x8000) >> 15;
 #endif
 #ifdef CONFIG_S3C2400
@@ -76,7 +76,7 @@ static void SetI2CSCL(int x)
 {
 	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
 
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	writel((readl(&gpio->GPEDAT) & ~0x4000) | (x & 1) << 14, &gpio->GPEDAT);
 #endif
 #ifdef CONFIG_S3C2400
@@ -128,7 +128,7 @@ void i2c_init(int speed, int slaveadd)
 	}
 
 	if ((readl(&i2c->IICSTAT) & I2CSTAT_BSY) || GetI2CSDA() == 0) {
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 		ulong old_gpecon = readl(&gpio->GPECON);
 #endif
 #ifdef CONFIG_S3C2400
@@ -137,7 +137,7 @@ void i2c_init(int speed, int slaveadd)
 		/* bus still busy probably by (most) previously interrupted
 		   transfer */
 
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 		/* set I2CSDA and I2CSCL (GPE15, GPE14) to GPIO */
 		writel((readl(&gpio->GPECON) & ~0xF0000000) | 0x10000000,
 		       &gpio->GPECON);
@@ -163,7 +163,7 @@ void i2c_init(int speed, int slaveadd)
 		udelay(1000);
 
 		/* restore pin functions */
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 		writel(old_gpecon, &gpio->GPECON);
 #endif
 #ifdef CONFIG_S3C2400
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 7171bdd..d8930a7 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -2097,7 +2097,30 @@ static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
 {
 	struct nand_chip *chip = mtd->priv;
 	int ret;
-
+#if defined(ENABLE_CMD_NAND_YAFFS)
+	/*Thanks for hugerat's code!*/
+	
+	int oldopsmode = 0;
+	if(mtd->rw_oob==1)	{
+		size_t oobsize = mtd->oobsize;  
+		size_t datasize = mtd->writesize;
+		int i = 0;
+		uint8_t oobtemp[oobsize];
+		int datapages = 0;
+		datapages = len/(datasize);
+		for(i=0;i<(datapages);i++)	{
+			memcpy((void *)oobtemp,
+				(void *)(buf+datasize*(i+1)),
+				oobsize);
+			memmove((void *)(buf+datasize*(i+1)),
+				(void *)(buf+datasize*(i+1)+oobsize),
+				(datapages-(i+1))*(datasize)+(datapages-1)*oobsize);
+			memcpy((void *)(buf+(datapages)*(datasize+oobsize)-oobsize),
+				(void *)(oobtemp),
+				oobsize);
+		}
+	}
+#endif
 	/* Do not allow reads past end of device */
 	if ((to + len) > mtd->size)
 		return -EINVAL;
@@ -2108,14 +2131,30 @@ static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
 
 	chip->ops.len = len;
 	chip->ops.datbuf = (uint8_t *)buf;
-	chip->ops.oobbuf = NULL;
 
+#if defined(ENABLE_CMD_NAND_YAFFS)
+	/*Thanks for hugerat's code!*/
+	if(mtd->rw_oob!=1)	{
+	  chip->ops.oobbuf = NULL;
+	} else	{
+	  chip->ops.oobbuf = (uint8_t *)(buf+len); 
+	  chip->ops.ooblen = mtd->oobsize;
+	  oldopsmode = chip->ops.mode;
+	  chip->ops.mode = MTD_OOB_RAW; 
+	}
+#else
+	chip->ops.oobbuf = NULL;
+#endif
 	ret = nand_do_write_ops(mtd, to, &chip->ops);
 
 	*retlen = chip->ops.retlen;
 
 	nand_release_device(mtd);
 
+#if defined(ENABLE_CMD_NAND_YAFFS)
+	/*Thanks for hugerat's code!*/
+	chip->ops.mode = oldopsmode;
+#endif
 	return ret;
 }
 
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index 29c42f7..fa5e7eb 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -476,6 +476,26 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 	size_t left_to_write = *length;
 	size_t len_incl_bad;
 	u_char *p_buffer = buffer;
+#if defined(ENABLE_CMD_NAND_YAFFS)
+	/*Thanks for hugerat's code*/
+	
+	if(nand->rw_oob==1)	{
+		size_t oobsize = nand->oobsize;  
+		size_t datasize = nand->writesize;
+		int datapages = 0;
+
+	   
+		if (((*length)%(nand->oobsize+nand->writesize)) != 0) {
+		    printf ("Attempt to write error length data!\n");
+		    return -EINVAL;
+	    }
+
+		datapages = *length/(datasize+oobsize);
+		*length = datapages*datasize;
+		left_to_write = *length;
+//		nand->skipfirstblock=1;
+	}
+#endif
 
 	/* Reject writes, which are not page aligned */
 	if ((offset & (nand->writesize - 1)) != 0 ||
@@ -490,7 +510,9 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 		printf ("Attempt to write outside the flash area\n");
 		return -EINVAL;
 	}
-
+	
+#if !defined(ENABLE_CMD_NAND_YAFFS)
+/*by hugerat,phase 6 */
 	if (len_incl_bad == *length) {
 		rval = nand_write (nand, offset, length, buffer);
 		if (rval != 0)
@@ -499,7 +521,7 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 
 		return rval;
 	}
-
+#endif
 	while (left_to_write > 0) {
 		size_t block_offset = offset & (nand->erasesize - 1);
 		size_t write_size;
@@ -512,12 +534,21 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 			offset += nand->erasesize - block_offset;
 			continue;
 		}
-
+#if defined(ENABLE_CMD_NAND_YAFFS)
+		/*Thanks for hugerat's code*/
+		if(nand->skipfirstblk==1)	{		
+			nand->skipfirstblk=0;
+			printf ("Skip the first good block %llx\n",
+				offset & ~(nand->erasesize - 1));
+			offset += nand->erasesize - block_offset;
+			continue;
+		}
+#endif
 		if (left_to_write < (nand->erasesize - block_offset))
 			write_size = left_to_write;
 		else
 			write_size = nand->erasesize - block_offset;
-
+		printf("\rWriting at 0x%llx -- ",offset);	/*Thanks for hugerat's code*/
 		rval = nand_write (nand, offset, &write_size, p_buffer);
 		if (rval != 0) {
 			printf ("NAND write to offset %llx failed %d\n",
@@ -527,8 +558,18 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 		}
 
 		left_to_write -= write_size;
+		printf("%d%% is complete.",100-(left_to_write/(*length/100)));/*Thanks for hugerat's code*/
 		offset        += write_size;
+#if defined(ENABLE_CMD_NAND_YAFFS)
+		/*Thanks for hugerat's code*/
+		if(nand->rw_oob==1)	{
+			p_buffer += write_size+(write_size/nand->writesize*nand->oobsize);
+		} else	{
+			p_buffer += write_size;
+		}
+#else
 		p_buffer      += write_size;
+#endif
 	}
 
 	return 0;
diff --git a/drivers/mtd/nand/s3c2410_nand.c b/drivers/mtd/nand/s3c2410_nand.c
index a27d47e..edbefe8 100644
--- a/drivers/mtd/nand/s3c2410_nand.c
+++ b/drivers/mtd/nand/s3c2410_nand.c
@@ -24,6 +24,9 @@
 #include <asm/arch/s3c24x0_cpu.h>
 #include <asm/io.h>
 
+#define	NF_BASE		0x4e000000
+
+#if defined(CONFIG_S3C2410)
 #define S3C2410_NFCONF_EN          (1<<15)
 #define S3C2410_NFCONF_512BYTE     (1<<14)
 #define S3C2410_NFCONF_4STEP       (1<<13)
@@ -35,6 +38,22 @@
 
 #define S3C2410_ADDR_NALE 4
 #define S3C2410_ADDR_NCLE 8
+#endif
+
+#if defined(CONFIG_S3C2440)
+#define S3C2410_NFCONT_EN          (1<<0)
+#define S3C2410_NFCONT_INITECC     (1<<4)
+#define S3C2410_NFCONT_nFCE        (1<<1)
+#define S3C2410_NFCONT_MAINECCLOCK (1<<5)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<12)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<8)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<4)
+
+#define S3C2410_ADDR_NALE 0x08
+#define S3C2410_ADDR_NCLE 0x0c
+#endif
+
+ulong IO_ADDR_W = NF_BASE; 
 
 #ifdef CONFIG_NAND_SPL
 
@@ -53,21 +72,22 @@ static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
 
 static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
 {
-	struct nand_chip *chip = mtd->priv;
+//	struct nand_chip *chip = mtd->priv;
 	struct s3c2410_nand *nand = s3c2410_get_base_nand();
 
 	debugX(1, "hwcontrol(): 0x%02x 0x%02x\n", cmd, ctrl);
 
 	if (ctrl & NAND_CTRL_CHANGE) {
-		ulong IO_ADDR_W = (ulong)nand;
+		IO_ADDR_W = (ulong)nand;
 
 		if (!(ctrl & NAND_CLE))
 			IO_ADDR_W |= S3C2410_ADDR_NCLE;
 		if (!(ctrl & NAND_ALE))
 			IO_ADDR_W |= S3C2410_ADDR_NALE;
 
-		chip->IO_ADDR_W = (void *)IO_ADDR_W;
+//		chip->IO_ADDR_W = (void *)IO_ADDR_W;
 
+#if defined(CONFIG_S3C2410)
 		if (ctrl & NAND_NCE)
 			writel(readl(&nand->NFCONF) & ~S3C2410_NFCONF_nFCE,
 			       &nand->NFCONF);
@@ -75,9 +95,19 @@ static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
 			writel(readl(&nand->NFCONF) | S3C2410_NFCONF_nFCE,
 			       &nand->NFCONF);
 	}
+#endif
+#if defined(CONFIG_S3C2440)
+		if (ctrl & NAND_NCE)
+			writel(readl(&nand->NFCONT) & ~S3C2410_NFCONT_nFCE,
+			       &nand->NFCONT);
+		else
+			writel(readl(&nand->NFCONT) | S3C2410_NFCONT_nFCE,
+			       &nand->NFCONT);
+	}
+#endif
 
 	if (cmd != NAND_CMD_NONE)
-		writeb(cmd, chip->IO_ADDR_W);
+		writeb(cmd, (void *)IO_ADDR_W);
 }
 
 static int s3c2410_dev_ready(struct mtd_info *mtd)
@@ -92,7 +122,13 @@ void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct s3c2410_nand *nand = s3c2410_get_base_nand();
 	debugX(1, "s3c2410_nand_enable_hwecc(%p, %d)\n", mtd, mode);
+#if defined(CONFIG_S3C2410)
 	writel(readl(&nand->NFCONF) | S3C2410_NFCONF_INITECC, &nand->NFCONF);
+#endif
+
+#if defined(CONFIG_S3C2440)
+	writel(readl(&nand->NFCONT) | S3C2410_NFCONT_INITECC, &nand->NFCONT);
+#endif
 }
 
 static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
@@ -132,6 +168,7 @@ int board_nand_init(struct nand_chip *nand)
 
 	writel(readl(&clk_power->CLKCON) | (1 << 4), &clk_power->CLKCON);
 
+#if defined(CONFIG_S3C2410)
 	/* initialize hardware */
 	twrph0 = 3;
 	twrph1 = 0;
@@ -145,6 +182,23 @@ int board_nand_init(struct nand_chip *nand)
 
 	/* initialize nand_chip data structure */
 	nand->IO_ADDR_R = nand->IO_ADDR_W = (void *)&nand_reg->NFDATA;
+#endif
+#if defined(CONFIG_S3C2440)
+	twrph0 = 4;
+	twrph1 = 2;
+	tacls = 0;
+
+	cfg = 0;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+	writel(cfg, &nand_reg->NFCONF);
+
+	cfg = (0<<13)|(0<<12)|(0<<10)|(0<<9)|(0<<8)|(0<<6)|(0<<5)|(1<<4)|(0<<1)|(1<<0);
+	writel(cfg, &nand_reg->NFCONT);
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = nand->IO_ADDR_W = (void *)&nand_reg->NFDATA;
+#endif
 
 	nand->select_chip = NULL;
 
diff --git a/drivers/net/dm9000x.c b/drivers/net/dm9000x.c
index a7fef56..ca80a3a 100644
--- a/drivers/net/dm9000x.c
+++ b/drivers/net/dm9000x.c
@@ -364,12 +364,14 @@ static int dm9000_init(struct eth_device *dev, bd_t *bd)
 	while (!(phy_read(1) & 0x20)) {	/* autonegation complete bit */
 		udelay(1000);
 		i++;
-		if (i == 10000) {
-			printf("could not establish link\n");
-			return 0;
+		if (i == 1000) {
+//			printf("could not establish link\n");
+//			return 0;
+			break;
 		}
 	}
 
+# if 1
 	/* see what we've got */
 	lnk = phy_read(17) >> 12;
 	printf("operating at ");
@@ -391,6 +393,7 @@ static int dm9000_init(struct eth_device *dev, bd_t *bd)
 		break;
 	}
 	printf("mode\n");
+#endif
 	return 0;
 }
 
diff --git a/drivers/usb/slave/2440usb.h b/drivers/usb/slave/2440usb.h
new file mode 100644
index 0000000..24716a5
--- /dev/null
+++ b/drivers/usb/slave/2440usb.h
@@ -0,0 +1,117 @@
+/*********************************************
+  NAME: 2440usb.h
+  DESC: 
+  HISTORY:
+  03.23.2002:purnnamu: first release for 2410
+ *********************************************/
+#ifndef __24XUSB_H__
+#define __24XUSB_H__
+
+//*************************************************************************
+// USB definitons
+//*************************************************************************
+
+/* Power Management Register */
+#define DISABLE_SUSPEND          0x00   
+#define ENABLE_SUSPEND           0x01
+#define SUSPEND_MODE		 0x02
+#define MCU_RESUME               0x04
+#define ISO_UPDATE		 (1<<7)
+
+/* MAXP Register */
+#define FIFO_SIZE_0              0x00  /* 0x00 * 8 = 0  */
+#define FIFO_SIZE_8              0x01  /* 0x01 * 8 = 8  */
+#define FIFO_SIZE_16             0x02  /* 0x02 * 8 = 16 */
+#define FIFO_SIZE_32             0x04  /* 0x04 * 8 = 32 */
+#define FIFO_SIZE_64             0x08  /* 0x08 * 8 = 64 */
+
+/* ENDPOINT0 CSR (Control Status Register) : Mapped to IN CSR1 */
+#define EP0_OUT_PKT_READY        0x01  /* USB sets, MCU clears by setting SERVICED_OUT_PKT_RDY */
+#define EP0_IN_PKT_READY         0x02  /* MCU sets, USB clears after sending FIFO */
+#define EP0_SENT_STALL           0x04  /* USB sets */       
+#define EP0_DATA_END             0x08  /* MCU sets */
+#define EP0_SETUP_END            0x10  /* USB sets, MCU clears by setting SERVICED_SETUP_END */
+#define EP0_SEND_STALL           0x20  /* MCU sets */
+#define EP0_SERVICED_OUT_PKT_RDY 0x40  /* MCU writes 1 to clear OUT_PKT_READY */
+#define EP0_SERVICED_SETUP_END   0x80  /* MCU writes 1 to clear SETUP_END        */
+
+#define EP0_WR_BITS              0xc0  
+
+//EP_INT_REG / EP_INT_EN_REG
+#define EP0_INT                	 0x01  // Endpoint 0, Control   
+#define EP1_INT                  0x02  // Endpoint 1, (Bulk-In) 
+#define EP2_INT                  0x04  // Endpoint 2 
+#define EP3_INT			 0x08  // Endpoint 3, (Bulk-Out)   
+#define EP4_INT			 0x10  // Endpoint 4
+
+//USB_INT_REG / USB_INT_EN_REG
+#define SUSPEND_INT            	 0x01  
+#define RESUME_INT               0x02  
+#define RESET_INT                0x04  
+
+//IN_CSR1
+#define EPI_IN_PKT_READY         0x01  
+#define EPI_UNDER_RUN		 0x04
+#define EPI_FIFO_FLUSH		 0x08
+#define EPI_SEND_STALL           0x10  
+#define EPI_SENT_STALL           0x20  
+#define EPI_CDT			 0x40	
+#define EPI_WR_BITS              (EPI_FIFO_FLUSH|EPI_IN_PKT_READY|EPI_CDT) 
+					//(EPI_FIFO_FLUSH) is preferred  (???)
+//IN_CSR2
+#define EPI_IN_DMA_INT_MASK	(1<<4)
+#define EPI_MODE_IN		(1<<5)
+#define EPI_MODE_OUT		(0<<5)
+#define EPI_ISO			(1<<6)
+#define EPI_BULK		(0<<6)
+#define EPI_AUTO_SET		(1<<7)
+
+//OUT_CSR1
+#define EPO_OUT_PKT_READY        0x01  
+#define EPO_OVER_RUN		 0x04  
+#define EPO_DATA_ERROR		 0x08  
+#define EPO_FIFO_FLUSH		 0x10
+#define EPO_SEND_STALL           0x20  
+#define EPO_SENT_STALL           0x40
+#define EPO_CDT			 0x80	
+#define EPO_WR_BITS              (EPO_FIFO_FLUSH|EPO_SEND_STALL|EPO_CDT)
+					//(EPO_FIFO_FLUSH) is preferred (???)
+
+//OUT_CSR2
+#define EPO_OUT_DMA_INT_MASK	(1<<5)
+#define EPO_ISO		 	(1<<6)
+#define EPO_BULK	 	(0<<6)
+#define EPO_AUTO_CLR		(1<<7)
+
+//USB DMA control register
+#define UDMA_IN_RUN_OB		(1<<7)
+#define UDMA_IGNORE_TTC		(1<<7)
+#define UDMA_DEMAND_MODE	(1<<3)
+#define UDMA_OUT_RUN_OB		(1<<2)
+#define UDMA_OUT_DMA_RUN	(1<<2)
+#define UDMA_IN_DMA_RUN		(1<<1)
+#define UDMA_DMA_MODE_EN	(1<<0)
+
+#define rEP1_DMA_TTC	(rEP1_DMA_TTC_L+(rEP1_DMA_TTC_M<<8)+(rEP1_DMA_TTC_H<<16))
+#define rEP2_DMA_TTC	(rEP2_DMA_TTC_L+(rEP2_DMA_TTC_M<<8)+(rEP2_DMA_TTC_H<<16))
+#define rEP3_DMA_TTC	(rEP3_DMA_TTC_L+(rEP3_DMA_TTC_M<<8)+(rEP3_DMA_TTC_H<<16))
+#define rEP4_DMA_TTC	(rEP4_DMA_TTC_L+(rEP4_DMA_TTC_M<<8)+(rEP4_DMA_TTC_H<<16))
+
+#define ADDR_EP0_FIFO 		(0x520001c0) //Endpoint 0 FIFO
+#define ADDR_EP1_FIFO		(0x520001c4) //Endpoint 1 FIFO
+#define ADDR_EP2_FIFO		(0x520001c8) //Endpoint 2 FIFO
+#define ADDR_EP3_FIFO		(0x520001cc) //Endpoint 3 FIFO
+#define ADDR_EP4_FIFO		(0x520001d0) //Endpoint 4 FIFO
+
+//If you chane the packet size, the source code should be changed!!!
+//USB Device Options
+#define USBDMA		TRUE
+//#define USBDMA		FALSE
+#define USBDMA_DEMAND 	FALSE	//the downloadFileSize should be (64*n)
+#define BULK_PKT_SIZE	32
+
+#define EP0_PKT_SIZE             8	
+#define EP1_PKT_SIZE             BULK_PKT_SIZE
+#define EP3_PKT_SIZE             BULK_PKT_SIZE
+
+#endif //__24XUSB_H__
diff --git a/drivers/usb/slave/Makefile b/drivers/usb/slave/Makefile
new file mode 100644
index 0000000..8297e0d
--- /dev/null
+++ b/drivers/usb/slave/Makefile
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB 	:= $(obj)libusb_slave.a
+
+COBJS 	:= usbin.o  usblib.o  usbmain.o  usbout.o  usbsetup.o usbinit.o interrupt.o
+
+SRCS 	:= $(COBJS:.o=.c)
+OBJS 	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/usb/slave/common_usb.h b/drivers/usb/slave/common_usb.h
new file mode 100644
index 0000000..8d98f17
--- /dev/null
+++ b/drivers/usb/slave/common_usb.h
@@ -0,0 +1,37 @@
+#ifndef __COMMON_MY_H__
+#define __COMMON_MY_H__
+
+#define ISR_EINT0_OFT     0
+#define ISR_EINT1_OFT     1
+#define ISR_EINT2_OFT     2
+#define ISR_EINT3_OFT     3
+#define ISR_EINT4_7_OFT   4
+#define ISR_EINT8_23_OFT  5
+#define ISR_NOTUSED6_OFT  6
+#define ISR_BAT_FLT_OFT   7
+#define ISR_TICK_OFT      8
+#define ISR_WDT_OFT       9
+#define ISR_TIMER0_OFT    10
+#define ISR_TIMER1_OFT    11
+#define ISR_TIMER2_OFT    12
+#define ISR_TIMER3_OFT    13
+#define ISR_TIMER4_OFT    14
+#define ISR_UART2_OFT     15
+#define ISR_LCD_OFT       16
+#define ISR_DMA0_OFT      17
+#define ISR_DMA1_OFT      18
+#define ISR_DMA2_OFT      19
+#define ISR_DMA3_OFT      20
+#define ISR_SDI_OFT       21
+#define ISR_SPI0_OFT      22
+#define ISR_UART1_OFT     23
+#define ISR_NOTUSED24_OFT 24
+#define ISR_USBD_OFT      25
+#define ISR_USBH_OFT      26
+#define ISR_IIC_OFT       27
+#define ISR_UART0_OFT     28
+#define ISR_SPI1_OFT      29
+#define ISR_RTC_OFT       30
+#define ISR_ADC_OFT       31
+
+#endif /* __COMMON_MY_H__ */
diff --git a/drivers/usb/slave/def.h b/drivers/usb/slave/def.h
new file mode 100644
index 0000000..5aabf6a
--- /dev/null
+++ b/drivers/usb/slave/def.h
@@ -0,0 +1,74 @@
+//
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+//
+//
+// Use of this source code is subject to the terms of the Microsoft end-user
+// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
+// If you did not accept the terms of the EULA, you are not authorized to use
+// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
+// install media.
+//
+/*++
+THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
+ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
+PARTICULAR PURPOSE.
+--*/
+#ifndef __DEF_H__
+#define __DEF_H__
+#ifndef U32
+#define U32 unsigned int
+#endif
+
+#ifndef U16
+#define U16 unsigned short
+#endif
+
+#ifndef S32
+#define S32 int
+#endif
+
+#ifndef S16
+#define S16 short int
+#endif
+
+#ifndef U8
+#define U8  unsigned char
+#endif
+
+#ifndef S8
+#define	S8  char
+#endif
+
+typedef unsigned char BOOL;
+typedef unsigned char UCHAR;
+typedef UCHAR *PUCHAR;
+typedef unsigned long DWORD;
+typedef DWORD *PDWORD;
+typedef unsigned long LDWORD;
+typedef DWORD *LPDWORD;
+typedef unsigned char   BYTE;
+typedef unsigned short  WORD;
+
+typedef unsigned long ULONG;
+typedef ULONG *PULONG;
+typedef unsigned short USHORT;
+typedef USHORT *PUSHORT;
+
+typedef BYTE *LPBYTE;
+
+typedef void *PVOID;
+
+typedef  char*          LPSTR;
+
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#define TRUE 	1   
+#define FALSE 	0
+
+#endif /*__DEF_H__*/
+
+
diff --git a/drivers/usb/slave/interrupt.c b/drivers/usb/slave/interrupt.c
new file mode 100644
index 0000000..8dbf380
--- /dev/null
+++ b/drivers/usb/slave/interrupt.c
@@ -0,0 +1,137 @@
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+#include <asm/proc-armv/ptrace.h>
+#include "common_usb.h"
+
+#define BIT_USBD		(0x1<<25)
+#define BIT_DMA2		(0x1<<19)
+#define BIT_WDT_AC97		(0x1<<9)
+#define BIT_TIMER4		(0x1<<14)
+#define BIT_ALLMSK		(0xFFFFFFFF)
+
+/* Start : add by www.100ask.net */
+void (*isr_handle_array[50])(void);
+
+    
+extern void IsrUsbd(void);
+extern void IsrDma2(void);
+
+/************************* Timer ********************************/
+static int intCount;
+
+void IsrWatchdog(void);
+
+void ClearPending_my(int bit) 
+{
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+ 	writel(bit, &intregs->SRCPND);
+	writel(bit, &intregs->INTPND);
+}
+
+void Timer_InitEx(void)
+{
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+	intCount=0;	
+ 	writel((1<<13), &intregs->SUBSRCPND);
+	ClearPending_my(BIT_WDT_AC97/*BIT_WDT*/);
+ 	writel((readl(&intregs->INTMSK) & ~(BIT_WDT_AC97 /*BIT_WDT*/)), &intregs->INTMSK);
+	writel((readl(&intregs->INTSUBMSK) & ~(1<<13)), &intregs->INTSUBMSK);
+}
+
+
+void Timer_StartEx(void)
+{
+	struct s3c24x0_watchdog * const wdtregs = s3c24x0_get_base_watchdog();
+    
+	writel((((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2)), &wdtregs->WTCON);  // 16us
+	writel(0xffff, &wdtregs->WTDAT);
+	writel(0xffff, &wdtregs->WTCNT);
+
+	// 1/16/(65+1),interrupt enable,reset disable,watchdog enable
+	writel((((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2)|(0<<0)|(1<<5)), &wdtregs->WTCON);  
+}
+
+unsigned int Timer_StopEx(void)
+{
+	int count;
+	struct s3c24x0_watchdog * const wdtregs = s3c24x0_get_base_watchdog();
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+
+	writel(((get_PCLK()/1000000-1)<<8), &wdtregs->WTCON);
+	writel((readl(&intregs->INTMSK) | BIT_WDT_AC97), &intregs->INTMSK);
+	writel((readl(&intregs->INTSUBMSK) | (1<<13)), &intregs->INTSUBMSK);	
+
+	count = (0xffff - readl(&wdtregs->WTCNT)) + (intCount*0xffff);
+	return ((unsigned int)count*16/1000000);
+}
+
+
+void  IsrWatchdog(void)
+{
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+	writel((1<<13), &intregs->SUBSRCPND);
+	ClearPending_my(BIT_WDT_AC97 /* BIT_WDT */);
+	intCount++;   	
+}
+
+int g_TimerIntHappen;
+void  IsrTimer4(void)
+{
+	ClearPending_my(BIT_TIMER4);
+	*(volatile int *)&g_TimerIntHappen = 1;
+}
+
+
+void Dummy_isr(void)
+{
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+	printf("Dummy_isr error, interrupt number: %d, INTMSK = 0x%x\n", readl(&intregs->INTOFFSET), readl(&intregs->INTMSK));
+	while(1);
+}
+
+void Isr_Init(void)
+{
+	int i = 0;
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+    
+	for (i = 0; i < sizeof(isr_handle_array) / sizeof(isr_handle_array[0]); i++ )
+	{
+		isr_handle_array[i] = Dummy_isr;
+	}
+	writel(0, &intregs->INTMOD);
+	writel(BIT_ALLMSK, &intregs->INTMSK);
+// All=IRQ mode
+// All interrupt is masked.
+
+	isr_handle_array[ISR_TIMER4_OFT] = IsrTimer4;
+	isr_handle_array[ISR_WDT_OFT]  = IsrWatchdog;
+
+//#ifdef CONFIG_USB_DEVICE
+	isr_handle_array[ISR_USBD_OFT] = IsrUsbd;
+	isr_handle_array[ISR_DMA2_OFT] = IsrDma2;
+	ClearPending_my(BIT_DMA2);
+	ClearPending_my(BIT_USBD);
+//#endif    
+}
+
+
+void IRQ_Handle(void)
+{
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+	struct s3c24x0_interrupt * const intregs = s3c24x0_get_base_interrupt();
+	unsigned long oft = readl(&intregs->INTOFFSET);
+    
+	// clean int
+	if( oft == 4 ) {
+		writel((1<<7), &gpio->EINTPEND);
+	}
+	writel((1<<oft), &intregs->SRCPND);
+	writel(readl(&intregs->INTPND), &intregs->INTPND);
+ 
+
+	/* run the isr */
+	isr_handle_array[oft]();
+}
+
+/* End : add by www.100ask.net */
diff --git a/drivers/usb/slave/usb.h b/drivers/usb/slave/usb.h
new file mode 100644
index 0000000..ee9ee90
--- /dev/null
+++ b/drivers/usb/slave/usb.h
@@ -0,0 +1,167 @@
+/****************************************************************
+ NAME: usb.h
+ DESC: definitions(USB data structure) for USB setup operation.
+       Because It's h/w independent file, it may be used without any change in future.
+       Reuse the source of S3C2400X u24xmon 
+ HISTORY:
+ Apr.07.2000:purnnamu: first release. 
+ ****************************************************************/
+#ifndef __USB_H__
+#define __USB_H__
+
+//************************
+//       Endpoint 0      
+//************************
+
+// Standard bmRequestTyje (Direction) 
+#define HOST_TO_DEVICE              (0x00)
+#define DEVICE_TO_HOST              (0x80)    
+
+// Standard bmRequestType (Type) 
+#define STANDARD_TYPE               (0x00)
+#define CLASS_TYPE                  (0x20)
+#define VENDOR_TYPE                 (0x40)
+#define RESERVED_TYPE               (0x60)
+
+// Standard bmRequestType (Recipient) 
+#define DEVICE_RECIPIENT            (0)
+#define INTERFACE_RECIPIENT         (1)
+#define ENDPOINT_RECIPIENT          (2)
+#define OTHER_RECIPIENT             (3)
+
+// Feature Selectors 
+#define DEVICE_REMOTE_WAKEUP        (1)
+#define EP_STALL                    (0)
+
+// Standard Request Codes 
+#define GET_STATUS                  (0)
+#define CLEAR_FEATURE               (1)
+#define SET_FEATURE                 (3)
+#define SET_ADDRESS                 (5)
+#define GET_DESCRIPTOR              (6)
+#define SET_DESCRIPTOR              (7)
+#define GET_CONFIGURATION           (8)
+#define SET_CONFIGURATION           (9)
+#define GET_INTERFACE               (10)
+#define SET_INTERFACE               (11)
+#define SYNCH_FRAME                 (12)
+
+// Class-specific Request Codes 
+#define GET_DEVICE_ID               (0)
+#define GET_PORT_STATUS             (1)
+#define SOFT_RESET                  (2)
+
+// Descriptor Types
+#define DEVICE_TYPE                 (1)
+#define CONFIGURATION_TYPE          (2)
+#define STRING_TYPE                 (3)
+#define INTERFACE_TYPE              (4)
+#define ENDPOINT_TYPE               (5)
+
+//configuration descriptor: bmAttributes 
+#define CONF_ATTR_DEFAULT	    (0x80) //Spec 1.0 it was BUSPOWERED bit.
+#define CONF_ATTR_REMOTE_WAKEUP     (0x20)
+#define CONF_ATTR_SELFPOWERED       (0x40)
+
+//endpoint descriptor
+#define EP_ADDR_IN		    (0x80)	
+#define EP_ADDR_OUT		    (0x00)
+
+#define EP_ATTR_CONTROL		    (0x0)	
+#define EP_ATTR_ISOCHRONOUS	    (0x1)
+#define EP_ATTR_BULK		    (0x2)
+#define EP_ATTR_INTERRUPT	    (0x3)	
+
+
+//string descriptor
+#define LANGID_EN_L 		    (0x09)  
+#define LANGID_EN_H 		    (0x08)
+
+
+struct USB_SETUP_DATA{
+    U8 bmRequestType;    
+    U8 bRequest;         
+    U8 bValueL;          
+    U8 bValueH;          
+    U8 bIndexL;          
+    U8 bIndexH;          
+    U8 bLengthL;         
+    U8 bLengthH;         
+};
+
+
+struct USB_DEVICE_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 bcdUSBL;
+    U8 bcdUSBH;
+    U8 bDeviceClass;          
+    U8 bDeviceSubClass;          
+    U8 bDeviceProtocol;          
+    U8 bMaxPacketSize0;         
+    U8 idVendorL;
+    U8 idVendorH;
+    U8 idProductL;
+    U8 idProductH;
+    U8 bcdDeviceL;
+    U8 bcdDeviceH;
+    U8 iManufacturer;
+    U8 iProduct;
+    U8 iSerialNumber;
+    U8 bNumConfigurations;
+};
+
+
+struct USB_CONFIGURATION_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 wTotalLengthL;
+    U8 wTotalLengthH;
+    U8 bNumInterfaces;
+    U8 bConfigurationValue;
+    U8 iConfiguration;
+    U8 bmAttributes;
+    U8 maxPower;          
+};
+    
+
+struct USB_INTERFACE_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 bInterfaceNumber;
+    U8 bAlternateSetting;
+    U8 bNumEndpoints;
+    U8 bInterfaceClass;
+    U8 bInterfaceSubClass;
+    U8 bInterfaceProtocol;
+    U8 iInterface;
+};
+
+
+struct USB_ENDPOINT_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 bEndpointAddress;
+    U8 bmAttributes;
+    U8 wMaxPacketSizeL;
+    U8 wMaxPacketSizeH;
+    U8 bInterval;
+};
+
+ struct USB_CONFIGURATION_SET{
+     U8 ConfigurationValue;
+ };
+
+ struct USB_GET_STATUS{
+     U8 Device;
+     U8 Interface;
+     U8 Endpoint0;
+     U8 Endpoint1;
+     U8 Endpoint3;
+ };
+
+ struct USB_INTERFACE_GET{
+     U8 AlternateSetting;
+ }; 
+#endif /*__USB_H__*/
+
diff --git a/drivers/usb/slave/usbin.c b/drivers/usb/slave/usbin.c
new file mode 100644
index 0000000..aef9e13
--- /dev/null
+++ b/drivers/usb/slave/usbin.c
@@ -0,0 +1,110 @@
+/****************************************************************
+ NAME: usbin.c
+ DESC: usb bulk-IN operation
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ ****************************************************************/
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#include "def.h"
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usb.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbin.h"
+
+//static void PrintEpiPkt(U8 *pt,int cnt);
+
+
+// ===================================================================
+// All following commands will operate in case 
+// - in_csr1 is valid.
+// ===================================================================
+
+//#define SET_EP1_IN_PKT_READY()  usbdevregs->EP0_CSR_IN_CSR1_REG= ((in_csr1 & (~EPI_WR_BITS)) | EPI_IN_PKT_READY )
+#define SET_EP1_IN_PKT_READY()  writeb(((in_csr1 & (~EPI_WR_BITS)) | EPI_IN_PKT_READY ), &usbdevregs->EP0_CSR_IN_CSR1_REG);	 
+// #define SET_EP1_SEND_STALL()	usbdevregs->EP0_CSR_IN_CSR1_REG= ((in_csr1 & (~EPI_WR_BITS)) | EPI_SEND_STALL )
+//#define CLR_EP1_SENT_STALL()	usbdevregs->EP0_CSR_IN_CSR1_REG= ((in_csr1 & (~EPI_WR_BITS)) & (~EPI_SENT_STALL) )
+#define CLR_EP1_SENT_STALL()	writeb(((in_csr1 & (~EPI_WR_BITS)) & (~EPI_SENT_STALL) ), &usbdevregs->EP0_CSR_IN_CSR1_REG);
+// #define FLUSH_EP1_FIFO() 	usbdevregs->EP0_CSR_IN_CSR1_REG= ((in_csr1 & (~EPI_WR_BITS)) | EPI_FIFO_FLUSH )
+
+
+// ***************************
+// *** VERY IMPORTANT NOTE ***
+// ***************************
+// Prepare the code for the packit size constraint!!!
+
+// EP1 = IN end point. 
+
+U8 ep1Buf[EP1_PKT_SIZE];
+int transferIndex=0;
+
+void PrepareEp1Fifo(void) 
+{
+	struct s3c24x0_usb_device * const usbdevregs = s3c24x0_get_base_usb_device();
+	int i;
+	U8 in_csr1;
+	
+	writeb(1,&usbdevregs->INDEX_REG);
+//	usbdevregs->INDEX_REG=1;
+	in_csr1 = readb(&usbdevregs->EP0_CSR_IN_CSR1_REG);
+//	in_csr1=usbdevregs->EP0_CSR_IN_CSR1_REG;
+    
+	for(i=0;i<EP1_PKT_SIZE;i++) {
+		ep1Buf[i]=(U8)(transferIndex+i);
+	}
+	
+	WrPktEp1(ep1Buf,EP1_PKT_SIZE);
+	SET_EP1_IN_PKT_READY(); 
+}
+
+
+void Ep1Handler(void)
+{
+	U8 in_csr1;
+	struct s3c24x0_usb_device * const usbdevregs = s3c24x0_get_base_usb_device();
+	writeb(1,&usbdevregs->INDEX_REG);
+//	usbdevregs->INDEX_REG=1;
+	in_csr1 = readb(&usbdevregs->EP0_CSR_IN_CSR1_REG);
+//	in_csr1=usbdevregs->EP0_CSR_IN_CSR1_REG;
+    
+//	DbgPrintf("<1:%x]",in_csr1);
+
+	//I think that EPI_SENT_STALL will not be set to 1.
+	if(in_csr1 & EPI_SENT_STALL)
+	{   
+//		DbgPrintf("[STALL]");
+		CLR_EP1_SENT_STALL();
+   		return;
+	}	
+
+	//IN_PKT_READY is cleared
+	//The data transfered was ep1Buf[] which was already configured 
+
+//	PrintEpiPkt(ep1Buf,EP1_PKT_SIZE); 
+    
+	transferIndex++;
+
+	PrepareEp1Fifo(); 
+    	//IN_PKT_READY is set   
+    	//This packit will be used for next IN packit.	
+
+    return;
+}
+
+
+#if 0    
+void PrintEpiPkt(U8 *pt,int cnt)
+{
+	int i;
+	DbgPrintf("[B_IN:%d:",cnt);
+	for(i=0;i<cnt;i++) {
+		DbgPrintf("%x,",pt[i]);
+	}
+	DbgPrintf("]");
+}
+#endif
diff --git a/drivers/usb/slave/usbin.h b/drivers/usb/slave/usbin.h
new file mode 100644
index 0000000..18f42d5
--- /dev/null
+++ b/drivers/usb/slave/usbin.h
@@ -0,0 +1,13 @@
+/****************************************************************
+ NAME: usbin.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+#ifndef __USBIN_H__
+#define __USBIN_H__
+
+void Ep1Handler(void);
+void PrepareEp1Fifo(void);
+
+#endif /*__USBIN_H__*/
diff --git a/drivers/usb/slave/usbinit.c b/drivers/usb/slave/usbinit.c
new file mode 100644
index 0000000..659f510
--- /dev/null
+++ b/drivers/usb/slave/usbinit.c
@@ -0,0 +1,320 @@
+/****************************************************************
+ NAME: u2440mon.c
+ DESC: u2440mon entry point,menu,download
+ HISTORY:
+ Mar.25.2002:purnnamu: S3C2400X profile.c is ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ Apr.01.2002:purnnamu: isDownloadReady flag is added.
+ Apr.10.2002:purnnamu: - Selecting menu is available in the waiting loop. 
+                         So, isDownloadReady flag gets not needed
+                       - UART ch.1 can be selected for the console.
+ Aug.20.2002:purnnamu: revision number change 0.2 -> R1.1       
+ Sep.03.2002:purnnamu: To remove the power noise in the USB signal, the unused CLKOUT0,1 is disabled.
+ ****************************************************************/
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#include "usbmain.h"
+#include "usbout.h"
+#include "usblib.h"
+#include "2440usb.h"
+
+#define BIT_DMA2		(0x1<<19)
+
+void Isr_Init(void);
+void HaltUndef(void);
+void HaltSwi(void);
+void HaltPabort(void);
+void HaltDabort(void);
+void Lcd_Off(void);
+__u32 usb_receive(char *buf, size_t len, U32 wait);
+void Menu(void);
+
+extern void Timer_InitEx(void);
+extern void Timer_StartEx(void);
+extern unsigned int Timer_StopEx(void);
+
+extern void (*isr_handle_array[])(void);
+
+/*
+ * Reads and returns a character from the serial port
+ *   - Times out after delay iterations checking for presence of character
+ *   - Sets *error_p to UART error bits or - on timeout
+ *   - On timeout, sets *error_p to -1 and returns 0
+ */
+char awaitkey(unsigned long delay, int* error_p)
+{
+    int i;
+//    char c;
+
+    if (delay == -1) {
+        while (1) {
+            if (tstc()) /* we got a key press	*/
+                return getc();
+        }
+    }
+    else {        
+        for (i = 0; i < delay; i++) {
+    		if (tstc()) /* we got a key press	*/
+    			return getc();
+            udelay (10*1000);
+        }
+    }
+    
+    if (error_p)
+        *error_p = -1;
+    return 0;
+}
+
+#define CTRL(x)   (x & 0x1f)
+#define INTR      CTRL('C')
+
+void Clk0_Enable(int clock_sel);	
+void Clk1_Enable(int clock_sel);
+void Clk0_Disable(void);
+void Clk1_Disable(void);
+
+//#define DOWNLOAD_ADDRESS _RAM_STARTADDRESS
+volatile U32 downloadAddress;
+
+void (*restart)(void)=(void (*)(void))0x0;
+void (*run)(void);
+
+
+volatile unsigned char *downPt;
+volatile U32 downloadFileSize;
+volatile U16 checkSum;
+volatile unsigned int err=0;
+volatile U32 totalDmaCount;
+
+volatile int isUsbdSetConfiguration;
+
+int download_run=0;
+volatile U32 tempDownloadAddress;
+int menuUsed=0;
+
+volatile U32 dwUSBBufReadPtr;
+volatile U32 dwUSBBufWritePtr;
+volatile U32 dwWillDMACnt;
+volatile U32 bDMAPending;
+volatile U32 dwUSBBufBase;
+volatile U32 dwUSBBufSize;
+
+int consoleNum;
+
+void usb_init_slave(void)
+{
+	struct s3c24x0_gpio * const gpioregs = s3c24x0_get_base_gpio();
+	char *mode;
+
+	udelay(100000);
+
+	Isr_Init();
+
+   writel((readl(&gpioregs->MISCCR) & ~((1<<3) | (1<<13))), &gpioregs->MISCCR); 
+// USBD is selected instead of USBH1 
+// USB port 1 is enabled.
+//
+//  USBD should be initialized first of all.
+//
+	isUsbdSetConfiguration=0;
+
+	UsbdMain(); 
+	udelay(100000);
+    
+    writel((readl(&gpioregs->GPCDAT) | (1<<5)), &gpioregs->GPCDAT); 
+ /* enable USB Device, thisway.diy */
+#if USBDMA
+	mode="DMA";
+#else
+	mode="Int";
+#endif
+	download_run=0; //The default menu is the Download & Run mode.
+	printf("USB slave is enable!\n");
+}
+
+
+__u32 usb_receive(char *buf, size_t len, U32 wait)
+{
+	int first=1;
+	U8 tempMem[16];
+	U32 j;
+	unsigned int dwRecvTimeSec = 0;
+	char c;
+	struct s3c24x0_interrupt * intregs = s3c24x0_get_base_interrupt();
+
+	dwUSBBufReadPtr = dwUSBBufBase; // USB_BUF_BASE; thiswa.diy, 2006.06.21
+	dwUSBBufWritePtr = dwUSBBufBase; // USB_BUF_BASE; thiswa.diy, 2006.06.21
+	bDMAPending = 0;
+
+	/* add by thisway.diy */
+	tempDownloadAddress = dwUSBBufBase; // USB_BUF_BASE; thiswa.diy, 2006.06.21 // RAM_BASE, changed by thisway.diy for wince, 2006.06.18
+
+	downloadAddress=(U32)tempMem; //_RAM_STARTADDRESS; 
+	downPt=(unsigned char *)downloadAddress;
+	//This address is used for receiving first 8 byte.
+	downloadFileSize=0;
+    
+
+    /*******************************/
+    /*    File download    */
+    /*******************************/
+    if(isUsbdSetConfiguration==0)
+    {
+	    printf("USB host is not connected yet.\n");
+    }
+
+    while(downloadFileSize==0) /* wait until send a file */
+    {
+        if(first==1 && isUsbdSetConfiguration!=0)
+        {
+            printf("USB host is connected. Waiting a download.\n");
+            first=0;
+        }
+		c = awaitkey(1, 0);
+		if ((c & 0x7f) == INTR)
+		{
+			printf("Cancelled by user\n");
+			return 0;
+		}
+    }
+
+	printf("get downloadFileSize = %d !!\n",downloadFileSize);
+
+    /* add by thisway.diy */
+    if (downloadFileSize - 10 > len)
+    {
+        printf("Length of file is too big : %d > %d\n", downloadFileSize - 10, len);
+        return 0;
+    }
+    
+    Timer_InitEx();
+    Timer_StartEx();
+        
+#if USBDMA    
+
+    writel((readl(&intregs->INTMSK) & ~(BIT_DMA2)), &intregs->INTMSK); 
+//    intregs->INTMSK&=~(BIT_DMA2);  
+
+    ClearEp3OutPktReady(); 
+    	// indicate the first packit is processed.
+    	// has been delayed for DMA2 cofiguration.
+
+    if(downloadFileSize>EP3_PKT_SIZE)
+    {
+        if(downloadFileSize - EP3_PKT_SIZE<=(0x80000))
+        {
+            /* set the source and length */
+            dwUSBBufWritePtr = downloadAddress + EP3_PKT_SIZE-8;
+            dwWillDMACnt = downloadFileSize - EP3_PKT_SIZE;
+	    }
+      	else
+      	{
+            dwUSBBufWritePtr = downloadAddress + EP3_PKT_SIZE - 8;
+            // dwWillDMACnt = 0x80000 - EP3_PKT_SIZE;
+            
+            /* Changed by thisway.diy, 2006.06.22
+             * We want When the first DMA interrupt happened, 
+             * it has received (0x80000 + 8) bytes data from PC
+             * The format of data PC send out is: <ADDR(DATA):4>+<SIZE(n+10):4>+<DATA:n>+<CS:2>
+             * So, the first 8 bytes isn't the real data we want
+             * We want the dwUSBBufWritePtr is always 0x80000 aligin
+             */
+            dwWillDMACnt = 0x80000 + 8 - EP3_PKT_SIZE;
+    	}
+     	totalDmaCount = 0;
+  	    ConfigEp3DmaMode(dwUSBBufWritePtr, dwWillDMACnt);
+    }
+    else
+    {
+        dwUSBBufWritePtr = downloadAddress + downloadFileSize - 8;
+	    totalDmaCount = downloadFileSize;
+    }
+#endif
+
+    printf("\nNow, Downloading [ADDRESS:%xh,TOTAL:%d]\n",
+    		downloadAddress,downloadFileSize);
+
+    if (wait)
+    {
+        printf("RECEIVED FILE SIZE:%8d",0);
+
+        j = totalDmaCount + 0x10000;
+        while (totalDmaCount != downloadFileSize)
+        {
+            if (totalDmaCount > j)
+            {
+        	    printf("\b\b\b\b\b\b\b\b%8d", j);
+                j = totalDmaCount + 0x10000;
+            }
+        }
+	    printf("\b\b\b\b\b\b\b\b%8d ", totalDmaCount);
+        dwRecvTimeSec = Timer_StopEx();
+        if (dwRecvTimeSec == 0)
+        {
+            dwRecvTimeSec = 1;
+        }
+        printf("(%dKB/S, %dS)\n", (downloadFileSize/dwRecvTimeSec/1024), dwRecvTimeSec);
+    }
+
+    return downloadFileSize - 10;
+}
+
+
+void HaltUndef(void)
+{
+	printf("Undefined instruction exception!!!\n");
+	while(1);
+}
+
+void HaltSwi(void)
+{
+	printf("SWI exception!!!\n");
+	while(1);
+}
+
+void HaltPabort(void)
+{
+	printf("Pabort exception!!!\n");
+	while(1);
+}
+
+void HaltDabort(void)
+{
+	printf("Dabort exception!!!\n");
+	while(1);
+}
+
+#if 0
+void Clk0_Enable(int clock_sel)	
+{	// 0:MPLLin, 1:UPLL, 2:FCLK, 3:HCLK, 4:PCLK, 5:DCLK0
+	struct s3c24x0_gpio 		* const  gpioregs	= s3c24x0_get_base_gpio();
+	gpioregs->MISCCR = gpioregs->MISCCR&~(7<<4) | (clock_sel<<4);
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<18) | (2<<18);
+}
+void Clk1_Enable(int clock_sel)
+{	// 0:MPLLout, 1:UPLL, 2:RTC, 3:HCLK, 4:PCLK, 5:DCLK1	
+	struct s3c24x0_gpio 		* const  gpioregs	= s3c24x0_get_base_gpio();
+	gpioregs->MISCCR = gpioregs->MISCCR&~(7<<8) | (clock_sel<<8);
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<20) | (2<<20);
+}
+void Clk0_Disable(void)
+{
+	struct s3c24x0_gpio 		* const  gpioregs	= s3c24x0_get_base_gpio();
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<18);	// GPH9 Input
+}
+void Clk1_Disable(void)
+{
+	struct s3c24x0_gpio 		* const  gpioregs	= s3c24x0_get_base_gpio();
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<20);	// GPH10 Input
+}
+#endif
+
+void udc_disconnect (void)
+{
+	struct s3c24x0_gpio * const  gpioregs = s3c24x0_get_base_gpio();
+	writel((readl(&gpioregs->GPCDAT) & ~(1<<5)), &gpioregs->GPCDAT); 
+//	UDCDBG ("disconnect, disable Pullup");
+
+}
diff --git a/drivers/usb/slave/usbinit.h b/drivers/usb/slave/usbinit.h
new file mode 100644
index 0000000..d2c27a1
--- /dev/null
+++ b/drivers/usb/slave/usbinit.h
@@ -0,0 +1,20 @@
+/****************************************************************
+ NAME: u2440mon.h
+ DESC: 
+ HISTORY:
+ Mar.29.2002:purnnamu: created first
+ ****************************************************************/
+ 
+#ifndef __U241MON_H__
+#define __U241MON_H__
+
+extern volatile unsigned char *downPt;
+extern volatile U32 totalDmaCount;
+extern volatile U32 downloadFileSize;
+extern volatile U32 downloadAddress;
+extern volatile U16 checkSum;
+
+extern int download_run;
+extern U32 tempDownloadAddress;
+
+#endif /*__U241MON_H__*/
diff --git a/drivers/usb/slave/usblib.c b/drivers/usb/slave/usblib.c
new file mode 100644
index 0000000..f118c4e
--- /dev/null
+++ b/drivers/usb/slave/usblib.c
@@ -0,0 +1,237 @@
+/****************************************************************
+ NAME: usblib.c
+ DESC: S3C2440X USB library functions
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ ****************************************************************/
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbmain.h"
+
+#define BIT_USBD		(0x1<<25)
+
+extern volatile U32 dwUSBBufReadPtr;
+extern volatile U32 dwUSBBufWritePtr;
+extern volatile U32 dwPreDMACnt;
+extern volatile U32 dwNextDMACnt;
+
+
+
+void ConfigUsbd(void)
+{
+	struct s3c24x0_interrupt * intregs = s3c24x0_get_base_interrupt();
+	ReconfigUsbd();
+	writel((readl(&intregs->INTMSK) & ~(BIT_USBD)), &intregs->INTMSK); 
+}
+
+
+void ReconfigUsbd(void)
+{
+// *** End point information ***
+//   EP0: control
+//   EP1: bulk in end point
+//   EP2: not used
+//   EP3: bulk out end point
+//   EP4: not used
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();   
+ 
+	writeb(PWR_REG_DEFAULT_VALUE, &usbdevregs->PWR_REG); //disable suspend mode
+	writeb(0, &usbdevregs->INDEX_REG); 
+	writeb(FIFO_SIZE_8, &usbdevregs->MAXP_REG); //EP0 max packit size = 8 
+	writeb((EP0_SERVICED_OUT_PKT_RDY | EP0_SERVICED_SETUP_END), & usbdevregs->EP0_CSR_IN_CSR1_REG); //EP0:clear OUT_PKT_RDY & SETUP_END
+	writeb(1, &usbdevregs->INDEX_REG); 
+
+#if (EP1_PKT_SIZE==32)
+	writeb(FIFO_SIZE_32, &usbdevregs->MAXP_REG); //EP1:max packit size = 32
+#else
+	writeb(FIFO_SIZE_64, &usbdevregs->MAXP_REG); 	//EP1:max packit size = 64
+#endif	
+	writeb((EPI_FIFO_FLUSH | EPI_CDT), &usbdevregs->EP0_CSR_IN_CSR1_REG); 
+	writeb((EPI_MODE_IN | EPI_IN_DMA_INT_MASK | EPI_BULK), &usbdevregs->IN_CSR2_REG);  //IN mode, IN_DMA_INT=masked    
+	writeb(EPO_CDT, &usbdevregs->OUT_CSR1_REG); 
+	writeb((EPO_BULK | EPO_OUT_DMA_INT_MASK), &usbdevregs->OUT_CSR2_REG); 
+
+	writeb(2, &usbdevregs->INDEX_REG); 
+	writeb(FIFO_SIZE_64, &usbdevregs->MAXP_REG); //EP2:max packit size = 64
+	writeb((EPI_FIFO_FLUSH | EPI_CDT | EPI_BULK), &usbdevregs->EP0_CSR_IN_CSR1_REG); 
+	writeb((EPI_MODE_IN | EPI_IN_DMA_INT_MASK), &usbdevregs->IN_CSR2_REG);  //IN mode, IN_DMA_INT=masked    
+	writeb(EPO_CDT, &usbdevregs->OUT_CSR1_REG); 
+	writeb((EPO_BULK | EPO_OUT_DMA_INT_MASK), &usbdevregs->OUT_CSR2_REG); 
+
+	writeb(3, &usbdevregs->INDEX_REG); 
+    #if (EP3_PKT_SIZE==32)
+	writeb(FIFO_SIZE_32, &usbdevregs->MAXP_REG); //EP3:max packit size = 32
+    #else
+	writeb(FIFO_SIZE_64, &usbdevregs->MAXP_REG); //EP3:max packit size = 64
+    #endif
+	writeb((EPI_FIFO_FLUSH | EPI_CDT | EPI_BULK), &usbdevregs->EP0_CSR_IN_CSR1_REG); 	
+	writeb((EPI_MODE_OUT | EPI_IN_DMA_INT_MASK), &usbdevregs->IN_CSR2_REG); //OUT mode, IN_DMA_INT=masked    
+	writeb(EPO_CDT, &usbdevregs->OUT_CSR1_REG); 
+    	//clear OUT_PKT_RDY, data_toggle_bit.
+	//The data toggle bit should be cleared when initialization.
+	writeb((EPO_BULK | EPO_OUT_DMA_INT_MASK), &usbdevregs->OUT_CSR2_REG); 
+
+	writeb(4, &usbdevregs->INDEX_REG); 
+	writeb(FIFO_SIZE_64, &usbdevregs->MAXP_REG); //EP4:max packit size = 64
+	writeb((EPI_FIFO_FLUSH | EPI_CDT | EPI_BULK), &usbdevregs->EP0_CSR_IN_CSR1_REG); 
+	writeb((EPI_MODE_OUT | EPI_IN_DMA_INT_MASK), &usbdevregs->IN_CSR2_REG); //OUT mode, IN_DMA_INT=masked    
+	writeb(EPO_CDT, &usbdevregs->OUT_CSR1_REG); 
+    	//clear OUT_PKT_RDY, data_toggle_bit.
+	//The data toggle bit should be cleared when initialization.
+	writeb((EPO_BULK | EPO_OUT_DMA_INT_MASK), &usbdevregs->OUT_CSR2_REG); 
+    
+	writeb((EP0_INT | EP1_INT | EP2_INT | EP3_INT | EP4_INT), &usbdevregs->EP_INT_REG); 
+	writeb((RESET_INT | SUSPEND_INT | RESUME_INT), &usbdevregs->USB_INT_REG); 
+    	//Clear all usbd pending bits
+    	
+	writeb((EP0_INT | EP1_INT | EP3_INT), &usbdevregs->EP_INT_EN_REG); 
+	writeb(RESET_INT, &usbdevregs->USB_INT_EN_REG); 
+    ep0State = EP0_STATE_INIT;
+    
+}
+
+
+void RdPktEp0(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();   
+ 	
+    for(i=0;i<num;i++)
+    {
+	 buf[i] = readb(&usbdevregs->fifo[0].EP_FIFO_REG);
+    }
+}
+    
+
+void WrPktEp0(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();      	
+    for(i=0;i<num;i++)
+    {
+	writeb(buf[i], &usbdevregs->fifo[0].EP_FIFO_REG); 
+    }
+}
+
+
+void WrPktEp1(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();      	
+    for(i=0;i<num;i++)
+    {
+	writeb(buf[i], &usbdevregs->fifo[1].EP_FIFO_REG); 
+    }
+}
+
+
+void WrPktEp2(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();      	
+    for(i=0;i<num;i++)
+    {
+	writeb(buf[i], &usbdevregs->fifo[2].EP_FIFO_REG); 
+    }
+}
+
+
+void RdPktEp3(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();      	
+    for(i=0;i<num;i++)
+    {
+	 buf[i] = readb(&usbdevregs->fifo[3].EP_FIFO_REG);
+    }
+}
+
+
+void RdPktEp4(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();      	
+    for(i=0;i<num;i++)
+    {
+	 buf[i] = readb(&usbdevregs->fifo[4].EP_FIFO_REG);
+    }
+}
+
+
+void ConfigEp3DmaMode(U32 bufAddr,U32 count)
+{
+	char j;
+	int i;
+	struct s3c24x0_usb_device * const usbdevregs = s3c24x0_get_base_usb_device();  
+	struct s3c24x0_dmas * const dmaregs = s3c24x0_get_base_dmas();
+
+	writeb(3, &usbdevregs->INDEX_REG); 
+	count &= 0xfffff; //transfer size should be <1MB
+	writel(((1<<1) | (1<<0)), &dmaregs->dma[2].DISRCC);     
+	writel(ADDR_EP3_FIFO, &dmaregs->dma[2].DISRC);  //src=APB,fixed,src=EP3_FIFO
+	writel(((0<<1) | (0<<0)), &dmaregs->dma[2].DIDSTC); 
+	writel(bufAddr, &dmaregs->dma[2].DIDST); //dst=AHB,increase,dst=bufAddr
+#if USBDMA_DEMAND
+	writel(((count)|(0<<31)|(0<<30)|(1<<29)|(0<<28)|(0<<27)|(4<<24)|(1<<23)|(0<<22)|(0<<20)), &dmaregs->dma[2].DCON); 
+        //demand,requestor=APB,CURR_TC int enable,unit transfer,
+        //single service,src=USBD,H/W request,autoreload,byte,CURR_TC
+#else
+    /* changed by thisway.diy to disable autoreload */
+	writel(((count)|(1<<31)|(0<<30)|(1<<29)|(0<<28)|(0<<27)|(4<<24)|(1<<23)|(1<<22)|(0<<20)), &dmaregs->dma[2].DCON); 
+        //handshake,requestor=APB,CURR_TC int enable,unit transfer,
+        //single service,src=USBD,H/W request,autoreload,byte,CURR_TC
+#endif
+	writel((1<<1), &dmaregs->dma[2].DMASKTRIG);         
+        //DMA 2 on
+
+    //rEP3_DMA_FIFO=0x40; //not needed for OUT operation. 	
+	writeb(0xff, &usbdevregs->ep3.EP_DMA_TTC_L); 
+	writeb(0xff, &usbdevregs->ep3.EP_DMA_TTC_M); 
+	writeb(0x0f, &usbdevregs->ep3.EP_DMA_TTC_H); 
+
+	writeb((readb(&usbdevregs->OUT_CSR2_REG) | EPO_AUTO_CLR | EPO_OUT_DMA_INT_MASK), &usbdevregs->OUT_CSR2_REG); 
+    	//AUTO_CLR(OUT_PKT_READY is cleared automatically), interrupt_masking.
+#if USBDMA_DEMAND
+	writeb(EP3_PKT_SIZE, &usbdevregs->ep3.EP_DMA_TTC_H); 
+	writeb((UDMA_DEMAND_MODE | UDMA_OUT_DMA_RUN | UDMA_DMA_MODE_EN), &usbdevregs->ep3.EP_DMA_CON); 
+        // deamnd enable,out_dma_run=run,in_dma_run=stop,DMA mode enable
+#else
+	writeb(0x01, &usbdevregs->ep3.EP_DMA_UNIT);         
+	writeb((UDMA_OUT_DMA_RUN | UDMA_DMA_MODE_EN), &usbdevregs->ep3.EP_DMA_CON); 
+        // deamnd disable,out_dma_run=run,in_dma_run=stop,DMA mode enable
+#endif  
+    //wait until DMA_CON is effective.
+	j = readb(&usbdevregs->ep3.EP_DMA_CON);
+	for(i=0;i<10;i++);    	
+
+    /* add by thisway.diy for non-autoreload */
+	writel((1<<1), &dmaregs->dma[3].DMASKTRIG); 
+}
+
+
+void ConfigEp3IntMode(void)
+{
+	char i;	
+	struct s3c24x0_usb_device * const usbdevregs = s3c24x0_get_base_usb_device(); 
+	struct s3c24x0_dmas * const dmaregs = s3c24x0_get_base_dmas(); 
+
+	writeb(3, &usbdevregs->INDEX_REG); 
+ 	writel((0<<1), &dmaregs->dma[2].DMASKTRIG);    
+
+        //DMA channel off
+	writeb((readb(&usbdevregs->OUT_CSR2_REG) & ~(EPO_AUTO_CLR)), &usbdevregs->OUT_CSR2_REG); 
+    	//AUTOCLEAR off,interrupt_enabled (???)
+	writeb(1, &usbdevregs->ep3.EP_DMA_UNIT); 	
+	writeb(0, &usbdevregs->ep3.EP_DMA_CON); 
+    	// deamnd disable,out_dma_run=stop,in_dma_run=stop,DMA mode disable
+	//wait until DMA_CON is effective.
+	i = readb(&usbdevregs->ep3.EP_DMA_CON);
+    
+}
diff --git a/drivers/usb/slave/usblib.h b/drivers/usb/slave/usblib.h
new file mode 100644
index 0000000..d67835e
--- /dev/null
+++ b/drivers/usb/slave/usblib.h
@@ -0,0 +1,29 @@
+/****************************************************************
+ NAME: usblib.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ ****************************************************************/
+#ifndef __USBLIB_H__
+#define __USBLIB_H__
+
+#include "2440usb.h"
+#include "def.h"
+
+#define PWR_REG_DEFAULT_VALUE (DISABLE_SUSPEND)
+
+void ConfigUsbd(void);
+void ReconfigUsbd(void);
+
+void RdPktEp0(U8 *buf,int num);
+void WrPktEp0(U8 *buf,int num);
+void WrPktEp1(U8 *buf,int num);
+void WrPktEp2(U8 *buf,int num);
+void RdPktEp3(U8 *buf,int num);
+void RdPktEp4(U8 *buf,int num);
+
+void ConfigEp3IntMode(void);
+void ConfigEp3DmaMode(U32 bufAddr,U32 count);
+
+#endif /*__USBLIB_H__*/
+
diff --git a/drivers/usb/slave/usbmain.c b/drivers/usb/slave/usbmain.c
new file mode 100644
index 0000000..38be407
--- /dev/null
+++ b/drivers/usb/slave/usbmain.c
@@ -0,0 +1,158 @@
+/****************************************************************
+ NAME: usbmain.c
+ DESC: endpoint interrupt handler
+       USB init jobs
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ ****************************************************************/
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbout.h"
+#include "usbin.h"
+
+#define BIT_USBD		(0x1<<25)
+extern void ClearPending_my(int bit); 
+    
+/**************************
+    Some PrepareEp1Fifo() should be deleted
+ **************************/   
+
+void UsbdMain(void)
+{
+    //ChangeUPllValue(0x38,2,1);	// UCLK=96Mhz     
+    //ChangeUPllValue(0x38,2,2);	// UCLK=48Mhz     
+    InitDescriptorTable();
+    //ResetUsbd();
+    
+    ConfigUsbd(); 
+
+    PrepareEp1Fifo(); 
+#if 0    
+    while(1)
+    {
+    	if(DbgPrintfLoop())continue;
+    	
+    	Delay(5000);
+    	if((i++%2)==0)Led_Display(0x8);
+    	else Led_Display(0x0);
+    }
+#endif    
+}
+
+
+void IsrUsbd(void)
+{
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();
+    U8 usbdIntpnd,epIntpnd;
+	U8 saveIndexReg = readb(&usbdevregs->INDEX_REG);
+	usbdIntpnd = readb(&usbdevregs->USB_INT_REG);
+	epIntpnd = readb(&usbdevregs->EP_INT_REG);
+//    DbgPrintf( "[INT:EP_I=%x,USBI=%x]",epIntpnd,usbdIntpnd );
+
+    if(usbdIntpnd&SUSPEND_INT)
+    {
+	writeb(SUSPEND_INT, &usbdevregs->USB_INT_REG);
+//    	DbgPrintf( "<SUS]\n");
+    }
+    if(usbdIntpnd&RESUME_INT)
+    {
+	writeb(RESUME_INT, &usbdevregs->USB_INT_REG);
+//    	DbgPrintf("<RSM]\n");
+    }
+    if(usbdIntpnd&RESET_INT)
+    {
+//    	DbgPrintf( "<RST] ReconfigUsbd\n");  
+    	
+    	//ResetUsbd();
+    	ReconfigUsbd();
+	writeb(RESET_INT, &usbdevregs->USB_INT_REG); //RESET_INT should be cleared after ResetUsbd().   	
+        PrepareEp1Fifo(); 
+    }
+
+    if(epIntpnd&EP0_INT)
+    {
+	writeb(EP0_INT, &usbdevregs->EP_INT_REG);
+    	Ep0Handler();
+    }
+    if(epIntpnd&EP1_INT)
+    {
+	writeb(EP1_INT, &usbdevregs->EP_INT_REG);
+    	Ep1Handler();
+    }
+
+    if(epIntpnd&EP2_INT)
+    {
+	writeb(EP2_INT, &usbdevregs->EP_INT_REG);
+ //   	DbgPrintf("<2:TBD]\n");   //not implemented yet	
+    	//Ep2Handler();
+    }
+
+    if(epIntpnd&EP3_INT)
+    {
+	writeb(EP3_INT, &usbdevregs->EP_INT_REG);
+    	Ep3Handler();
+    }
+
+    if(epIntpnd&EP4_INT)
+    {
+	writeb(EP4_INT, &usbdevregs->EP_INT_REG);
+ //   	DbgPrintf("<4:TBD]\n");   //not implemented yet	
+    	//Ep4Handler();
+    }
+
+    ClearPending_my((int)BIT_USBD);	 
+	writeb(saveIndexReg, &usbdevregs->INDEX_REG);    
+}
+
+
+
+
+/******************* Consol printf for debug *********************/
+
+#define DBGSTR_LENGTH (0x1000)
+U8 dbgStrFifo[DBGSTR_LENGTH];
+volatile U32 dbgStrRdPt=0;
+volatile U32 dbgStrWrPt=0;
+
+
+
+void _WrDbgStrFifo(U8 c)
+{
+    dbgStrFifo[dbgStrWrPt++]=c;
+    if(dbgStrWrPt==DBGSTR_LENGTH)dbgStrWrPt=0;
+
+}
+
+
+#if 0
+void DbgPrintf(char *fmt,...)
+{
+    int i,slen;
+    va_list ap;
+    char string[256];
+
+    va_start(ap,fmt);
+    vsprintf(string,fmt,ap);
+    
+//    slen=strlen(string);
+    
+//    for(i=0;i<slen;i++)
+//    	_WrDbgStrFifo(string[i]);
+    
+    va_end(ap);
+    puts(string);
+}
+#else
+void DbgPrintf(char *fmt,...)
+{
+}
+#endif
+
+
diff --git a/drivers/usb/slave/usbmain.h b/drivers/usb/slave/usbmain.h
new file mode 100644
index 0000000..f070ce9
--- /dev/null
+++ b/drivers/usb/slave/usbmain.h
@@ -0,0 +1,17 @@
+/****************************************************************
+ NAME: usbmain.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+ 
+#ifndef __USBMAIN_H__
+#define __USBMAIN_H__
+
+void UsbdMain(void);
+void IsrUsbd(void);
+
+void DbgPrintf(char *fmt,...);
+
+
+#endif /*__USBMAIN_H__*/
diff --git a/drivers/usb/slave/usbout.c b/drivers/usb/slave/usbout.c
new file mode 100644
index 0000000..6f16595
--- /dev/null
+++ b/drivers/usb/slave/usbout.c
@@ -0,0 +1,240 @@
+/****************************************************************
+ NAME: usbout.c
+ DESC: USB bulk-OUT operation related functions
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ ****************************************************************/
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#include "def.h"
+ 
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usb.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbout.h"
+
+#include "usbinit.h"
+
+#define BIT_USBD		(0x1<<25)
+#define BIT_DMA2		(0x1<<19)
+
+extern volatile U32 dwUSBBufReadPtr;
+extern volatile U32 dwUSBBufWritePtr;
+extern volatile U32 dwWillDMACnt;
+extern volatile U32 bDMAPending;
+extern volatile U32 dwUSBBufBase;
+extern volatile U32 dwUSBBufSize;
+extern void ClearPending_my(int bit); 
+//static void PrintEpoPkt(U8 *pt,int cnt);
+static void RdPktEp3_CheckSum(U8 *buf,int num);
+
+// ===================================================================
+// All following commands will operate in case 
+// - out_csr3 is valid.
+// ===================================================================
+
+ 
+
+#define CLR_EP3_OUT_PKT_READY() writeb(((out_csr3 & (~ EPO_WR_BITS)) & (~EPO_OUT_PKT_READY)) , &usbdevregs->OUT_CSR1_REG)
+//#define SET_EP3_SEND_STALL()	usbdevregs->OUT_CSR1_REG= ((out_csr3 & (~EPO_WR_BITS)) | EPO_SEND_STALL) 
+#define CLR_EP3_SENT_STALL()	writeb(((out_csr3 & (~EPO_WR_BITS)) &(~EPO_SENT_STALL)), &usbdevregs->OUT_CSR1_REG)
+//#define FLUSH_EP3_FIFO() 	usbdevregs->OUT_CSR1_REG= ((out_csr3 & (~EPO_WR_BITS)) |EPO_FIFO_FLUSH) 
+
+// ***************************
+// *** VERY IMPORTANT NOTE ***
+// ***************************
+// Prepare for the packit size constraint!!!
+
+// EP3 = OUT end point. 
+
+U8 ep3Buf[EP3_PKT_SIZE];
+
+void Ep3Handler(void)
+{
+	struct s3c24x0_interrupt * intregs = s3c24x0_get_base_interrupt();
+	struct s3c24x0_usb_device * const usbdevregs = s3c24x0_get_base_usb_device();
+    U8 out_csr3;
+    int fifoCnt;
+	writeb(3, &usbdevregs->INDEX_REG);
+	out_csr3 = readb(&usbdevregs->OUT_CSR1_REG);
+    
+//    DbgPrintf("<3:%x]",out_csr3);
+
+    if(out_csr3 & EPO_OUT_PKT_READY)
+    {   
+//	fifoCnt=usbdevregs->OUT_FIFO_CNT1_REG; 
+	fifoCnt = readb(&usbdevregs->OUT_FIFO_CNT1_REG);
+#if 0
+	RdPktEp3(ep3Buf,fifoCnt);
+	PrintEpoPkt(ep3Buf,fifoCnt);
+#else
+
+	if(downloadFileSize==0)
+	{
+   	    RdPktEp3((U8 *)downPt,8); 	
+   	    
+   	    if(download_run==0)
+   	    {
+		    downloadAddress=tempDownloadAddress;
+	    }
+	    else
+	    {
+	    	downloadAddress=
+	    		*((U8 *)(downPt+0))+
+			(*((U8 *)(downPt+1))<<8)+
+			(*((U8 *)(downPt+2))<<16)+
+			(*((U8 *)(downPt+3))<<24);
+            
+            dwUSBBufReadPtr = downloadAddress;
+            dwUSBBufWritePtr = downloadAddress;
+	    }
+	    downloadFileSize=
+	    	*((U8 *)(downPt+4))+
+		(*((U8 *)(downPt+5))<<8)+
+		(*((U8 *)(downPt+6))<<16)+
+		(*((U8 *)(downPt+7))<<24);
+	    checkSum=0;
+	    downPt=(U8 *)downloadAddress;
+
+  	    RdPktEp3_CheckSum((U8 *)downPt,fifoCnt-8); //The first 8-bytes are deleted.	    
+  	    downPt+=fifoCnt-8;  
+  	    
+  	#if USBDMA
+     	    //CLR_EP3_OUT_PKT_READY() is not executed. 
+     	    //So, USBD may generate NAK until DMA2 is configured for USB_EP3;
+		writel((readl(&intregs->INTMSK) | BIT_USBD), &intregs->INTMSK);
+      	    return;	
+  	#endif	
+	}
+	else
+	{
+	#if USBDMA    	
+	    printf("<ERROR>");
+	#endif    
+	    RdPktEp3_CheckSum((U8 *)downPt,fifoCnt); 	    
+	    downPt+=fifoCnt;  //fifoCnt=64
+	}
+#endif
+   	CLR_EP3_OUT_PKT_READY();
+#if 0
+       if(((rOUT_CSR1_REG&0x1)==1) && ((rEP_INT_REG & 0x8)==0))
+  		{
+  		fifoCnt=rOUT_FIFO_CNT1_REG; 
+		RdPktEp3_CheckSum((U8 *)downPt,fifoCnt); 	    
+	       downPt+=fifoCnt;  //fifoCnt=64
+	       CLR_EP3_OUT_PKT_READY();
+		}
+#endif
+  	return;
+    }
+
+    
+    //I think that EPO_SENT_STALL will not be set to 1.
+    if(out_csr3 & EPO_SENT_STALL)
+    {   
+   	DbgPrintf("[STALL]");
+   	CLR_EP3_SENT_STALL();
+   	return;
+    }	
+}
+
+
+#if 0
+void PrintEpoPkt(U8 *pt,int cnt)
+{
+    int i;
+    DbgPrintf("[BOUT:%d:",cnt);
+    for(i=0;i<cnt;i++)
+    	DbgPrintf("%x,",pt[i]);
+    DbgPrintf("]");
+}
+#endif
+
+void RdPktEp3_CheckSum(U8 *buf,int num)
+{
+    int i;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();    
+	
+    for(i=0;i<num;i++)
+    {
+	buf[i] = readb(&usbdevregs->fifo[3].EP_FIFO_REG);
+        checkSum+=buf[i];
+    }
+}
+
+
+
+void IsrDma2(void)
+{
+	struct s3c24x0_interrupt * intregs = s3c24x0_get_base_interrupt();
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();
+    U8 out_csr3;
+    U32 dwEmptyCnt;
+	U8 saveIndexReg = readb(&usbdevregs->INDEX_REG);
+	writeb(3, &usbdevregs->INDEX_REG);
+	out_csr3 = readb(&usbdevregs->OUT_CSR1_REG);
+
+    ClearPending_my((int)BIT_DMA2);	    
+
+    /* thisway.diy, 2006.06.22 
+     * When the first DMA interrupt happened, it has received max (0x80000 + EP3_PKT_SIZE) bytes data from PC
+     */
+    if (!totalDmaCount) 
+        totalDmaCount = dwWillDMACnt + EP3_PKT_SIZE;
+    else
+        totalDmaCount+=dwWillDMACnt;
+
+//    dwUSBBufWritePtr = ((dwUSBBufWritePtr + dwWillDMACnt - USB_BUF_BASE) % USB_BUF_SIZE) + USB_BUF_BASE; /* thisway.diy, 2006.06.21 */
+    dwUSBBufWritePtr = ((dwUSBBufWritePtr + dwWillDMACnt - dwUSBBufBase) % dwUSBBufSize) + dwUSBBufBase;
+
+    if(totalDmaCount>=downloadFileSize)// is last?
+    {
+    	totalDmaCount=downloadFileSize;
+	
+    	ConfigEp3IntMode();	
+
+    	if(out_csr3& EPO_OUT_PKT_READY)
+    	{
+       	    CLR_EP3_OUT_PKT_READY();
+	    }
+		writel(((readl(&intregs->INTMSK) | BIT_DMA2) & ~(BIT_USBD)), &intregs->INTMSK);
+    }
+    else
+    {
+    	if((totalDmaCount+0x80000)<downloadFileSize)	
+    	{
+    	    dwWillDMACnt = 0x80000;
+	    }
+    	else
+    	{
+    	    dwWillDMACnt = downloadFileSize - totalDmaCount;
+    	}
+
+        // dwEmptyCnt = (dwUSBBufReadPtr - dwUSBBufWritePtr - 1 + USB_BUF_SIZE) % USB_BUF_SIZE; /* thisway.diy, 2006.06.21 */
+        dwEmptyCnt = (dwUSBBufReadPtr - dwUSBBufWritePtr - 1 + dwUSBBufSize) % dwUSBBufSize;
+        if (dwEmptyCnt >= dwWillDMACnt)
+        {
+    	    ConfigEp3DmaMode(dwUSBBufWritePtr, dwWillDMACnt);
+        }
+        else
+        {
+            bDMAPending = 1;
+        }
+    }
+	writeb(saveIndexReg, &usbdevregs->INDEX_REG);
+}
+
+
+void ClearEp3OutPktReady(void)
+{
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();
+    U8 out_csr3;
+	writeb(3, &usbdevregs->INDEX_REG);
+	out_csr3 = readb(&usbdevregs->OUT_CSR1_REG);
+    CLR_EP3_OUT_PKT_READY();
+}
diff --git a/drivers/usb/slave/usbout.h b/drivers/usb/slave/usbout.h
new file mode 100644
index 0000000..c763cb6
--- /dev/null
+++ b/drivers/usb/slave/usbout.h
@@ -0,0 +1,17 @@
+/****************************************************************
+ NAME: usbout.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+ 
+#ifndef __USBOUT_H__
+#define __USBOUT_H__
+
+void Ep3Handler(void);
+void Ep3HandlerOptimized(void);
+
+void IsrDma2(void);
+void ClearEp3OutPktReady(void);
+
+#endif /*__USBOUT_H__*/
diff --git a/drivers/usb/slave/usbsetup.c b/drivers/usb/slave/usbsetup.c
new file mode 100644
index 0000000..1e82805
--- /dev/null
+++ b/drivers/usb/slave/usbsetup.c
@@ -0,0 +1,669 @@
+/**************************************************************
+ NAME: usbsetup.c
+ DESC: process the USB setup stage operations.
+ HISTORY:
+ MAR.25.2002:purnnamu: S3C2400X usbsetup.c is ported for S3C2410X.
+ AUG.20.2002:purnnamu: rEP0_CSR should be used instead of rOUT_CSR1_REG for EP0 macros.
+ **************************************************************/
+#include <common.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#include "def.h"
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usb.h"
+#include "usblib.h"
+#include "usbsetup.h"
+
+// *** End point information ***
+//   EP0: control
+//   EP1: bulk in end point
+//   EP2: not used
+//   EP3: bulk out end point
+//   EP4: not used
+
+// *** VERY IMPORTANT NOTE ***
+// Every descriptor size of EP0 should be 8n+m(m=1~7).
+// Otherwise, USB will not operate normally because the program
+// doesn't prepare the case that the descriptor size is 8n+0.
+// If the size of a descriptor is 8n, the 0 length packit should be sent. 
+// Special thanks to E.S.Choi for reminding me of this USB specification.
+
+
+// ===================================================================
+// All following commands will operate only in case 
+// - ep0_csr is valid.
+// ===================================================================
+#define CLR_EP0_OUT_PKT_RDY() 		writeb(((ep0_csr & (~EP0_WR_BITS)) | EP0_SERVICED_OUT_PKT_RDY ), &usbdevregs->EP0_CSR_IN_CSR1_REG)	 
+#define CLR_EP0_OUTPKTRDY_DATAEND() 	writeb(((ep0_csr & (~EP0_WR_BITS)) | (EP0_SERVICED_OUT_PKT_RDY | EP0_DATA_END)), &usbdevregs->EP0_CSR_IN_CSR1_REG)
+#define SET_EP0_IN_PKT_RDY() 		writeb(((ep0_csr & (~EP0_WR_BITS)) | (EP0_IN_PKT_READY)), &usbdevregs->EP0_CSR_IN_CSR1_REG)	 
+#define SET_EP0_INPKTRDY_DATAEND() 	writeb(((ep0_csr & (~EP0_WR_BITS)) | (EP0_IN_PKT_READY|EP0_DATA_END)), &usbdevregs->EP0_CSR_IN_CSR1_REG)			
+#define CLR_EP0_SETUP_END()		writeb(((ep0_csr & (~EP0_WR_BITS)) | (EP0_SERVICED_SETUP_END)), &usbdevregs->EP0_CSR_IN_CSR1_REG)			
+#define CLR_EP0_SENT_STALL() 		writeb(((ep0_csr & (~EP0_WR_BITS)) & (~EP0_SENT_STALL)), &usbdevregs->EP0_CSR_IN_CSR1_REG)			
+#define FLUSH_EP0_FIFO() 		{ while (readb(&usbdevregs->OUT_FIFO_CNT1_REG)) { readb(&usbdevregs->fifo[0].EP_FIFO_REG);}}
+
+U32 ep0State;
+U32 ep0SubState;
+
+extern volatile int isUsbdSetConfiguration;
+volatile U8 Rwuen;
+volatile U8 Configuration=1;
+volatile U8 AlterSetting;
+volatile U8 Selfpwr=TRUE;
+volatile U8 device_status;
+volatile U8 interface_status;
+volatile U8 endpoint0_status;
+volatile U8 endpoint1_status;
+volatile U8 endpoint3_status;
+
+struct USB_SETUP_DATA descSetup;
+struct USB_DEVICE_DESCRIPTOR descDev;
+struct USB_CONFIGURATION_DESCRIPTOR descConf;
+struct USB_INTERFACE_DESCRIPTOR descIf;
+struct USB_ENDPOINT_DESCRIPTOR descEndpt0;
+struct USB_ENDPOINT_DESCRIPTOR descEndpt1;
+struct USB_CONFIGURATION_SET ConfigSet;
+struct USB_INTERFACE_GET InterfaceGet;
+struct USB_GET_STATUS StatusGet;   //={0,0,0,0,0};
+
+
+static const U8 descStr0[]={
+	4,STRING_TYPE,LANGID_EN_L,LANGID_EN_H,  //codes representing languages
+    };
+
+static const U8 descStr1[]={  //Manufacturer  
+        (0x1c+2),STRING_TYPE, 
+        'T',0x0,'e',0x0,'k',0x0,'k',0x0,'a',0x0,'m',0x0,'a',0x0,'n',0x0,
+        ' ',0x0,'N',0x0,'i',0x0,'n',0x0,'j',0x0,'a',0x0,
+    };
+    
+static const U8 descStr2[]={  //Product  
+        (0x26+2),STRING_TYPE, 
+        'S',0x0,'3',0x0,'C',0x0,'2',0x0,'4',0x0,'4',0x0,'0',0x0,' ',0x0,
+        'O',0x0,'N',0x0,' ',0x0,'M',0x0,'I',0x0,'N',0x0,'I',0x0,'2',0x0,
+        '4',0x0,'4',0x0,'0',0x0,
+    };
+
+
+void Ep0Handler(void)
+{
+	static int ep0SubState;
+	U8 ep0_csr;
+	struct s3c24x0_usb_device * const usbdevregs	= s3c24x0_get_base_usb_device();
+
+	writeb(0, &usbdevregs->INDEX_REG);	
+	ep0_csr = readb(&usbdevregs->EP0_CSR_IN_CSR1_REG);
+    //DATAEND interrupt(ep0_csr==0x0) will be ignored 
+    //because ep0State==EP0_STATE_INIT when the DATAEND interrupt is issued.
+
+    
+    if(ep0_csr & EP0_SETUP_END)
+    {   
+    	 // Host may end GET_DESCRIPTOR operation without completing the IN data stage.
+    	 // If host does that, SETUP_END bit will be set.
+    	 // OUT_PKT_RDY has to be also cleared because status stage sets OUT_PKT_RDY to 1.
+//   	DbgPrintf("[SETUPEND]");
+	CLR_EP0_SETUP_END();
+	if(ep0_csr & EP0_OUT_PKT_READY) 
+	{
+	    FLUSH_EP0_FIFO(); //(???)
+	    	//I think this isn't needed because EP0 flush is done automatically.   
+	    CLR_EP0_OUT_PKT_RDY();
+	}
+	
+	ep0State=EP0_STATE_INIT;
+	return;
+    }	
+
+    //I think that EP0_SENT_STALL will not be set to 1.
+    if(ep0_csr & EP0_SENT_STALL)
+    {   
+//   	DbgPrintf("[STALL]");
+   	CLR_EP0_SENT_STALL();
+	if(ep0_csr & EP0_OUT_PKT_READY) 
+	{
+	    CLR_EP0_OUT_PKT_RDY();
+	}
+	
+	ep0State=EP0_STATE_INIT;
+	return;
+    }	
+
+
+
+    if((ep0_csr & EP0_OUT_PKT_READY)) // && (ep0State==EP0_STATE_INIT))
+    {	
+	RdPktEp0((U8 *)&descSetup,EP0_PKT_SIZE);
+
+//	PrintEp0Pkt((U8 *)(&descSetup)); //DEBUG
+    
+	switch(descSetup.bRequest)
+    	{
+    	case GET_DESCRIPTOR:
+            switch(descSetup.bValueH)        
+            {
+            case DEVICE_TYPE:
+// 	    	DbgPrintf("[GDD]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+	    	ep0State=EP0_STATE_GD_DEV_0;	        
+	    	break;	
+	    case CONFIGURATION_TYPE:
+// 	    	DbgPrintf("[GDC]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+ 	    	if((descSetup.bLengthL+(descSetup.bLengthH<<8))>0x9)
+ 	    	  //bLengthH should be used for bLength=0x209 at WIN2K.    	
+	    	   ep0State=EP0_STATE_GD_CFG_0; //for WIN98,WIN2K
+               else	    	    
+  		    ep0State=EP0_STATE_GD_CFG_ONLY_0; //for WIN2K
+	    	break;
+   	    case STRING_TYPE:
+// 	    	DbgPrintf("[GDS]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+	    	switch(descSetup.bValueL)
+	    	{
+	    	    case 0:
+	    	    	ep0State=EP0_STATE_GD_STR_I0;
+	    	    	break;
+	    	    case 1:
+       	    	    	ep0State=EP0_STATE_GD_STR_I1;
+	    	    	break;
+	    	    case 2:	
+	    	    	ep0State=EP0_STATE_GD_STR_I2;
+	    	    	break;
+	    	    default:
+//	    		DbgPrintf("[UE:STRI?]");
+	    		break;
+	    	}
+	    	ep0SubState=0;
+	    	break;
+	    case INTERFACE_TYPE:
+// 	    	DbgPrintf("[GDI]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+	    	ep0State=EP0_STATE_GD_IF_ONLY_0; //for WIN98
+	    	break;
+	    case ENDPOINT_TYPE:	    	
+ //	    	DbgPrintf("[GDE]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+ 	    	switch(descSetup.bValueL&0xf)
+	    	{
+	    	case 0:
+	    	    ep0State=EP0_STATE_GD_EP0_ONLY_0;
+	    	    break;
+	    	case 1:
+       	    	    ep0State=EP0_STATE_GD_EP1_ONLY_0;
+	    	    break;
+	    	default:
+//	    	    DbgPrintf("[UE:GDE?]");
+	    	    break;
+	    	}
+	    	break;
+	    default:
+//	    	DbgPrintf("[UE:GD?]");
+	    	break;
+	    }	
+    	    break;
+
+    	case SET_ADDRESS:
+//            DbgPrintf("[SA:%d]",descSetup.bValueL);
+		writeb((descSetup.bValueL | 0x80), &usbdevregs->FUNC_ADDR_REG);
+	    CLR_EP0_OUTPKTRDY_DATAEND(); //Because of no data control transfers.
+            ep0State=EP0_STATE_INIT;
+            break;
+    	
+	case SET_CONFIGURATION:
+//            DbgPrintf("[SC]");
+            ConfigSet.ConfigurationValue=descSetup.bValueL;
+            CLR_EP0_OUTPKTRDY_DATAEND(); //Because of no data control transfers.
+            ep0State=EP0_STATE_INIT;
+
+            isUsbdSetConfiguration=1; 
+            break;
+
+    	    //////////////////////// For chapter 9 test ////////////////////
+
+    	  case CLEAR_FEATURE:
+    	  	
+    	  	switch (descSetup.bmRequestType)
+    	  	{
+    	  	  case DEVICE_RECIPIENT:
+    	  	  	if (descSetup.bValueL == 1)
+    	  	  		Rwuen = FALSE;
+    	  	  	
+    	  	  	break;
+
+    	  	  case ENDPOINT_RECIPIENT:
+    	  	  	 if (descSetup.bValueL == 0)
+    	  	  	 {
+	                       if((descSetup.bIndexL & 0x7f) == 0x00){
+	                        StatusGet.Endpoint0= 0;    
+	                       }
+	                       if((descSetup.bIndexL & 0x8f) == 0x81){           // IN  Endpoint 1
+	                         StatusGet.Endpoint1= 0;           
+	                        }
+	                       if((descSetup.bIndexL & 0x8f) == 0x03){          // OUT Endpoint 3
+	                         StatusGet.Endpoint3= 0;      
+	                         }
+                       }
+    	  	  	 
+    	  	  	 break;
+
+    	  	  default:
+    	  	  	break;
+    	  	}
+    	  	CLR_EP0_OUTPKTRDY_DATAEND();
+    	  	ep0State=EP0_STATE_INIT;
+    	  	break;
+
+    	  case GET_CONFIGURATION:
+
+                CLR_EP0_OUT_PKT_RDY();
+	    	  ep0State=EP0_CONFIG_SET;
+    	  	   
+    	         break;
+
+
+    	  case GET_INTERFACE:
+    	  	
+    	  	  CLR_EP0_OUT_PKT_RDY();
+	    	  ep0State=EP0_INTERFACE_GET;
+    	  	  
+    	  	  break;
+
+    	  case GET_STATUS:
+
+    	  	switch(descSetup.bmRequestType)
+    	  	{
+    	  	      case  (0x80):
+
+    	  	 		CLR_EP0_OUT_PKT_RDY();
+    	  	 		StatusGet.Device=((U8)Rwuen<<1)|(U8)Selfpwr;
+    	  	 		ep0State=EP0_GET_STATUS0;
+    	  	 		    	  	 		
+                          break;
+
+                     case  (0x81):
+                           	CLR_EP0_OUT_PKT_RDY();
+    	  	 		StatusGet.Interface=0;
+    	  	 		ep0State=EP0_GET_STATUS1;
+                          break;
+
+                     case  (0x82):
+
+                     	CLR_EP0_OUT_PKT_RDY();
+    	  	 		if((descSetup.bIndexL & 0x7f) == 0x00){
+	                          ep0State=EP0_GET_STATUS2;
+    	  	 		  }
+    	  	 		
+	                       if((descSetup.bIndexL & 0x8f) == 0x81){
+	                          ep0State=EP0_GET_STATUS3;
+	                       }
+	                       
+	                       if((descSetup.bIndexL & 0x8f) == 0x03){
+                                ep0State=EP0_GET_STATUS4;
+	                       }
+                          break;
+
+                      default:
+                          	break;
+    	  	}
+    	  	      
+    	  	break;
+
+
+    	  case SET_DESCRIPTOR:
+    	  	       CLR_EP0_OUTPKTRDY_DATAEND();
+    	  	       ep0State=EP0_STATE_INIT;
+    	  	break;
+
+
+    	  case SET_FEATURE:
+    	  	 
+    	  	switch (descSetup.bmRequestType)
+    	  	{
+    	  	  case DEVICE_RECIPIENT:
+    	  	  	if (descSetup.bValueL == 1)
+    	  	  		Rwuen = TRUE;
+    	  	  	
+    	  	  	break;
+
+    	  	  case ENDPOINT_RECIPIENT:
+    	  	  	 if (descSetup.bValueL == 0)
+    	  	  	 {
+	                       if((descSetup.bIndexL & 0x7f) == 0x00){
+	                        StatusGet.Endpoint0= 1;
+	                       }
+	                       if((descSetup.bIndexL & 0x8f) == 0x81){
+	                         StatusGet.Endpoint1= 1;
+	                       }
+	                       if((descSetup.bIndexL & 0x8f) == 0x03){
+	                         StatusGet.Endpoint3= 1;
+	                       }
+                       }
+    	  	  	break;
+
+    	  	  default:
+    	  	  	break;
+    	  	}
+    	  	CLR_EP0_OUTPKTRDY_DATAEND();
+    	  	ep0State=EP0_STATE_INIT;
+    	  
+    	  	break;
+
+
+    	  case SET_INTERFACE:
+    	  	   InterfaceGet.AlternateSetting= descSetup.bValueL;
+    	  	   CLR_EP0_OUTPKTRDY_DATAEND(); 
+                 ep0State=EP0_STATE_INIT;
+    	  	break;
+
+    	  case SYNCH_FRAME:
+    	  	ep0State=EP0_STATE_INIT;
+    	  	break;
+
+    	  //////////////////////////////////////////////////////////////
+
+  	default:
+//	    DbgPrintf("[UE:SETUP=%x]",descSetup.bRequest);
+    	    CLR_EP0_OUTPKTRDY_DATAEND(); //Because of no data control transfers.
+	    ep0State=EP0_STATE_INIT;
+	    break;
+    
+        }
+    }
+    
+    switch(ep0State)
+    {	
+	case EP0_STATE_INIT:
+	    break; 
+
+	//=== GET_DESCRIPTOR:DEVICE ===
+    	case EP0_STATE_GD_DEV_0:
+//            DbgPrintf("[GDD0]");
+            WrPktEp0((U8 *)&descDev+0,8); //EP0_PKT_SIZE
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_DEV_1;
+            break;
+            
+    	case EP0_STATE_GD_DEV_1:
+ //           DbgPrintf("[GDD1]");
+            WrPktEp0((U8 *)&descDev+0x8,8); 
+            SET_EP0_IN_PKT_RDY();
+            
+            ep0State=EP0_STATE_GD_DEV_2;
+            break;
+
+    	case EP0_STATE_GD_DEV_2:
+//            DbgPrintf("[GDD2]");
+            WrPktEp0((U8 *)&descDev+0x10,2);   //8+8+2=0x12
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;
+            break;
+    
+
+        //=== GET_DESCRIPTOR:CONFIGURATION+INTERFACE+ENDPOINT0+ENDPOINT1 ===
+        //Windows98 gets these 4 descriptors all together by issuing only a request.
+        //Windows2000 gets each descriptor seperately.
+    	case EP0_STATE_GD_CFG_0:
+//            DbgPrintf("[GDC0]");
+            WrPktEp0((U8 *)&descConf+0,8); //EP0_PKT_SIZE
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_1;
+            break;
+    
+    	case EP0_STATE_GD_CFG_1:
+//            DbgPrintf("[GDC1]");
+            WrPktEp0((U8 *)&descConf+8,1); 
+            WrPktEp0((U8 *)&descIf+0,7); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_2;
+            break;
+
+    	case EP0_STATE_GD_CFG_2:
+//            DbgPrintf("[GDC2]");
+            WrPktEp0((U8 *)&descIf+7,2); 
+            WrPktEp0((U8 *)&descEndpt0+0,6); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_3;
+            break;
+
+    	case EP0_STATE_GD_CFG_3:
+ //           DbgPrintf("[GDC3]");
+            WrPktEp0((U8 *)&descEndpt0+6,1); 
+            WrPktEp0((U8 *)&descEndpt1+0,7); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_4;            
+            break;
+
+    	case EP0_STATE_GD_CFG_4:
+//            DbgPrintf("[GDC4]");
+             //zero length data packit 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+
+        //=== GET_DESCRIPTOR:CONFIGURATION ONLY===
+    	case EP0_STATE_GD_CFG_ONLY_0:
+//            DbgPrintf("[GDCO0]");
+            WrPktEp0((U8 *)&descConf+0,8); //EP0_PKT_SIZE
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_ONLY_1;
+            break;
+    
+    	case EP0_STATE_GD_CFG_ONLY_1:
+//            DbgPrintf("[GDCO1]");
+            WrPktEp0((U8 *)&descConf+8,1); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+
+        //=== GET_DESCRIPTOR:INTERFACE ONLY===
+    	case EP0_STATE_GD_IF_ONLY_0:
+//            DbgPrintf("[GDI0]");
+            WrPktEp0((U8 *)&descIf+0,8); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_IF_ONLY_1;
+            break;
+    	case EP0_STATE_GD_IF_ONLY_1:
+//           DbgPrintf("[GDI1]");
+            WrPktEp0((U8 *)&descIf+8,1); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+
+        //=== GET_DESCRIPTOR:ENDPOINT 0 ONLY===
+    	case EP0_STATE_GD_EP0_ONLY_0:
+//            DbgPrintf("[GDE00]");
+            WrPktEp0((U8 *)&descEndpt0+0,7); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+            
+        //=== GET_DESCRIPTOR:ENDPOINT 1 ONLY===
+    	case EP0_STATE_GD_EP1_ONLY_0:
+//            DbgPrintf("[GDE10]");
+            WrPktEp0((U8 *)&descEndpt1+0,7); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+            
+////////////////////////////////////////////
+
+         case EP0_INTERFACE_GET:
+            WrPktEp0((U8 *)&InterfaceGet+0,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+ 
+        //=== GET_DESCRIPTOR:STRING ===
+
+    	case EP0_STATE_GD_STR_I0:
+//            DbgPrintf("[GDS0_0]");
+           WrPktEp0((U8 *)descStr0, 4 );  
+	    SET_EP0_INPKTRDY_DATAEND();
+	    ep0State=EP0_STATE_INIT;     
+	    ep0SubState=0;
+	    break;
+
+	case EP0_STATE_GD_STR_I1:
+//            DbgPrintf("[GDS1_%d]",ep0SubState);
+             if( (ep0SubState*EP0_PKT_SIZE+EP0_PKT_SIZE)<sizeof(descStr1) )
+            {
+            	WrPktEp0((U8 *)descStr1+(ep0SubState*EP0_PKT_SIZE),EP0_PKT_SIZE); 
+            	SET_EP0_IN_PKT_RDY();
+            	ep0State=EP0_STATE_GD_STR_I1;
+            	ep0SubState++;
+            }
+	    else
+	    {
+	    	WrPktEp0((U8 *)descStr1+(ep0SubState*EP0_PKT_SIZE),
+	    		 sizeof(descStr1)-(ep0SubState*EP0_PKT_SIZE)); 
+		SET_EP0_INPKTRDY_DATAEND();
+		ep0State=EP0_STATE_INIT;     
+		ep0SubState=0;
+	    }
+	    break;
+
+	case EP0_STATE_GD_STR_I2:
+//            DbgPrintf("[GDS2_%d]",ep0SubState);
+             if( (ep0SubState*EP0_PKT_SIZE+EP0_PKT_SIZE)<sizeof(descStr2) )
+            {
+            	WrPktEp0((U8 *)descStr2+(ep0SubState*EP0_PKT_SIZE),EP0_PKT_SIZE); 
+            	SET_EP0_IN_PKT_RDY();
+            	ep0State=EP0_STATE_GD_STR_I2;
+            	ep0SubState++;
+            }
+	    else
+	    {
+//                DbgPrintf("[E]");
+	    	WrPktEp0((U8 *)descStr2+(ep0SubState*EP0_PKT_SIZE),
+	    		 sizeof(descStr2)-(ep0SubState*EP0_PKT_SIZE)); 
+		SET_EP0_INPKTRDY_DATAEND();
+		ep0State=EP0_STATE_INIT;     
+		ep0SubState=0;
+	    }
+	    break;
+
+	 case EP0_CONFIG_SET:
+	 	WrPktEp0((U8 *)&ConfigSet+0,1); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+            break;
+
+        case EP0_GET_STATUS0:
+	     WrPktEp0((U8 *)&StatusGet+0,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS1:
+	     WrPktEp0((U8 *)&StatusGet+1,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS2:
+	     WrPktEp0((U8 *)&StatusGet+2,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS3:
+	     WrPktEp0((U8 *)&StatusGet+3,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS4:
+	     WrPktEp0((U8 *)&StatusGet+4,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+     	default:
+//	    DbgPrintf("UE:G?D");
+     	    break;
+    }
+}
+
+
+   
+#if 0    
+void PrintEp0Pkt(U8 *pt)
+{
+    int i;
+   DbgPrintf("[RCV:");
+    for(i=0;i<EP0_PKT_SIZE;i++)
+        DbgPrintf("%x,",pt[i]);
+    DbgPrintf("]");
+}
+#endif
+
+
+
+void InitDescriptorTable(void)
+{	
+    //Standard device descriptor
+    descDev.bLength=0x12;	//EP0_DEV_DESC_SIZE=0x12 bytes    
+    descDev.bDescriptorType=DEVICE_TYPE;         
+    descDev.bcdUSBL=0x10;
+    descDev.bcdUSBH=0x01; 	//Ver 1.10
+    descDev.bDeviceClass=0xFF; //0x0          
+    descDev.bDeviceSubClass=0x0;          
+    descDev.bDeviceProtocol=0x0;          
+    descDev.bMaxPacketSize0=0x8;         
+    descDev.idVendorL=0x45;
+    descDev.idVendorH=0x53;
+    descDev.idProductL=0x34;
+    descDev.idProductH=0x12;
+    descDev.bcdDeviceL=0x00;
+    descDev.bcdDeviceH=0x01;
+    descDev.iManufacturer=0x1;  //index of string descriptor
+    descDev.iProduct=0x2;	//index of string descriptor 
+    descDev.iSerialNumber=0x0;
+    descDev.bNumConfigurations=0x1;
+
+    //Standard configuration descriptor
+    descConf.bLength=0x9;    
+    descConf.bDescriptorType=CONFIGURATION_TYPE;         
+    descConf.wTotalLengthL=0x20; //<cfg desc>+<if desc>+<endp0 desc>+<endp1 desc>
+    descConf.wTotalLengthH=0;
+    descConf.bNumInterfaces=1;
+//dbg    descConf.bConfigurationValue=2;  //why 2? There's no reason.
+    descConf.bConfigurationValue=1;  
+    descConf.iConfiguration=0;
+    descConf.bmAttributes=CONF_ATTR_DEFAULT|CONF_ATTR_SELFPOWERED;  //bus powered only.
+    descConf.maxPower=25; //draws 50mA current from the USB bus.          
+
+    //Standard interface descriptor
+    descIf.bLength=0x9;    
+    descIf.bDescriptorType=INTERFACE_TYPE;         
+    descIf.bInterfaceNumber=0x0;
+    descIf.bAlternateSetting=0x0; //?
+    descIf.bNumEndpoints=2;	//# of endpoints except EP0
+    descIf.bInterfaceClass=0xff; //0x0 ?
+    descIf.bInterfaceSubClass=0x0;  
+    descIf.bInterfaceProtocol=0x0;
+    descIf.iInterface=0x0;
+
+    //Standard endpoint0 descriptor
+    descEndpt0.bLength=0x7;    
+    descEndpt0.bDescriptorType=ENDPOINT_TYPE;         
+    descEndpt0.bEndpointAddress=1|EP_ADDR_IN;   // 2400Xendpoint 1 is IN endpoint.
+    descEndpt0.bmAttributes=EP_ATTR_BULK;
+    descEndpt0.wMaxPacketSizeL=EP1_PKT_SIZE; //64
+    descEndpt0.wMaxPacketSizeH=0x0;
+    descEndpt0.bInterval=0x0; //not used
+
+    //Standard endpoint1 descriptor
+    descEndpt1.bLength=0x7;    
+    descEndpt1.bDescriptorType=ENDPOINT_TYPE;         
+    descEndpt1.bEndpointAddress=3|EP_ADDR_OUT;   // 2400X endpoint 3 is OUT endpoint.
+    descEndpt1.bmAttributes=EP_ATTR_BULK;
+    descEndpt1.wMaxPacketSizeL=EP3_PKT_SIZE; //64
+    descEndpt1.wMaxPacketSizeH=0x0;
+    descEndpt1.bInterval=0x0; //not used 
+}
+
diff --git a/drivers/usb/slave/usbsetup.h b/drivers/usb/slave/usbsetup.h
new file mode 100644
index 0000000..5ec1481
--- /dev/null
+++ b/drivers/usb/slave/usbsetup.h
@@ -0,0 +1,55 @@
+/****************************************************************
+ NAME: usbsetup.h
+ DESC: usb setup
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+ 
+#ifndef __USBSETUP_H__
+#define __USBSETUP_H__
+
+void Ep0Handler(void);
+void InitDescriptorTable(void);
+void PrintEp0Pkt(U8 *pt);
+
+
+#define EP0_STATE_INIT 			(0)  
+
+//NOTE: The ep0State value in a same group should be added by 1.
+#define EP0_STATE_GD_DEV_0	 	(10)  //10-10=0 
+#define EP0_STATE_GD_DEV_1 		(11)  //11-10=1
+#define EP0_STATE_GD_DEV_2 		(12)  //12-10=2
+
+#define EP0_STATE_GD_CFG_0	 	(20)
+#define EP0_STATE_GD_CFG_1 		(21)
+#define EP0_STATE_GD_CFG_2 		(22)
+#define EP0_STATE_GD_CFG_3 		(23)
+#define EP0_STATE_GD_CFG_4 		(24)
+
+#define EP0_STATE_GD_CFG_ONLY_0		(40)
+#define EP0_STATE_GD_CFG_ONLY_1		(41)
+#define EP0_STATE_GD_IF_ONLY_0 		(42)
+#define EP0_STATE_GD_IF_ONLY_1 		(43)
+#define EP0_STATE_GD_EP0_ONLY_0		(44)
+#define EP0_STATE_GD_EP1_ONLY_0		(45)
+#define EP0_INTERFACE_GET                        (46)
+
+
+#define EP0_STATE_GD_STR_I0	 	(30)  
+#define EP0_STATE_GD_STR_I1	 	(31)  
+#define EP0_STATE_GD_STR_I2	 	(32)  
+
+#define EP0_CONFIG_SET    (33)
+#define EP0_GET_STATUS0  (35)
+#define EP0_GET_STATUS1  (36)
+#define EP0_GET_STATUS2  (37)
+#define EP0_GET_STATUS3  (38)
+#define EP0_GET_STATUS4  (39)
+
+
+
+
+extern U32 ep0State;
+
+
+#endif /*__USBSETUP_H__*/
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index a5e339a..5f46344 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -39,6 +39,7 @@ COBJS-$(CONFIG_VIDEO_SM501) += sm501.o
 COBJS-$(CONFIG_VIDEO_SMI_LYNXEM) += smiLynxEM.o
 COBJS-$(CONFIG_VIDEO_VCXK) += bus_vcxk.o
 COBJS-y += videomodes.o
+COBJS-y += s3c2410_fb.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/video/cfb_console.c b/drivers/video/cfb_console.c
index 49f0a2e..ff1dd23 100644
--- a/drivers/video/cfb_console.c
+++ b/drivers/video/cfb_console.c
@@ -283,8 +283,11 @@ void	console_cursor (int state);
 #define VIDEO_LOGO_LUT_OFFSET	LINUX_LOGO_LUT_OFFSET
 #define VIDEO_LOGO_COLORS	LINUX_LOGO_COLORS
 #endif	/* CONFIG_VIDEO_BMP_LOGO */
-#define VIDEO_INFO_X		(VIDEO_LOGO_WIDTH)
-#define VIDEO_INFO_Y		(VIDEO_FONT_HEIGHT/2)
+#define VIDEO_INFO_X		(0)
+#define VIDEO_INFO_Y		(VIDEO_LOGO_HEIGHT)
+//#define VIDEO_INFO_X		(VIDEO_LOGO_WIDTH)
+//#define VIDEO_INFO_Y		(VIDEO_FONT_HEIGHT/2)
+
 #else	/* CONFIG_VIDEO_LOGO */
 #define VIDEO_LOGO_WIDTH	0
 #define VIDEO_LOGO_HEIGHT	0
diff --git a/drivers/video/s3c2410_fb.c b/drivers/video/s3c2410_fb.c
new file mode 100644
index 0000000..1340449
--- /dev/null
+++ b/drivers/video/s3c2410_fb.c
@@ -0,0 +1,168 @@
+/*
+ * (C) Copyright 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+ 
+#if defined(CONFIG_VIDEO_S3C2410)
+ 
+#include <video_fb.h>
+#include "videomodes.h"
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+/*
+ * Export Graphic Device
+ */
+GraphicDevice smi;
+ 
+#define VIDEO_MEM_SIZE  0x200000        /* 240x320x16bit = 0x25800 bytes */
+ 
+extern void board_video_init(GraphicDevice *pGD);
+ 
+/*******************************************************************************
+ *
+ * Init video chip with common Linux graphic modes (lilo)
+ */
+void *video_hw_init (void)
+{
+    struct s3c24x0_lcd * const lcd = s3c24x0_get_base_lcd();
+    GraphicDevice *pGD = (GraphicDevice *)&smi;
+    int videomode;
+    unsigned long t1, hsynch, vsynch;
+    char *penv;
+    int tmp, i, bits_per_pixel;
+    struct ctfb_res_modes *res_mode;
+    struct ctfb_res_modes var_mode;
+//    unsigned char videoout;
+ 
+    /* Search for video chip */
+    printf("Video: ");
+
+    tmp = 0;
+ 
+         videomode = CFG_SYS_DEFAULT_VIDEO_MODE;
+         /* get video mode via environment */
+         if ((penv = getenv ("videomode")) != NULL) {
+                 /* deceide if it is a string */
+                 if (penv[0] <= '9') {
+                         videomode = (int) simple_strtoul (penv, NULL, 16);
+                         tmp = 1;
+                 }
+         } else {
+                 tmp = 1;
+         }
+         if (tmp) {
+                 /* parameter are vesa modes */
+                 /* search params */
+                 for (i = 0; i < VESA_MODES_COUNT; i++) {
+                         if (vesa_modes[i].vesanr == videomode)
+                                 break;
+                 }
+                 if (i == VESA_MODES_COUNT) {
+                         printf ("no VESA Mode found, switching to mode 0x%x ", CFG_SYS_DEFAULT_VIDEO_MODE);
+                         i = 0;
+                }
+                 res_mode =
+                         (struct ctfb_res_modes *) &res_mode_init[vesa_modes[i].
+                                                                  resindex];
+                 bits_per_pixel = vesa_modes[i].bits_per_pixel;
+         } else {
+ 
+                res_mode = (struct ctfb_res_modes *) &var_mode;
+                 bits_per_pixel = video_get_params (res_mode, penv);
+         }
+ 
+         /* calculate hsynch and vsynch freq (info only) */
+         t1 = (res_mode->left_margin + res_mode->xres +
+               res_mode->right_margin + res_mode->hsync_len) / 8;
+         t1 *= 8;
+         t1 *= res_mode->pixclock;
+         t1 /= 1000;
+         hsynch = 1000000000L / t1;
+         t1 *=
+                 (res_mode->upper_margin + res_mode->yres +
+                  res_mode->lower_margin + res_mode->vsync_len);
+         t1 /= 1000;
+         vsynch = 1000000000L / t1;
+ 
+         /* fill in Graphic device struct */
+         sprintf (pGD->modeIdent, "%dx%dx%d %ldkHz %ldHz", res_mode->xres,
+                  res_mode->yres, bits_per_pixel, (hsynch / 1000),
+                  (vsynch / 1000));
+         printf ("%s\n", pGD->modeIdent);
+         pGD->winSizeX = res_mode->xres;
+         pGD->winSizeY = res_mode->yres;
+         pGD->plnSizeX = res_mode->xres;
+         pGD->plnSizeY = res_mode->yres;
+             
+         switch (bits_per_pixel) {
+         case 8:
+                 pGD->gdfBytesPP = 1;
+                 pGD->gdfIndex = GDF__8BIT_INDEX;
+                 break;
+         case 15:
+                 pGD->gdfBytesPP = 2;
+                 pGD->gdfIndex = GDF_15BIT_555RGB;
+                 break;
+         case 16:
+                 pGD->gdfBytesPP = 2;
+                 pGD->gdfIndex = GDF_16BIT_565RGB;
+                 break;
+         case 24:
+                 pGD->gdfBytesPP = 3;
+                 pGD->gdfIndex = GDF_24BIT_888RGB;
+                 break;
+         }
+ 
+         /* statically configure settings */
+        pGD->winSizeX = pGD->plnSizeX = 240;
+         pGD->winSizeY = pGD->plnSizeY = 320;
+         pGD->gdfBytesPP = 2;
+         pGD->gdfIndex = GDF_16BIT_565RGB;
+ 
+         pGD->frameAdrs = LCD_VIDEO_ADDR;
+         pGD->memSize = VIDEO_MEM_SIZE;
+ 
+         board_video_init(pGD);
+
+	writel((pGD->frameAdrs >> 1), &lcd->LCDSADDR1); 
+ 
+         /* This marks the end of the frame buffer. */
+	writel((((readl(&lcd->LCDSADDR1))&0x1fffff) + (pGD->winSizeX+0) * pGD->winSizeY), &lcd->LCDSADDR2); 
+	writel((pGD->winSizeX & 0x7ff), &lcd->LCDSADDR3); 
+ 
+         /* Clear video memory */
+         memset((void *)pGD->frameAdrs, 0, pGD->memSize);
+ 
+         /* Enable  Display  */
+	writel((readl(&lcd->LCDCON1) | 0x01), & lcd->LCDCON1); /* ENVID = 1 */
+ 
+         return ((void*)&smi);
+ }
+ 
+ void
+ video_set_lut (unsigned int index,      /* color number */
+                unsigned char r, /* red */
+                unsigned char g, /* green */
+                unsigned char b  /* blue */
+		)
+ {
+ }
+ 
+ #endif /* CONFIG_VIDEO_S3C2410 */
diff --git a/drivers/video/videomodes.c b/drivers/video/videomodes.c
index d27ce1d..834b992 100644
--- a/drivers/video/videomodes.c
+++ b/drivers/video/videomodes.c
@@ -95,6 +95,7 @@ const struct ctfb_vesa_modes vesa_modes[VESA_MODES_COUNT] = {
 	{0x319, RES_MODE_1280x1024, 15},
 	{0x31A, RES_MODE_1280x1024, 16},
 	{0x31B, RES_MODE_1280x1024, 24},
+	{0x211, RES_MODE_240x320, 16},
 };
 const struct ctfb_res_modes res_mode_init[RES_MODES_COUNT] = {
 	/* x	 y pixclk   le	ri  up	lo   hs vs  s  vmode */
@@ -104,6 +105,7 @@ const struct ctfb_res_modes res_mode_init[RES_MODES_COUNT] = {
 	{960, 720, 13100, 160, 40, 32, 8, 80, 4, 0, FB_VMODE_NONINTERLACED},
 	{1152, 864, 12004, 200, 64, 32, 16, 80, 4, 0, FB_VMODE_NONINTERLACED},
 	{1280, 1024, 9090, 200, 48, 26, 1, 184, 3, 0, FB_VMODE_NONINTERLACED},
+	{240,   320,    158025, 26,     6,      1,      11,     37,     2, 0, FB_VMODE_NONINTERLACED},
 };
 
 /************************************************************************
diff --git a/drivers/video/videomodes.h b/drivers/video/videomodes.h
index 0d7c335..74bb2c5 100644
--- a/drivers/video/videomodes.h
+++ b/drivers/video/videomodes.h
@@ -22,8 +22,8 @@
  */
 
 
-#ifndef CONFIG_SYS_DEFAULT_VIDEO_MODE
-#define CONFIG_SYS_DEFAULT_VIDEO_MODE	0x301
+#ifndef CFG_SYS_DEFAULT_VIDEO_MODE
+#define CFG_SYS_DEFAULT_VIDEO_MODE	0x211
 #endif
 
 /* Some mode definitions */
@@ -78,9 +78,11 @@ struct ctfb_vesa_modes {
 #define RES_MODE_960_720	3
 #define RES_MODE_1152x864	4
 #define RES_MODE_1280x1024	5
-#define RES_MODES_COUNT		6
+#define RES_MODE_240x320	6
 
-#define VESA_MODES_COUNT 19
+#define RES_MODES_COUNT		7
+
+#define VESA_MODES_COUNT 20
 
 extern const struct ctfb_vesa_modes vesa_modes[];
 extern const struct ctfb_res_modes res_mode_init[];
diff --git a/include/asm-arm/arch-s3c24x0/mmc.h b/include/asm-arm/arch-s3c24x0/mmc.h
new file mode 100644
index 0000000..5da7108
--- /dev/null
+++ b/include/asm-arm/arch-s3c24x0/mmc.h
@@ -0,0 +1,113 @@
+/*
+ *  linux/drivers/mmc/mmc_pxa.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_PXA_P_H__
+#define __MMC_PXA_P_H__
+
+#include <asm/arch/regs-sdi.h>
+
+#define MMC_DEFAULT_RCA			(1<<16)
+
+#define MMC_BLOCK_SIZE			512
+#define MMC_CMD_RESET			0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID 		2
+#define MMC_CMD_SET_RCA			3
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_IF_COND                 8
+#define MMC_CMD_SEND_CSD 		9
+#define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_BLOCK		17
+#define MMC_CMD_RD_BLK_MULTI		18
+#define MMC_CMD_WRITE_BLOCK		24
+
+#define MMC_MAX_BLOCK_SIZE		512
+
+#define MMC_R1_IDLE_STATE		0x01
+#define MMC_R1_ERASE_STATE		0x02
+#define MMC_R1_ILLEGAL_CMD		0x04
+#define MMC_R1_COM_CRC_ERR		0x08
+#define MMC_R1_ERASE_SEQ_ERR		0x01
+#define MMC_R1_ADDR_ERR			0x02
+#define MMC_R1_PARAM_ERR		0x04
+
+#define MMC_R1B_WP_ERASE_SKIP		0x0002
+#define MMC_R1B_ERR			0x0004
+#define MMC_R1B_CC_ERR			0x0008
+#define MMC_R1B_CARD_ECC_ERR		0x0010
+#define MMC_R1B_WP_VIOLATION		0x0020
+#define MMC_R1B_ERASE_PARAM		0x0040
+#define MMC_R1B_OOR			0x0080
+#define MMC_R1B_IDLE_STATE		0x0100
+#define MMC_R1B_ERASE_RESET		0x0200
+#define MMC_R1B_ILLEGAL_CMD		0x0400
+#define MMC_R1B_COM_CRC_ERR		0x0800
+#define MMC_R1B_ERASE_SEQ_ERR		0x1000
+#define MMC_R1B_ADDR_ERR		0x2000
+#define MMC_R1B_PARAM_ERR		0x4000
+
+typedef struct mmc_cid
+{
+	/* FIXME: BYTE_ORDER */
+	uchar	year:4,
+		month:4;
+	uchar	sn[3];
+	uchar	fwrev:4,
+		hwrev:4;
+	uchar	name[6];
+	uchar	id[3];
+} mmc_cid_t;
+
+typedef struct mmc_csd
+{
+	uchar	ecc:2,
+		file_format:2,
+		tmp_write_protect:1,
+		perm_write_protect:1,
+		copy:1,
+		file_format_grp:1;
+	uint64_t content_prot_app:1,
+		rsvd3:4,
+		write_bl_partial:1,
+		write_bl_len:4,
+		r2w_factor:3,
+		default_ecc:2,
+		wp_grp_enable:1,
+		wp_grp_size:5,
+		erase_grp_mult:5,
+		erase_grp_size:5,
+		c_size_mult1:3,
+		vdd_w_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_r_curr_min:3,
+		c_size:12,
+		rsvd2:2,
+		dsr_imp:1,
+		read_blk_misalign:1,
+		write_blk_misalign:1,
+		read_bl_partial:1;
+
+	ushort	read_bl_len:4,
+		ccc:12;
+	uchar	tran_speed;
+	uchar	nsac;
+	uchar	taac;
+	uchar	rsvd1:2,
+  		spec_vers:4,
+		csd_structure:2;
+} mmc_csd_t;
+
+
+#endif /* __MMC_PXA_P_H__ */
diff --git a/include/asm-arm/arch-s3c24x0/regs-sdi.h b/include/asm-arm/arch-s3c24x0/regs-sdi.h
new file mode 100644
index 0000000..9597542
--- /dev/null
+++ b/include/asm-arm/arch-s3c24x0/regs-sdi.h
@@ -0,0 +1,110 @@
+/* linux/include/asm/arch-s3c2410/regs-sdi.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 MMC/SDIO register definitions
+ *
+ *  Changelog:
+ *    18-Aug-2004 Ben Dooks      Created initial file
+ *    29-Nov-2004 Koen Martens   Added some missing defines, fixed duplicates
+ *    29-Nov-2004 Ben Dooks	 Updated Koen's patch
+*/
+
+#ifndef __ASM_ARM_REGS_SDI
+#define __ASM_ARM_REGS_SDI "regs-sdi.h"
+
+#define S3C2440_SDICON_SDRESET        (1<<8)
+#define S3C2440_SDICON_MMCCLOCK       (1<<5)
+#define S3C2410_SDICON_BYTEORDER      (1<<4)
+#define S3C2410_SDICON_SDIOIRQ        (1<<3)
+#define S3C2410_SDICON_RWAITEN        (1<<2)
+#define S3C2410_SDICON_FIFORESET      (1<<1)
+#define S3C2410_SDICON_CLOCKTYPE      (1<<0)
+
+#define S3C2410_SDICMDCON_ABORT       (1<<12)
+#define S3C2410_SDICMDCON_WITHDATA    (1<<11)
+#define S3C2410_SDICMDCON_LONGRSP     (1<<10)
+#define S3C2410_SDICMDCON_WAITRSP     (1<<9)
+#define S3C2410_SDICMDCON_CMDSTART    (1<<8)
+#define S3C2410_SDICMDCON_SENDERHOST  (1<<6)
+#define S3C2410_SDICMDCON_INDEX       (0x3f)
+
+#define S3C2410_SDICMDSTAT_CRCFAIL    (1<<12)
+#define S3C2410_SDICMDSTAT_CMDSENT    (1<<11)
+#define S3C2410_SDICMDSTAT_CMDTIMEOUT (1<<10)
+#define S3C2410_SDICMDSTAT_RSPFIN     (1<<9)
+#define S3C2410_SDICMDSTAT_XFERING    (1<<8)
+#define S3C2410_SDICMDSTAT_INDEX      (0xff)
+
+#define S3C2440_SDIDCON_DS_BYTE       (0<<22)
+#define S3C2440_SDIDCON_DS_HALFWORD   (1<<22)
+#define S3C2440_SDIDCON_DS_WORD       (2<<22)
+#define S3C2410_SDIDCON_IRQPERIOD     (1<<21)
+#define S3C2410_SDIDCON_TXAFTERRESP   (1<<20)
+#define S3C2410_SDIDCON_RXAFTERCMD    (1<<19)
+#define S3C2410_SDIDCON_BUSYAFTERCMD  (1<<18)
+#define S3C2410_SDIDCON_BLOCKMODE     (1<<17)
+#define S3C2410_SDIDCON_WIDEBUS       (1<<16)
+#define S3C2410_SDIDCON_DMAEN         (1<<15)
+#define S3C2410_SDIDCON_STOP          (1<<14)
+#define S3C2440_SDIDCON_DATSTART      (1<<14)
+#define S3C2410_SDIDCON_DATMODE	      (3<<12)
+#define S3C2410_SDIDCON_BLKNUM        (0x7ff)
+
+/* constants for S3C2410_SDIDCON_DATMODE */
+#define S3C2410_SDIDCON_XFER_READY    (0<<12)
+#define S3C2410_SDIDCON_XFER_CHKSTART (1<<12)
+#define S3C2410_SDIDCON_XFER_RXSTART  (2<<12)
+#define S3C2410_SDIDCON_XFER_TXSTART  (3<<12)
+
+#define S3C2410_SDIDCNT_BLKNUM_MASK   (0xFFF)
+#define S3C2410_SDIDCNT_BLKNUM_SHIFT  (12)
+
+#define S3C2410_SDIDSTA_RDYWAITREQ    (1<<10)
+#define S3C2410_SDIDSTA_SDIOIRQDETECT (1<<9)
+#define S3C2410_SDIDSTA_FIFOFAIL      (1<<8)	/* reserved on 2440 */
+#define S3C2410_SDIDSTA_CRCFAIL       (1<<7)
+#define S3C2410_SDIDSTA_RXCRCFAIL     (1<<6)
+#define S3C2410_SDIDSTA_DATATIMEOUT   (1<<5)
+#define S3C2410_SDIDSTA_XFERFINISH    (1<<4)
+#define S3C2410_SDIDSTA_BUSYFINISH    (1<<3)
+#define S3C2410_SDIDSTA_SBITERR       (1<<2)	/* reserved on 2410a/2440 */
+#define S3C2410_SDIDSTA_TXDATAON      (1<<1)
+#define S3C2410_SDIDSTA_RXDATAON      (1<<0)
+
+#define S3C2440_SDIFSTA_FIFORESET      (1<<16)
+#define S3C2440_SDIFSTA_FIFOFAIL       (3<<14)  /* 3 is correct (2 bits) */
+#define S3C2410_SDIFSTA_TFDET          (1<<13)
+#define S3C2410_SDIFSTA_RFDET          (1<<12)
+#define S3C2410_SDIFSTA_TFHALF         (1<<11)
+#define S3C2410_SDIFSTA_TFEMPTY        (1<<10)
+#define S3C2410_SDIFSTA_RFLAST         (1<<9)
+#define S3C2410_SDIFSTA_RFFULL         (1<<8)
+#define S3C2410_SDIFSTA_RFHALF         (1<<7)
+#define S3C2410_SDIFSTA_COUNTMASK      (0x7f)
+
+#define S3C2410_SDIIMSK_RESPONSECRC    (1<<17)
+#define S3C2410_SDIIMSK_CMDSENT        (1<<16)
+#define S3C2410_SDIIMSK_CMDTIMEOUT     (1<<15)
+#define S3C2410_SDIIMSK_RESPONSEND     (1<<14)
+#define S3C2410_SDIIMSK_READWAIT       (1<<13)
+#define S3C2410_SDIIMSK_SDIOIRQ        (1<<12)
+#define S3C2410_SDIIMSK_FIFOFAIL       (1<<11)
+#define S3C2410_SDIIMSK_CRCSTATUS      (1<<10)
+#define S3C2410_SDIIMSK_DATACRC        (1<<9)
+#define S3C2410_SDIIMSK_DATATIMEOUT    (1<<8)
+#define S3C2410_SDIIMSK_DATAFINISH     (1<<7)
+#define S3C2410_SDIIMSK_BUSYFINISH     (1<<6)
+#define S3C2410_SDIIMSK_SBITERR        (1<<5)	/* reserved 2440/2410a */
+#define S3C2410_SDIIMSK_TXFIFOHALF     (1<<4)
+#define S3C2410_SDIIMSK_TXFIFOEMPTY    (1<<3)
+#define S3C2410_SDIIMSK_RXFIFOLAST     (1<<2)
+#define S3C2410_SDIIMSK_RXFIFOFULL     (1<<1)
+#define S3C2410_SDIIMSK_RXFIFOHALF     (1<<0)
+
+#endif /* __ASM_ARM_REGS_SDI */
diff --git a/include/asm-arm/arch-s3c24x0/s3c24x0.h b/include/asm-arm/arch-s3c24x0/s3c24x0.h
index 15f53dd..797fd39 100644
--- a/include/asm-arm/arch-s3c24x0/s3c24x0.h
+++ b/include/asm-arm/arch-s3c24x0/s3c24x0.h
@@ -78,7 +78,7 @@ struct s3c24x0_interrupt {
 	u32	PRIORITY;
 	u32	INTPND;
 	u32	INTOFFSET;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	SUBSRCPND;
 	u32	INTSUBMSK;
 #endif
@@ -88,11 +88,11 @@ struct s3c24x0_interrupt {
 /* DMAS (see manual chapter 8) */
 struct s3c24x0_dma {
 	u32	DISRC;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	DISRCC;
 #endif
 	u32	DIDST;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	DIDSTC;
 #endif
 	u32	DCON;
@@ -103,7 +103,7 @@ struct s3c24x0_dma {
 #ifdef CONFIG_S3C2400
 	u32	res[1];
 #endif
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	res[7];
 #endif
 };
@@ -122,6 +122,9 @@ struct s3c24x0_clock_power {
 	u32	CLKCON;
 	u32	CLKSLOW;
 	u32	CLKDIVN;
+#if defined (CONFIG_S3C2440)
+	u32	CAMDIVN;
+#endif
 };
 
 
@@ -141,7 +144,7 @@ struct s3c24x0_lcd {
 	u32	res[8];
 	u32	DITHMODE;
 	u32	TPAL;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	LCDINTPND;
 	u32	LCDSRCPND;
 	u32	LCDINTMSK;
@@ -149,7 +152,7 @@ struct s3c24x0_lcd {
 #endif
 };
 
-
+#if defined(CONFIG_S3C2410)
 /* NAND FLASH (see S3C2410 manual chapter 6) */
 struct s3c2410_nand {
 	u32	NFCONF;
@@ -159,7 +162,28 @@ struct s3c2410_nand {
 	u32	NFSTAT;
 	u32	NFECC;
 };
-
+#endif
+#if defined (CONFIG_S3C2440)
+/* NAND FLASH (see S3C2440 manual chapter 6) */
+struct s3c2410_nand {
+	u32	NFCONF;
+	u32	NFCONT;
+	u32	NFCMD;
+	u32	NFADDR;
+	u32	NFDATA;
+	u32	NFMECCD0;
+	u32	NFMECCD1;
+	u32	NFSECCD;
+	u32	NFSTAT;
+	u32	NFESTAT0;
+	u32	NFESTAT1;
+	u32	NFMECC0;
+	u32	NFMECC1;
+	u32	NFSECC;
+	u32	NFSBLK;
+	u32	NFEBLK;
+};
+#endif
 
 /* UART (see manual chapter 11) */
 struct s3c24x0_uart {
@@ -298,13 +322,13 @@ struct s3c24x0_usb_device {
 	u8	INDEX_REG;
 	u8	res9[7];
 	u8	MAXP_REG;
-	u8	res10[7];
+	u8	res10[3];
 	u8	EP0_CSR_IN_CSR1_REG;
 	u8	res11[3];
 	u8	IN_CSR2_REG;
-	u8	res12[3];
+	u8	res12[7];
 	u8	OUT_CSR1_REG;
-	u8	res13[7];
+	u8	res13[3];
 	u8	OUT_CSR2_REG;
 	u8	res14[3];
 	u8	OUT_FIFO_CNT1_REG;
@@ -312,8 +336,14 @@ struct s3c24x0_usb_device {
 	u8	OUT_FIFO_CNT2_REG;
 	u8	res16[3];
 #endif /*  __BIG_ENDIAN */
-	struct s3c24x0_usb_dev_fifos	fifo[5];
-	struct s3c24x0_usb_dev_dmas	dma[5];
+	u32	res17[8];
+ 	struct s3c24x0_usb_dev_fifos	fifo[5];
+	u32	res18[11];
+	struct s3c24x0_usb_dev_dmas	ep1;
+	struct s3c24x0_usb_dev_dmas	ep2;
+	u8	res19[16];
+	struct s3c24x0_usb_dev_dmas	ep3;
+	struct s3c24x0_usb_dev_dmas	ep4;
 };
 
 
@@ -397,7 +427,7 @@ struct s3c24x0_gpio {
 	u32	MISCCR;
 	u32	EXTINT;
 #endif
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	GPACON;
 	u32	GPADAT;
 	u32	res1[2];
@@ -446,6 +476,14 @@ struct s3c24x0_gpio {
 	u32	GSTATUS2;
 	u32	GSTATUS3;
 	u32	GSTATUS4;
+#if defined (CONFIG_S3C2440)
+	u32	res9[3];
+	u32	MSLCON;
+	u32	GPJCON;
+	u32	GPJDAT;
+	u32	GPJUP;
+
+#endif
 #endif
 };
 
@@ -639,6 +677,8 @@ struct s3c2410_sdi {
 	u32	SDIDCNT;
 	u32	SDIDSTA;
 	u32	SDIFSTA;
+#if defined(CONFIG_S3C2410)
+#if 0
 #ifdef __BIG_ENDIAN
 	u8	res[3];
 	u8	SDIDAT;
@@ -646,7 +686,13 @@ struct s3c2410_sdi {
 	u8	SDIDAT;
 	u8	res[3];
 #endif
+#endif
+	u32	SDIDAT;
 	u32	SDIIMSK;
+#elif defined(CONFIG_S3C2440)
+	u32	SDIIMSK;
+	u32	SDIDAT;
+#endif
 };
 
 #endif /*__S3C24X0_H__*/
diff --git a/include/asm-arm/arch-s3c24x0/s3c24x0_cpu.h b/include/asm-arm/arch-s3c24x0/s3c24x0_cpu.h
index c37d4a1..6585ee1 100644
--- a/include/asm-arm/arch-s3c24x0/s3c24x0_cpu.h
+++ b/include/asm-arm/arch-s3c24x0/s3c24x0_cpu.h
@@ -22,6 +22,8 @@
 	#include <asm/arch/s3c2400.h>
 #elif defined CONFIG_S3C2410
 	#include <asm/arch/s3c2410.h>
+#elif defined CONFIG_S3C2440
+	#include <asm/arch/s3c2410.h>
 #else
 	#error Please define the s3c24x0 cpu type
 #endif
diff --git a/include/configs/mini2440.h b/include/configs/mini2440.h
new file mode 100644
index 0000000..141c7dc
--- /dev/null
+++ b/include/configs/mini2440.h
@@ -0,0 +1,378 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Modified for the friendly-arm SBC-2410X by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * Configuation settings for the friendly-arm SBC-2410X board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#undef CONFIG_SKIP_LOWLEVEL_INIT	/* undef for developing */
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T	1	/* This is an ARM920T Core	*/
+#define CONFIG_S3C24X0	1	/* in a SAMSUNG S3C24x0-type SoC	*/
+//#define CONFIG_S3C2410	1	/* specifically a SAMSUNG S3C2410 SoC	*/
+//#define CONFIG_SBC2410X	1	/* on a friendly-arm SBC-2410X Board  */
+#define	CONFIG_S3C2440		1	/* in a SAMSUNG S3C2440 SoC     */
+#define CONFIG_MINI2440		1	/* on a friendly-arm MINI2440 Board  */
+#define CONFIG_MINI2440_LED 	1
+#define CONFIG_S3C2410_NAND_SKIP_BAD	1
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000/* the SBC2410X has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+
+//#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+#define CONFIG_USB_DEVICE 1
+#ifdef CONFIG_USB_DEVICE
+#define CONFIG_USE_IRQ 1
+#endif
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#if 0
+#define CONFIG_NET_MULTI
+#define CONFIG_CS8900		/* we have a CS8900 on-board */
+#define CONFIG_CS8900_BASE	0x19000300
+#define CONFIG_CS8900_BUS16	/* the Linux driver does accesses as shorts */
+#endif
+#define CONFIG_NET_MULTI		1
+#define CONFIG_NET_RETRY_COUNT		20
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_BASE		0x20000300
+#define DM9000_IO 			CONFIG_DM9000_BASE
+#define DM9000_DATA 			(CONFIG_DM9000_BASE+4)
+#define CONFIG_DM9000_USE_16BIT		1
+#define CONFIG_DM9000_NO_SROM		1
+#undef CONFIG_DM9000_DEBUG
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24X0_SERIAL
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SBC2410X */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+//#define CONFIG_MTD_DEVICE
+//#define CONFIG_CMD_MTDPARTS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_FAT 
+/* FAT support*/
+//#define CONFIG_CMD_EXT2
+
+#define CONFIG_CMD_JFFS2
+/* JFFS2 Support*/
+#define CONFIG_CMD_USB
+/* USB Support*/
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTARGS		"noinitrd root=/dev/nfs rw nfsroot=192.168.0.1:/home/tekkaman/working/nfs/rootfs ip=192.168.0.2:192.168.0.1::255.255.255.0 console=ttySAC0,115200 init=/linuxrc mem=64M"
+#define CONFIG_ETHADDR	        08:08:11:18:12:27
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		192.168.0.2
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_GATEWAYIP	192.168.0.1
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/*#define CONFIG_BOOTFILE	"elinos-lart" */
+#define CONFIG_BOOTCOMMAND	"nfs 0x30008000 192.168.0.1:/home/tekkaman/working/nfs/zImage.img;bootm"
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+	"tekkaman=bmp d 70000\0 "				\
+	"stdin=serial\0"					\
+	"stdout=serial\0"					\
+	"stderr=serial\0"					\
+	""
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+#define	CONFIG_SYS_PROMPT		"[u-boot@MINI2440]# "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+
+#define	CONFIG_SYS_LOAD_ADDR		0x30008000	/* default load address	*/
+
+#define	CONFIG_SYS_HZ			1000
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+/* #define CONFIG_AMD_LV400	1	/\* uncomment this if you have a LV400 flash *\/ */
+
+//#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+#define CONFIG_SST_VF1601	1	/* uncomment this if you have a Am29LV160DB flash */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ) /* Timeout for Flash Write */
+
+
+//#if 0
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_I2C
+
+#define CONFIG_DRIVER_S3C24X0_I2C    1    /* we use the buildin I2C controller */
+#define CONFIG_HARD_I2C    1        /* I2C with hardware support */
+
+#define CONFIG_SYS_I2C_SPEED        100000    /* I2C speed and slave address */
+#define CONFIG_SYS_I2C_SLAVE        0x7F
+
+#define CONFIG_SYS_I2C_EEPROM_ADDR        0x50    /* EEPROM at24c08        */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN     1    /* Bytes of address        */
+/* mask of address bits that overflow into the "EEPROM chip address"    */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW    0x07
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 4    /* The Catalyst CAT24WC08 has    */
+                    /* 16 byte page write mode using*/
+                    /* last 4 bits of the address    */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS    10   /* and takes up to 10 msec */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_ENABLE
+
+//#define CONFIG_ENV_IS_IN_EEPROM    1    /* use EEPROM for environment vars */
+//#define CONFIG_ENV_OFFSET       0x000    /* environment starts at offset 0 */
+//#define CONFIG_ENV_SIZE	        0x400    /* 1KB  */
+
+//#else 
+#define CONFIG_ENV_IS_IN_NAND 1
+//#define CONFIG_ENV_IS_IN_FLASH 1
+#define CONFIG_ENV_OFFSET 0X60000
+#define CONFIG_ENV_SIZE			0x20000	/* Total Size of Environment Sector */
+//#endif
+
+/* == LENGTH_UBOOT*/
+#ifdef CONFIG_SST_VF1601
+#define PHYS_FLASH_SIZE		0x00200000 /* 2MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(32)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET) /* addr of environment */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#if defined(CONFIG_CMD_NAND)
+#define CONFIG_NAND_S3C2410
+#define CONFIG_SYS_NAND_BASE 0x4E000000 
+#define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices		*/
+#define SECTORSIZE 512
+#define SECTORSIZE_2K 2048
+#define NAND_SECTOR_SIZE SECTORSIZE
+#define NAND_SECTOR_SIZE_2K SECTORSIZE_2K
+#define NAND_BLOCK_MASK 511
+#define NAND_BLOCK_MASK_2K 2047
+#define NAND_MAX_CHIPS 1
+#define CONFIG_MTD_NAND_VERIFY_WRITE 
+#define CONFIG_SYS_64BIT_VSPRINTF		/* needed for nand_util.c */
+#endif	/* CONFIG_CMD_NAND */
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_TAG
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2   "> "
+
+#define CONFIG_CMDLINE_EDITING
+
+//#ifdef CONFIG_CMDLINE_EDITING
+//#undef CONFIG_AUTO_COMPLETE
+//#else
+#define CONFIG_AUTO_COMPLETE
+//#endif
+
+
+#if 1
+#define CONFIG_USB_OHCI
+#define CONFIG_USB_STORAGE
+//#define CONFIG_KEYBOARD
+//#define CONFIG_USB_KEYBOARD
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SYS_DEVICE_DEREGISTER
+#define CONFIG_SUPPORT_VFAT
+#define LITTLEENDIAN
+#endif 
+
+#define CONFIG_JFFS2_NAND 1
+//#undef CONFIG_JFFS2_CMDLINE
+#define CONFIG_JFFS2_DEV	"nand0"
+#define CONFIG_JFFS2_PART_SIZE	0x480000
+#define CONFIG_JFFS2_PART_OFFSET	0x80000
+
+#define CONFIG_JFFS2_CMDLINE 1
+#define MTDIDS_DEFAULT "nand0=nandflash0"
+#define MTDPARTS_DEFAULT "mtdparts=nandflash0:384k(bootloader)," \
+					      "128k(params)," \
+					      "5m(kernel)," \
+					      "-(root)"
+
+
+#define ENABLE_CMD_LOADB_X	1
+#define ENABLE_CMD_NAND_YAFFS	1
+#define ENABLE_CMD_NAND_YAFFS_SKIPFB	1
+//#define CFG_NAND_YAFFS1_NEW_OOB_LAYOUT	1
+
+#if 1
+#define CONFIG_CMD_BMP 
+#define CONFIG_VIDEO 
+#define CONFIG_VIDEO_S3C2410 
+#define CONFIG_VIDEO_LOGO 
+#define VIDEO_FB_16BPP_WORD_SWAP 
+
+#define CONFIG_VIDEO_SW_CURSOR 
+#define CONFIG_VIDEO_BMP_LOGO 
+//#define CONFIG_CONSOLE_EXTRA_INFO
+//#define CONFIG_CONSOLE_CURSOR
+//#define CONFIG_CONSOLE_TIME
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+//#define CFG_CONSOLE_INFO_QUIET 
+//#define VIDEO_FB_LITTLE_ENDIAN 
+#define CONFIG_SPLASH_SCREEN 
+#define CONFIG_SYS_VIDEO_LOGO_MAX_SIZE         (240*320+1024+100) /* 100 = slack */ 
+#define CONFIG_VIDEO_BMP_GZIP 
+#define CONFIG_CMD_UNZIP 
+#define LCD_VIDEO_ADDR         0x33d00000
+
+/*for PC-keyboard*/
+#define VIDEO_KBD_INIT_FCT     0 
+#define VIDEO_TSTC_FCT         serial_tstc 
+#define VIDEO_GETC_FCT         serial_getc
+
+#endif
+
+/*for SD Card*/
+#define CONFIG_CMD_MMC
+#define CONFIG_MMC		1
+#define CONFIG_MMC_S3C	1	/* Enabling the MMC driver */
+#define CFG_MMC_BASE		0xff000000
+
+
+#if 0
+#define CONFIG_YAFFS2
+//#undef CONFIG_YAFFS_YAFFS2
+#undef CONFIG_YAFFS_NO_YAFFS1
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 16556c4..5314051 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -129,6 +129,12 @@ struct mtd_info {
 	 */
 	u_int32_t writesize;
 
+#if defined(ENABLE_CMD_NAND_YAFFS)
+		/*Thanks for hugerat's code*/
+	u_char rw_oob;
+	u_char skipfirstblk;
+#endif
+
 	u_int32_t oobsize;   /* Amount of OOB data per block (e.g. 16) */
 	u_int32_t oobavail;  /* Available OOB bytes per block */
 
diff --git a/include/mmc.h b/include/mmc.h
index 8973bc7..5fe484b 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -169,7 +169,7 @@
 #define MMC_RSP_R6      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 #define MMC_RSP_R7      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 
-
+#if 0
 struct mmc_cid {
 	unsigned long psn;
 	unsigned short oid;
@@ -218,7 +218,7 @@ struct mmc_csd
 	u8	crc:7;
 	u8	one:1;
 };
-
+#endif
 struct mmc_cmd {
 	ushort cmdidx;
 	uint resp_type;
@@ -268,8 +268,10 @@ struct mmc {
 
 int mmc_register(struct mmc *mmc);
 int mmc_initialize(bd_t *bis);
-int mmc_init(struct mmc *mmc);
-int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size);
+//int mmc_init(struct mmc *mmc);
+//int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size);
+int mmc_init(int verbose);
+int mmc_read(ulong src, uchar *dst, int size);
 struct mmc *find_mmc_device(int dev_num);
 void print_mmc_devices(char separator);
 int board_mmc_getcd(u8 *cd, struct mmc *mmc);
diff --git a/include/part.h b/include/part.h
index 3cdae02..f877b1d 100644
--- a/include/part.h
+++ b/include/part.h
@@ -62,6 +62,7 @@ typedef struct block_dev_desc {
 #define IF_TYPE_MMC		6
 #define IF_TYPE_SD		7
 #define IF_TYPE_SATA		8
+#define IF_TYPE_SDHC		9
 
 /* Part types */
 #define PART_TYPE_UNKNOWN	0x00
diff --git a/include/serial.h b/include/serial.h
index f2638ec..dfdfa6a 100644
--- a/include/serial.h
+++ b/include/serial.h
@@ -37,7 +37,7 @@ extern struct serial_device eserial4_device;
 
 #endif
 
-#if defined(CONFIG_S3C2410)
+#if defined(CONFIG_S3C2410) ||  defined(CONFIG_S3C2440)
 extern struct serial_device s3c24xx_serial0_device;
 extern struct serial_device s3c24xx_serial1_device;
 extern struct serial_device s3c24xx_serial2_device;
diff --git a/lib_arm/board.c b/lib_arm/board.c
index f5660a9..d598a82 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -49,6 +49,8 @@
 #include <nand.h>
 #include <onenand_uboot.h>
 #include <mmc.h>
+#include <asm/arch/s3c24x0_cpu.h>   //tekkamanninja
+#include <asm/io.h>   //tekkamanninja
 
 #ifdef CONFIG_BITBANGMII
 #include <miiphy.h>
@@ -70,6 +72,10 @@ extern int  AT91F_DataflashInit(void);
 extern void dataflash_print_info(void);
 #endif
 
+#ifdef CONFIG_USB_DEVICE
+extern void usb_init_slave(void);
+#endif
+
 #ifndef CONFIG_IDENT_STRING
 #define CONFIG_IDENT_STRING ""
 #endif
@@ -86,7 +92,7 @@ extern void rtl8019_get_enetaddr (uchar * addr);
 #include <i2c.h>
 #endif
 
-
+#if 0
 /************************************************************************
  * Coloured LED functionality
  ************************************************************************
@@ -110,6 +116,7 @@ void inline __blue_LED_on(void) {}
 void blue_LED_on(void) __attribute__((weak, alias("__blue_LED_on")));
 void inline __blue_LED_off(void) {}
 void blue_LED_off(void) __attribute__((weak, alias("__blue_LED_off")));
+#endif
 
 /************************************************************************
  * Init Utilities							*
@@ -135,7 +142,13 @@ static int init_baudrate (void)
 
 static int display_banner (void)
 {
-	printf ("\n\n%s\n\n", version_string);
+#if defined(CONFIG_MINI2440_LED) 	
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+	writel(0x101, &gpio->GPBDAT);  //tekkamanninja
+#endif
+	printf ("\n\n%s\n\n", version_string);	
+	printf (" modified by tekkamanninja (tekkamanninja@163.com)\n");
+	printf (" Love Linux forever!!\n\n");
 	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
 	       _armboot_start, _bss_start, _bss_end);
 #ifdef CONFIG_MODEM_SUPPORT
@@ -275,7 +288,9 @@ void start_armboot (void)
 #if defined(CONFIG_VFD) || defined(CONFIG_LCD)
 	unsigned long addr;
 #endif
-
+#if defined(CONFIG_MINI2440_LED) 	
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+#endif
 	/* Pointer is writable since we allocated a register for it */
 	gd = (gd_t*)(_armboot_start - CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));
 	/* compiler optimization barrier needed for GCC >= 3.4 */
@@ -381,10 +396,12 @@ void start_armboot (void)
 	/* miscellaneous platform dependent initialisations */
 	misc_init_r ();
 #endif
-
 	/* enable exceptions */
 	enable_interrupts ();
 
+#ifdef CONFIG_USB_DEVICE
+	usb_init_slave();
+#endif
 	/* Perform network card initialisation if necessary */
 #ifdef CONFIG_DRIVER_TI_EMAC
 	/* XXX: this needs to be moved to board init */
@@ -437,6 +454,15 @@ extern void davinci_eth_set_mac_addr (const u_int8_t *addr);
 	reset_phy();
 #endif
 #endif
+#if defined(CONFIG_MINI2440_LED) 	
+	writel(0x0, &gpio->GPBDAT);  //tekkamanninja
+#endif
+ 
+#if defined(CONFIG_CFB_CONSOLE)        
+	printf ("%s\n", version_string);
+	printf ("modified by tekkamanninja\n(tekkamanninja@163.com)\n");
+	printf ("Love Linux forever!!\n");
+#endif
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop ();
diff --git a/net/nfs.c b/net/nfs.c
index d11bb4c..53e0cd5 100644
--- a/net/nfs.c
+++ b/net/nfs.c
@@ -31,7 +31,7 @@
 
 #define HASHES_PER_LINE 65	/* Number of "loading" hashes per line	*/
 #define NFS_RETRY_COUNT 30
-#define NFS_TIMEOUT 2000UL
+#define NFS_TIMEOUT (10*2000UL)
 
 static int fs_mounted = 0;
 static unsigned long rpc_id = 0;
-- 
1.7.0.4

